#ifdef WIN32
#include <direct.h>
#include <io.h>
#else
#include <unistd.h>
#endif
#include <stdio.h>
#include <stdlib.h>
#include "dt_lib.h"

#include "zlib.h"
#define COMPRESSLEVEL 5

#ifdef __unix
int uCopyFile(const char * src,const char *dest) {
 FILE *fsrc=fopen(src,"rb");
 if(fsrc==NULL) 
   ThrowWith("Open source file error while copy file '%s' to '%s'",
 	  	   src,dest);
 FILE *fdest=fopen(dest,"w+b");
 if(fdest==NULL) {
 	ThrowWith("Create dest file error while copy file '%s' to '%s'",
 	  	   src,dest);
 	fclose(fsrc);
 	return -2;
 }
 char buf[1024];
 for(;;) {
 	int l=fread(buf,1,1024,fsrc);
 	if(l>0) {
 	  l=fwrite(buf,1,l,fdest);
 	  if(l<1) {
 	  	fclose(fsrc);
 	  	fclose(fdest);
 	  	ThrowWith("Wirte file error while copy file '%s' to '%s'",
 	  	   src,dest);
 	  }
 	}
 	else break;
 	  
 }
 fclose(fsrc);
 fclose(fdest);
 return 1;		
}
#endif

int CreateMtFromFile(int maxrows,char *filename)
{
	FILE *fp=fopen(filename,"rb");
	if(!fp)
		ThrowWith("CreateMt from file '%s' which could not open.",filename);
	int cdlen=0,cdnum=0;
	fread(&cdlen,sizeof(int),1,fp);
	fread(&cdnum,sizeof(int),1,fp);
	if(cdlen==0 || cdnum==0)
		ThrowWith("read columns info from file 's' error!",filename);
	char *pbf=new char[cdlen];
	if(fread(pbf,1,cdlen,fp)!=cdlen) {
		delete [] pbf;
		ThrowWith("read columns info from file 's' error!",filename);
	}
	int mt=wociCreateMemTable();
	wociImport(mt,NULL,0,pbf,cdnum,maxrows,0);
	delete []pbf;
	return mt;
}

	MySQLConn::MySQLConn() {
		memset(host,0,sizeof(host));
		memset(username,0,sizeof(username));
		memset(password,0,sizeof(password));
		memset(dbname,0,sizeof(dbname));
		myData=NULL;
		result=NULL;
	}

	void MySQLConn::SelectDB(char *db) {
		if(!myData) ThrowWith("Connection has not build while select db:%s\n",db);
		if ( mysql_select_db( myData, db ) < 0 ) {
			mysql_close( myData ) ;
			ThrowWith( "Can't select the %s database !\n", dbname ) ;
		}
	}

	void MySQLConn::Connect(char *host,char *username,char *password,char *dbname,unsigned int portnum) {
		if(host) strcpy(this->host,host);
		else this->host[0]=0;
		if(username) strcpy(this->username,username);
		else strcpy(this->username,"root");
		if(password) strcpy(this->password,password);
		else strcpy(this->password,"root");
		if(dbname) strcpy(this->dbname,dbname);
		else strcpy(this->dbname,"mysql");
		if(portnum!=0) this->portnum=portnum;
		else portnum=3306;
		if ( (myData = mysql_init((MYSQL*) 0)) && 
         mysql_real_connect( myData, host,username,password,NULL,portnum,
			   NULL, 0 ) )
		{
			if ( mysql_select_db( myData, this->dbname ) < 0 ) {
				mysql_close( myData ) ;
				myData=NULL;
				ThrowWith( "Can't select the '%s' database !\n", this->dbname ) ;
			}
		}
		else {
			myData=NULL;
			ThrowWith( "Can't connect to the mysql server on port %d !\n",
					portnum ) ;
		}
	}

	void MySQLConn::DoQuery(const char *szSQL)
	{
		if(!myData) ThrowWith("Connection has not build while query:%s\n",szSQL);
		if(result) {
			mysql_free_result(result);
			result=NULL;
		}
		//char dstsql[3000];
		//mysql_real_escape_string(myData,dstsql,szSQL,strlen(szSQL));
		if ( mysql_query( myData, szSQL)) {//dstsql,strlen(dstsql) ) ) 
			if(mysql_errno(myData)==1091 || mysql_errno(myData)==1146) return ;
  		 ThrowWith( "Couldn't execute %s on the server !\n errcode:%d,info:%s\n", szSQL ,
			 mysql_errno(myData),mysql_error(myData)) ;
		}
		result=mysql_store_result(myData);
		if(!result) {
			//ERROR 1091: Can't DROP 'tab_gsmvoicdr2_2'. Check that column/key exists
			//if(mysql_errno(myData)==1091) return ;
			if (mysql_errno(myData))
			{
				ThrowWith("Error: %s\n", mysql_error(myData));
			}
			else if (mysql_field_count(myData) == 0)
			{
				// query does not return data
				// (it was not a SELECT)
				num_rows = mysql_affected_rows(myData);
				const char *info=mysql_info(myData) ;
				if(info) lgprintf(info);
			}
		}
	}

	bool MySQLConn::TouchTable(const char *tabname) {
		if(!myData) ThrowWith("Connection has not build while touchtable:%s\n",tabname);
		char sql[300];
		sprintf(sql,"desc %s",tabname);
		if(result) {
			mysql_free_result(result);
			result=NULL;
		}
		if ( mysql_query( myData, sql ) ) {
		 if(mysql_errno(myData)==1146) return false;
  		 ThrowWith( "Couldn't execute %s on the server !\n errcode:%d,info:%s\n", sql ,
			 mysql_errno(myData),mysql_error(myData)) ;
		}
		result=mysql_store_result(myData);
		return true;
	}


	
	void SysAdmin::CreateDT(int tabp,int srctabp) 
	{
	    MySQLConn conn;
	    conn.Connect(NULL,NULL,NULL,"dt");
		int srcid=dt_srctable.GetInt("srcsysid",srctabp);
		int srcidp=wociSearchIK(dt_srcsys,srcid);
		int tabid=dt_table.GetInt("tabid",tabp);
		//Reset recordnum before create data table and index
		char sqlbf[200];
		sprintf(sqlbf,"update dt.dt_table set recordnum=0 where tabid=%d",tabid);
		lgprintf("记录数清零...");
		conn.DoQuery(sqlbf);

		lgprintf("Flush MySQL...");
		conn.DoQuery("flush tables");
		//建立到数据源的连接
		AutoHandle srcsys;
		char tabname[300];
		const char *pathval=GetPathName(0,"cdes");
		srcsys.SetHandle(BuildSrcDBC(srcidp));
	    //构造源数据的内存表结构
		AutoMt srcmt(srcsys,0);
		srcmt.SetHandle(GetSrcTableStructMt(srctabp,tabp,srcsys));

		//创建目标表
		char *dbsn=dt_table.PtrStr("databasename",tabp);
		conn.SelectDB(dbsn);
		strcpy(tabname,dt_table.PtrStr("tabname",tabp));
		bool newdttab=CreateTableOnMysql(pathval,conn,srcmt,tabname,tabid,0,0,true);
		
		//建立索引表和目标表、索引表的索引
		AutoMt idxtarget(dts,100);
		AutoMt idxmt(dts,100);
		//每一个独立索引都需要建立索引表
		idxmt.FetchAll("select * from dt_index where tabid=%d and issoledindex=1",
			tabid);
		int rn=idxmt.Wait();
		if(rn<1) 
			ThrowWith("no soled index defined in table '%s'",
			  dt_srctable.PtrStr("srctabname",srctabp));
		for(int i=0;i<rn;i++) {
			CreateIndexTable(conn,srcmt,tabid,idxmt.GetInt("indexid",i),
				idxmt.PtrStr("indextabname",i),idxmt.PtrStr("columnsname",i),pathval,true);
			CreateIndex(tabname,idxmt.PtrStr("indextabname",i),0,conn,tabid,
				idxmt.GetInt("indexid",i),true);
		}
	}


DataDump::DataDump(int dtdbc,int maxmem,int maxrows):fnmt(dtdbc,300)
{
	this->dtdbc=dtdbc;
	//Create fnmt and build column structrues.
	fnmt.FetchAll("select * from dt_middledatafile where rownum<1");
	fnmt.Wait();
	fnmt.Reset();
	taskid=srctabid=indexid=0;
	memlimit=maxmem;
	idxmaxrows=maxrows;
	maxblockrn=0;
}

int DataDump::BuildMiddleFilePath(int partid,int idx) {
	int fid=taskid*10000+fnorder++;
	sprintf(tmpfn,"%smddt_%d_%d_%d_%d_%d.dat",dp.tmppath[0],
		datasetid,srctabid,partid,idx,fid);
	sprintf(tmpidxfn,"%smdidx_%d_%d_%d_%d_%d.dat",dp.tmppath[0],
		datasetid,srctabid,partid,idx,fid);
	while(true) {
		int freem=GetFreeM(tmpfn);
		if(freem<1024) {
			lgprintf("Available space on hard disk less then 1G : %dM,waitting 5 minutes for free...",freem);
#ifdef WIN32
			Sleep(300000);
#else
			sleep(300);
#endif
		}
		else break;
	}
	return fid;
}

void DataDump::ProcBlock(int partid,AutoMt *pCur,int idx,AutoMt &blockmt)
{
	int fid=BuildMiddleFilePath(partid,idx);
	blockmt.Reset();
	int cur=*pCur;
	char *idxcolsname=dp.idxp[idx].idxcolsname;
	int *ikptr=NULL;
	int strow=-1;
	int subrn=0;
	int blockrn=0;
	lgprintf("Build idxdt...");
	AutoMt idxdt(0,idxmaxrows);
	wociCopyColumnDefine(idxdt,cur,idxcolsname);
	wociAddColumn(idxdt,"idx_blockoffset","",COLUMN_TYPE_INT,0,0);
//	wociAddColumn(idxdt,"idx_storesize","",COLUMN_TYPE_INT,0,0);
	wociAddColumn(idxdt,"idx_startrow","",COLUMN_TYPE_INT,0,0);
	wociAddColumn(idxdt,"idx_rownum","",COLUMN_TYPE_INT,0,0);
	wociAddColumn(idxdt,"idx_fid","",COLUMN_TYPE_INT,0,0);
	idxdt.Build();
	
	void *idxptr[20];
	int pidxc1[10];
	bool pkmode=false;
	lgprintf("Sorting ...");
	sorttm.Start();
	int cn1=wociConvertColStrToInt(cur,idxcolsname,pidxc1);
	if(cn1==1 && wociGetColumnType(cur,pidxc1[0])==COLUMN_TYPE_INT)
		pkmode=true;
	if(!pkmode) {
		wociSetSortColumn(cur,idxcolsname);
		wociSort(cur);
	}
	else {
		wociSetIKByName(cur,idxcolsname);
		wociOrderByIK(cur);
		wociGetIntAddrByName(cur,idxcolsname,0,&ikptr);
	}
	sorttm.Stop();
	lgprintf("Sort ended,pkmode:%d.idx coln :%d,colname:%s",pkmode?1:0,cn1,idxcolsname);
	int idx_blockoffset=0,idx_store_size=0,idx_startrow=0,idx_rownum=0;
	int idxc=cn1;
	idxptr[idxc++]=&idx_blockoffset;
//	idxptr[idxc++]=&idx_store_size;
	idxptr[idxc++]=&idx_startrow;
	idxptr[idxc++]=&idx_rownum;
	idxptr[idxc++]=&fid;
	idxptr[idxc]=NULL;
	dt_file df;
	lgprintf("prepare data file '%s' handle...",tmpfn);
	df.Open(tmpfn,1,fid);
	lgprintf("write file header...");
	idx_blockoffset=df.WriteHeader(cur);
	idxdt.Reset();
	int rn=wociGetMemtableRows(cur);
	adjtm.Start();
	lgprintf("Block process...");
	for(int i=0;i<rn;i++) {
		int thisrow=pkmode?wociGetRawrnByIK(cur,i):wociGetRawrnBySort(cur,i);
		//int thisrow=wociGetRawrnByIK(cur,i);
		if(strow==-1) {
		 strow=thisrow;
		 idx_startrow=blockrn;
		}
		//子块分割
		else 
		  if(pkmode?(ikptr[strow]!=ikptr[thisrow]):
		    (wociCompareSortRow(cur,strow,thisrow)!=0) ){
		  //if(ikptr[strow]!=ikptr[thisrow]) {
			for(int c=0;c<cn1;c++) {
				idxptr[c]=pCur->PtrVoid(pidxc1[c],strow);
			}
			idx_rownum=blockrn-idx_startrow;
			wociInsertRows(idxdt,idxptr,NULL,1);
			strow=thisrow;
			idx_startrow=blockrn;
		}
		//blockmt.QuickCopyFrom(pcur,blockrn,thisrow);
		wociCopyRowsTo(cur,blockmt,-1,thisrow,1);
		blockrn++;//=wociGetMemtableRows(blockmt);
		//块和子块的分割
		if(blockrn>=maxblockrn) {
			adjtm.Stop();
			fiotm.Start();
			for(int c=0;c<cn1;c++) {
				idxptr[c]=pCur->PtrVoid(pidxc1[c],strow);
			}
			idx_rownum=blockrn-idx_startrow;
			wociInsertRows(idxdt,idxptr,NULL,1);
			idx_blockoffset=df.WriteMt(blockmt,COMPRESSLEVEL);
			idx_startrow=0;
			strow=-1;blockrn=0;
			blockmt.Reset();
			fiotm.Stop();
			adjtm.Start();
		}
	}
	adjtm.Stop();
	lgprintf("Save last data of block.");
	//保存最后的块数据
	if(blockrn) {
		for(int c=0;c<cn1;c++) {
			idxptr[c]=pCur->PtrVoid(pidxc1[c],strow);
		}
		idx_rownum=blockrn-idx_startrow;
		wociInsertRows(idxdt,idxptr,NULL,1);
		idx_blockoffset=df.WriteMt(blockmt,COMPRESSLEVEL);
		idx_startrow=0;
		strow=-1;blockrn=0;
		blockmt.Reset();
	}
	//保存索引数据
	{
		dt_file di;
		di.Open(tmpidxfn,1);
		di.WriteHeader(idxdt,wociGetMemtableRows(idxdt));
		di.WriteMt(idxdt,COMPRESSLEVEL);
	}
	//保存文件索引
	{
		void *ptr[20];
		int subdatasetid=(partid*100+idx)*100000+datasetid;
		ptr[0]=&fid;ptr[1]=&taskid;ptr[2]=&partid;
		ptr[3]=&subdatasetid;ptr[4]=&srctabid;ptr[5]=&dp.tabid;
		int rn=df.GetRowNum();
		int fl=df.GetLastOffset();
		ptr[6]=&rn;ptr[7]=&fl;
		char now[10];
		wociGetCurDateTime(now);
		ptr[8]=tmpfn;ptr[9]=tmpidxfn;ptr[10]=now;
		int state=1;
		ptr[11]=&state;
		char nuldt[10];
		memset(nuldt,0,10);
		ptr[12]=now;//nuldt;
		ptr[13]=&dp.idxp[idx].idxid;
		ptr[14]=dp.idxp[idx].idxcolsname;
		ptr[15]=dp.idxp[idx].idxreusecols;
		ptr[16]=&datasetid;
		ptr[17]=NULL;
		wociInsertRows(fnmt,ptr,NULL,1);
	}
	lgprintf("block proc end.");
}

int DataDump::DoDump(SysParam &sp) {
	taskid=sp.GetFirstTaskID(NEWTASK,srctabid,datasetid);
	if(taskid<1) return 0;
	sp.UpdateTaskStatus(DUMPING,taskid);
	sp.GetSoledInexParam(srctabid,&dp);
	xmkdir(dp.tmppath[0]);
	xmkdir(dp.tmppath[1]);
	//xmkdir(dp.dstpath[0]);
	//xmkdir(dp.dstpath[1]);
	//sp.UpdateTaskStatus(DUMPING,taskid);
	int partoff=0;
	int realrn=memlimit/dp.rowlen;
	if(realrn>dp.maxrecnum) realrn=dp.maxrecnum;
	{
	AutoStmt st(dtdbc);
	st.Prepare("delete from dt_middledatafile where datasetid=%d",datasetid);
	st.Execute(1);
	st.Wait();
	}
	//realrn=50000;
	//indexparam *ip=&dp.idxp[dp.psoledindex];
	maxblockrn=sp.GetMaxBlockRnFromSrcTab(srctabid);
	AutoMt blockmt(0,maxblockrn);
	fnmt.Reset();
	int partid=0;
	AutoHandle srcdbc;
	fnorder=0;
	srcdbc.SetHandle(sp.BuildSrcDBCFromSrcTableID(srctabid));
	while(partid=sp.GetDumpSQL(taskid,partoff++,dumpsql),partid!=-1) {
		//idxdt.Reset();
		
		TradeOffMt dtmt(0,realrn);
		AutoStmt stmt(srcdbc);
		stmt.Prepare(dumpsql);
		dtmt.Cur()->Build(stmt);
		dtmt.Next()->Build(stmt);
		blockmt.Clear();
		blockmt.Build(stmt);
		//准备数据索引表插入变量数组
		dtmt.FetchFirst();
		
		int rn=dtmt.Wait();
		while(rn>0) {
			dtmt.FetchNext();
			lgprintf("开始数据处理");
			for(int i=0;i<dp.soledindexnum;i++) {
				ProcBlock(partid,dtmt.Cur(),i/*dp.psoledindex*/,blockmt);
			}
			lgprintf("数据处理结束");
			rn=dtmt.Wait();
		}
		//delete dtmt;
		//delete stmt;
	}
//	{
//	AutoHandle dbc;
//	dbc.SetHandle(wociCreateSession("system","gcmanager","gctest"));
	wociAppendToDbTable(fnmt,"dt_middledatafile",dtdbc);
//	}
	lgprintf("数据抽取结束,任务状态1-->2,taskid:%d",taskid);
	sp.UpdateTaskStatus(DUMPED,taskid);
	lgprintf("sort time :%11.6f file io time :%11.6f adjust data time:%11.6f",
		sorttm.GetTime(),fiotm.GetTime(),adjtm.GetTime());
	lgprintf("结束");
	getch();
	//MYSQL中的MY_ISAM不支持事务处理，对MYSQL表的修改不需要提交.
	return 0;
}

MiddleDataLoader::MiddleDataLoader(SysParam *_sp):
	   indexmt(0,0),mdindexmt(0,0),blockmt(0,0),mdf(_sp->GetDTS(),300)
	  {
		  sp=_sp;
		  tmpfilenum=0;
		  pdtf=NULL;
		  pdtfid=NULL;
		  dtfidlen=0;
	  }

#define MAXINDEXRN 200000
int MiddleDataLoader::Load(MySQLConn &conn) {
	//Check deserved temporary(middle) fileset
	//检查状态为1的任务
	mdf.FetchAll("select * from dt_middledatafile where procstate<=1  order by subdatasetid");
	int rn=mdf.Wait();
	if(rn>0) {
		mdf.FetchAll("select * from dt_middledatafile where subdatasetid=%d",
			mdf.GetInt("subdatasetid",0));
		rn=mdf.Wait();
		if(rn<1) 
			ThrowWith("A Strange error ocur at MiddleDataLoader::Load : get a empty middledataset resultset");
	}
	else return 0;

	//取基本参数
	int subdatasetid=mdf.GetInt("subdatasetid",0);
	int srctabid=mdf.GetInt("srctabid",0);
	int indexid=mdf.GetInt("indexid",0);
	int datasetid=mdf.GetInt("datasetid",0);
	int tabid=mdf.GetInt("tabid",0);
	int taskid=mdf.GetInt("taskid",0);
	lgprintf("Find deserved middle load task,taskid:%d,indexid:%d",taskid,indexid);
	//目标表数据索引文件检查,数据子集编号相同的记录删除,但数据文件保留,需要手工删除.
	char sqlbf[200];
	sprintf(sqlbf,"update dt.dt_table set recordnum=0 where tabid=%d",tabid);
	lgprintf("记录数清零...");
	conn.DoQuery(sqlbf);
	lgprintf("源表锁定...");
	lgprintf("Flush MySQL...");
	conn.DoQuery("flush tables");
	AutoStmt st(sp->GetDTS());
	lgprintf("删除数据子集编号为%d的数据和索引记录...",subdatasetid);
	st.Prepare(" delete from dt_datafilemap where subdatasetid=%d",subdatasetid);
	st.Execute(1);
	st.Wait();
	st.Prepare(" delete from dt_indexfilemap where subdatasetid=%d",subdatasetid);
	st.Execute(1);
	st.Wait();
	//为防止功能重入,中间文件状态修改.
	lgprintf("修改中间文件的处理状态(subdatasetid:%d,%d个文件)：1-->2",subdatasetid,rn);
	sprintf(sqlbf,"update dt.dt_middledatafile set procstate=2 where subdatasetid=%d",subdatasetid);
	conn.DoQuery(sqlbf);
	tmpfilenum=rn;
	//索引数据文件遍历，累加索引总行数
	int idxrn=0;
	int i;
	for( i=0;i<rn;i++) {
		dt_file df;
		df.Open(mdf.PtrStr("indexfilename",i),0);
		lgprintf("file opened :%s",mdf.PtrStr("indexfilename",i));
		idxrn+=df.GetRowNum();
	}
	lgprintf("索引记录数:%d",idxrn);
	//建立中间索引(中间文件数据块索引)内存表mdindexmt和目标数据块内存表blockmt
	lgprintf("建立中间索引内存表");
	int maxblockrn=sp->GetMaxBlockRnFromSrcTab(srctabid);
	{
	dt_file idf;
	idf.Open(mdf.PtrStr("indexfilename",0),0);
	mdindexmt.SetHandle(idf.CreateMt(idxrn));
	//wociAddColumn(idxmt,"dtfileid",NULL,COLUMN_TYPE_INT,4,0);
	//idxmt.SetMaxRows(idxrn);
	mdindexmt.Build();
	if(mdindexmt>0) {
		lgprintf("mdindex, maxrows:%d,cols:%d",wociGetMemtableRows(mdindexmt),
		  wociGetColumnNumber(mdindexmt));
	}
	idf.Open(mdf.PtrStr("datafilename",0),0);
	blockmt.SetHandle(idf.CreateMt(maxblockrn));
	//mdblockmt.SetHandle(idf.CreateMt(maxblockrn));
	}
	int crn=0;
//	wociGetIntAddrByName(idxmt,"dtfileid",0,&pdtfid);
	// pdtfid为一个字符数组，偏移为x的值表示中间索引内存表第x行的文件序号(Base0);
	lgprintf("建立文件序号附加字段");
	if(dtfidlen<idxrn) 
	{
		if(pdtfid)
			delete [] pdtfid;
		pdtfid=new unsigned char [idxrn];
		dtfidlen=idxrn;
	}
	//pdtf为file_mt对象的数组。存放数据文件对象。
	lgprintf("建立数据文件对象组");
	if(pdtf) delete [] pdtf;
	pdtf=new file_mt[rn];
	//mdindexmt.SetMaxRows(idxrn);
	//读入全部索引数据到mdindexmt(中间索引内存表),并打开全部数据文件
	//pdtfid指向对应的文件序号。
	for(i=0;i<rn;i++) {
		dt_file df;
		df.Open(mdf.PtrStr("indexfilename",i),0);
		int brn=df.ReadMt(0,0,mdindexmt,false);
		for(int j=crn;j<crn+brn;j++)
			pdtfid[j]=(unsigned char )i;
		crn+=brn;
		pdtf[i].Open(mdf.PtrStr("datafilename",i),0);
		if(mdindexmt>0) {
			lgprintf("mdindex, maxrows:%d,cols:%d",wociGetMemtableRows(mdindexmt),
				  wociGetColumnNumber(mdindexmt));
		}
	}
	//对mdindexmt(中间索引内存表)做排序。
	//由于排序不涉及内存表的数据排列，而是新建记录顺序表，因此，
	// pdtfid作为内存表外的等效内存表字段，不需做处理。
	lgprintf("中间索引表重新排序");
	{
		char sort[300];
		sprintf(sort,"%s,idx_fid,idx_blockoffset",mdf.PtrStr("soledindexcols",0));
		lgprintf("Sort by :%s",sort);
//		wociMTPrint(mdindexmt,2,"idx_blockoffset");
//		wociMTPrint(mdindexmt,2,"termphone");
		//wociMTToTextFile(mdindexmt,"/dds/wgsh/dtsvr/mdindexmt.data",0,NULL);
		 wociSetSortColumn(mdindexmt,sort);
		//ThrowWith("Force break here");
		wociSort(mdindexmt);
		lgprintf("Sort end.");
	}
	//取得全部独立索引结构
	sp->GetSoledInexParam(srctabid,&dp);
	//检查需要处理的中间数据是否使用主独立索引，如果是，isfirstidx=1.
	lgprintf("检查需要处理的中间数据是否使用主独立索引 ...");
	int isfirstidx=0;
	indexparam *ip;
	{
	int idxp=dp.GetOffset(indexid);
	ip=&dp.idxp[idxp];
	if(idxp==dp.psoledindex) isfirstidx=1;
	}
	//从结构描述文件建立indexmt,indexmt是目标索引内存表。是建立目标索引表的数据源。
	indexmt.SetHandle(CreateMtFromFile(MAXINDEXRN,ip->cdsfilename));
	lgprintf("检查结果 :%s",isfirstidx==1?"Yes":"No");
	//取独立索引和复用索引在blockmt(目标数据块内存表)结构中的位置，
	// 检查结构描述文件建立的索引是否和系统参数表中指定的字段数相同。
	void *indexptr[40];
	int pblockc1[20];
	int pblockc2[20];
	bool pkmode=false;
	int bcn1=wociConvertColStrToInt(blockmt,ip->idxcolsname,pblockc1);
	if(bcn1==1 && wociGetColumnType(blockmt,pblockc1[0])==COLUMN_TYPE_INT)
		pkmode=true;
	int bcn2=wociConvertColStrToInt(blockmt,ip->idxreusecols,pblockc2);
	if(wociGetColumnNumber(indexmt)!=bcn1+bcn2+6) {
		ThrowWith("Column number error,subdatasetid:%d,colnum:%d,deserved:%d",
			subdatasetid,wociGetColumnNumber(indexmt),bcn1+bcn2+6);
	}
	//设置dt_index中的idxfieldnum
	lgprintf("Set 'idxfieldnum' of table 'dt_index'...");
	sprintf(sqlbf,"update dt.dt_index set idxfieldnum=%d where indexid=%d",
		bcn1+bcn2,indexid);
	lgprintf("设置dt_index中的索引字段数(idxfieldnum).");
	conn.DoQuery(sqlbf);

	//取独立索引在mdindexmt(中间索引存表)结构中的位置。
	//设置对indexmt插入记录需要的结构和变量。
	lgprintf("Get position of soled index in middle index mt..");
	int pidxc1[20];
	int cn1=wociConvertColStrToInt(mdindexmt,ip->idxcolsname,pidxc1);
	int dtfid,blockstart,blocksize,blockrn=0,startrow,rownum;
	int stcn=bcn1+bcn2;
	indexptr[stcn++]=&dtfid;
	indexptr[stcn++]=&blockstart;
	indexptr[stcn++]=&blocksize;
	indexptr[stcn++]=&blockrn;
	indexptr[stcn++]=&startrow;
	indexptr[stcn++]=&rownum;
	indexptr[stcn]=NULL;
	//indexmt中的blocksize,blockstart?,blockrownum需要滞后写入，
	//因而需要取出这些字段的首地址。
	int *pblocksize;
	int *pblockstart;
	int *pblockrn;
	wociGetIntAddrByName(indexmt,"blocksize",0,&pblocksize);
	wociGetIntAddrByName(indexmt,"blockstart",0,&pblockstart);
	wociGetIntAddrByName(indexmt,"blockrownum",0,&pblockrn);
	//mdindexmt中下列字段是读中间数据文件的关键项。
	int *poffset,*pstartrow,*prownum;
	wociGetIntAddrByName(mdindexmt,"idx_blockoffset",0,&poffset);
	wociGetIntAddrByName(mdindexmt,"idx_startrow",0,&pstartrow);
	wociGetIntAddrByName(mdindexmt,"idx_rownum",0,&prownum);

	//indexmt 记录行数计数复位
	int indexmtrn=0;
	
	//从dt_datafilemap(存blockmt文件表)和dt_indexfilemap(存indexmt文件表)
	//建立内存表结构
	char fn[300];
	AutoMt fnmt(sp->GetDTS(),300);
	fnmt.FetchAll("select * from dt_datafilemap where rownum<1");
	fnmt.Wait();
	AutoMt fnidxmt(sp->GetDTS(),300);
	fnidxmt.FetchAll("select * from dt_indexfilemap where rownum<1");
	fnidxmt.Wait();
	
	//建立目标数据文件和目标索引文件对象(dt_file).
	// 目标数据文件和目标索引文件一一对应，目标数据文件中按子块方式存储内存表
	//  目标索引文件中为一个单一的内存表，文件头结构在写入内存表时建立
	dtfid=sp->NextFileID();
	dp.usingpathid=0;
	sprintf(fn,"%s%d_%d_%d.dat",dp.dstpath[0],srctabid,subdatasetid,dtfid);
	dt_file dstfile;
	dstfile.Open(fn,1);
	blockstart=dstfile.WriteHeader(blockmt,0,dtfid);
	char idxfn[300];
	sprintf(idxfn,"%s%d_%d_%d.idx",dp.dstpath[0],srctabid,subdatasetid,dtfid);
	dt_file idxf;
	idxf.Open(idxfn,1);

	startrow=0;
	rownum=0;
	blockrn=0;
	int subtotrn=0;
	lgprintf("开始数据处理(MiddleDataLoading)....");

	/*******按照Sort顺序遍历mdindexmt(中间索引内存表)***********/
	//
	//
	int firstrn=wociGetRawrnBySort(mdindexmt,0);
	lgprintf("Firt raw row number of mdindexmt:%d",firstrn);
	for(i=0;i<idxrn;i++) {
		int thisrn=wociGetRawrnBySort(mdindexmt,i);
		int rfid=pdtfid[thisrn];
		int sbrn=prownum[thisrn];
		int sbstart=pstartrow[thisrn];
		int sameval=mdindexmt.CompareRows(firstrn,thisrn,pidxc1,cn1);
//		lgprintf("thisrn:%d rfid:%d,sbrn:%d,sbstart:%d,sameval:%d",
//		         thisrn,rfid,sbrn,sbstart,sameval);
		//if(i>3) ThrowWith("Force Break run .");
//lgprintf("bug test1");
		if(sameval!=0) {
			//子块索引
			int c;
//lgprintf("bug test2");
			for(c=0;c<bcn1;c++) {
				indexptr[c]=blockmt.PtrVoid(pblockc1[c],startrow);
			}
//lgprintf("bug test3");
			for(c=0;c<bcn2;c++) {
				indexptr[bcn1+c]=blockmt.PtrVoid(pblockc2[c],startrow);
			}
//lgprintf("bug test4");
			wociInsertRows(indexmt,indexptr,NULL,1);
			firstrn=thisrn;
//lgprintf("bug test5");
			startrow=blockrn;
			rownum=0;
		}
//lgprintf("bug test6");
		//数据块拆分
		int mt=pdtf[rfid].ReadBlock(poffset[thisrn],0);
//lgprintf("bug test7,mt:%d,blockmt:%d",(int)mt,(int)blockmt);
		if(mt<1) ThrowWith("Invalid data block at file '%s',offset:%d",
		  pdtf[rfid].GetFileName(),pdtf[rfid].GetLastOffset());
		if(blockrn+sbrn>maxblockrn) {
			if(blockrn<maxblockrn*.8) {
//lgprintf("bug test8");
				int rmrn=maxblockrn-blockrn;
				wociCopyRowsTo(mt,blockmt,-1,sbstart,rmrn);
//lgprintf("bug test9");
				rownum+=rmrn;
				sbrn-=rmrn;
//lgprintf("bug test10");
				sbstart+=rmrn;
				blockrn+=rmrn;
			}
//lgprintf("bug test11");
			//保存子快索引
			int c;
			for(c=0;c<bcn1;c++) {
				indexptr[c]=blockmt.PtrVoid(pblockc1[c],startrow);
			}
//lgprintf("bug test12");
			for(c=0;c<bcn2;c++) {
				indexptr[bcn1+c]=blockmt.PtrVoid(pblockc2[c],startrow);
			}
//lgprintf("bug test13");
			wociInsertRows(indexmt,indexptr,NULL,1);
			//保存块数据
			blocksize=dstfile.WriteMt(blockmt,COMPRESSLEVEL)-blockstart;
			int irn=wociGetMemtableRows(indexmt);
//lgprintf("bug test14");
			while(--irn>0) {
				if(pblockstart[irn]==blockstart) {
					pblocksize[irn]=blocksize;
					pblockrn[irn]=blockrn;
				}
				else break;
			}
//lgprintf("bug test15");
			blockstart+=blocksize;
			subtotrn+=blockrn;
//lgprintf("bug test16");
			if(blockstart>2000000000) {
			//增加文件对照表记录(dt_datafilemap)
				{
					void *fnmtptr[20];
					fnmtptr[0]=&dtfid;
					fnmtptr[1]=fn;
					fnmtptr[2]=&subdatasetid;
					fnmtptr[3]=&dp.dstpathid[dp.usingpathid];
					fnmtptr[4]=&dp.tabid;
					fnmtptr[5]=&ip->idxid;
					fnmtptr[6]=&isfirstidx;
					fnmtptr[7]=&blockstart;
					fnmtptr[8]=&subtotrn;
					fnmtptr[9]=&datasetid;
					wociInsertRows(fnmt,fnmtptr,NULL,1);
				}
			//
			//增加索引数据对照表记录(dt_indexfilemap)
				{
					int irn1=wociGetMemtableRows(indexmt);
					idxf.WriteHeader(indexmt,dtfid);
					int idxfsize=idxf.WriteMt(indexmt,COMPRESSLEVEL);
					void *fnmtptr[20];
					fnmtptr[0]=&dtfid;
					fnmtptr[1]=idxfn;
					fnmtptr[2]=&subdatasetid;
					fnmtptr[3]=&dp.dstpathid[dp.usingpathid];
					fnmtptr[4]=&dp.tabid;
					fnmtptr[5]=&ip->idxid;
					fnmtptr[6]=&isfirstidx;
					fnmtptr[7]=&idxfsize;
					fnmtptr[8]=&irn1;
					fnmtptr[9]=&datasetid;
					wociInsertRows(fnidxmt,fnmtptr,NULL,1);
				}
			//
				dtfid=sp->NextFileID();
				sprintf(fn,"%s%d_%d_%d.dat",dp.dstpath[0],srctabid,subdatasetid,dtfid);
				dstfile.SetFileHeader(subtotrn,fn);
				dstfile.Open(fn,1);
				blockstart=dstfile.WriteHeader(blockmt,0,dtfid);

				sprintf(idxfn,"%s%d_%d_%d.idx",dp.dstpath[0],srctabid,subdatasetid,dtfid);
				idxf.SetFileHeader(wociGetMemtableRows(indexmt),idxfn);
				idxf.Open(idxfn,1);
				idxf.WriteHeader(indexmt,0,dtfid);
				indexmt.Reset();
				subtotrn=0;
				blockrn=0;
			}
			blockmt.Reset();
			blockrn=0;
			firstrn=thisrn;
			startrow=blockrn;
			rownum=0;
		}
//lgprintf("bug test17");
		wociCopyRowsTo(mt,blockmt,-1,sbstart,sbrn);
		rownum+=sbrn;
		blockrn+=sbrn;
	}
//lgprintf("bug test18");
	if(blockrn>0) {
			
			//保存子快索引
			int c;
//lgprintf("bug test19");
			for( c=0;c<bcn1;c++) {
				indexptr[c]=blockmt.PtrVoid(pblockc1[c],startrow);
			}
//lgprintf("bug test20");
			for(c=0;c<bcn2;c++) {
				indexptr[bcn1+c]=blockmt.PtrVoid(pblockc2[c],startrow);
			}
//lgprintf("bug test21");
			wociInsertRows(indexmt,indexptr,NULL,1);
			//保存块数据
			//保存块数据
			blocksize=dstfile.WriteMt(blockmt,COMPRESSLEVEL)-blockstart;
			int irn=wociGetMemtableRows(indexmt);
//lgprintf("bug test22");
			while(--irn>0) {
				if(pblockstart[irn]==blockstart) {
					pblocksize[irn]=blocksize;
					pblockrn[irn]=blockrn;
				}
				else break;
			}
			blockstart+=blocksize;
//lgprintf("bug test23");
			subtotrn+=blockrn;
			//增加文件对照表记录(dt_datafilemap)
				{
					void *fnmtptr[20];
					fnmtptr[0]=&dtfid;
					fnmtptr[1]=fn;
					fnmtptr[2]=&subdatasetid;
					fnmtptr[3]=&dp.dstpathid[dp.usingpathid];
					fnmtptr[4]=&dp.tabid;
					fnmtptr[5]=&ip->idxid;
					fnmtptr[6]=&isfirstidx;
					fnmtptr[7]=&blockstart;
					fnmtptr[8]=&subtotrn;
					fnmtptr[9]=&datasetid;
					wociInsertRows(fnmt,fnmtptr,NULL,1);
				}
			//增加索引数据对照表记录(dt_indexfilemap)
//lgprintf("bug test24");
				{
					int irn1=wociGetMemtableRows(indexmt);
					idxf.WriteHeader(indexmt,dtfid);
					int idxfsize=idxf.WriteMt(indexmt,COMPRESSLEVEL);
					void *fnmtptr[20];
					fnmtptr[0]=&dtfid;
					fnmtptr[1]=idxfn;
					fnmtptr[2]=&subdatasetid;
					fnmtptr[3]=&dp.dstpathid[dp.usingpathid];
					fnmtptr[4]=&dp.tabid;
					fnmtptr[5]=&ip->idxid;
					fnmtptr[6]=&isfirstidx;
					fnmtptr[7]=&idxfsize;
					fnmtptr[8]=&irn1;
					fnmtptr[9]=&datasetid;
					wociInsertRows(fnidxmt,fnmtptr,NULL,1);
				}
			//
//lgprintf("bug test25");
				
			//
			dstfile.SetFileHeader(subtotrn,NULL);
			idxf.SetFileHeader(wociGetMemtableRows(indexmt),NULL);
			indexmt.Reset();
			blockmt.Reset();
//lgprintf("bug test26");
			blockrn=0;
			startrow=blockrn;
			rownum=0;
	}
	lgprintf("数据处理(MiddleDataLoading)结束.");
	wociAppendToDbTable(fnmt,"dt_datafilemap",sp->GetDTS());
	wociAppendToDbTable(fnidxmt,"dt_indexfilemap",sp->GetDTS());
	lgprintf("生成%d个数据文件,已插入dt_datafilemap表.",wociGetMemtableRows(fnmt));
	//wociMTPrint(fnmt,0,NULL);
	lgprintf("生成%d个索引文件,已插入dt_indexfilemap表.",wociGetMemtableRows(fnidxmt));
	//wociMTPrint(fnidxmt,0,NULL);
	lgprintf("修改中间文件的处理状态(subdatasetid:%d,%d个文件)：2-->3",subdatasetid,rn);
	sprintf(sqlbf,"update dt.dt_middledatafile set procstate=3 where subdatasetid=%d",subdatasetid);
	conn.DoQuery(sqlbf);
	//检查是否最后一批数据
	{
	mdf.FetchAll("select * from dt_taskschedule where taskid=%d and taskstatus>=2",
		taskid);
	int rn=mdf.Wait();
	if(rn==1) {
		mdf.FetchAll("select * from dt_middledatafile where procstate!=3 and datasetid=%d",
				datasetid);
		int rn=mdf.Wait();
		if(rn==0) {
			lgprintf("最后一批数据已处理完,任务状态2-->3,taskid:%d",taskid);
			sprintf(sqlbf,"update dt.dt_taskschedule set taskstatus=3 where taskid=%d",
				taskid);
			conn.DoQuery(sqlbf);
		}
	}
	}
	return 1;
	//Load index data into memory table (indexmt)
  }

int SysAdmin::GetSrcTableStructMt(int srctabp, int tabp, int srcsys)
{
		AutoStmt srcst(srcsys);
		srcst.Prepare("select * from %s.%s",dt_srctable.PtrStr("srcschedulename",srctabp),
			dt_srctable.PtrStr("srctabname",srctabp));
		int mt=wociCreateMemTable();
		wociBuildStmt(mt,srcst,10);
		return mt;
}

bool SysAdmin::CreateTableOnMysql(const char *cdpathval,MySQLConn &conn, int srcmt, const char *tabname, int tabid, int indexid,int targettype,bool forcecreate)
{
		//如果目标表已存在，先删除
	    char sqlbf[3000];
		bool exist=conn.TouchTable(tabname);
		if(exist && !forcecreate) return false;
		if(exist) {
			printf("table %s has exist,dropped.\n",tabname);
			sprintf(sqlbf,"drop table %s",tabname);
			conn.DoQuery(sqlbf);
		}
		//else 
		{
			//建立目标标及其表结构的描述文件
			wociGetCreateTableSQL(srcmt,sqlbf,tabname,true);
			conn.DoQuery(sqlbf);
			int fid=NextFileID();
			char fn[300];
			sprintf(fn,"%sdt_%s_%d_%d.cdsc",cdpathval,tabname,tabid,fid);
			FILE *fp=fopen(fn,"w+b");
			if(fp==NULL) ThrowWith("Create file '%s' failed\n",fn);
			void *pcd;
			int cdlen,cdnum;
			wociGetColumnDesc(srcmt,&pcd,cdlen,cdnum);
			fwrite(&cdlen,1,sizeof(int),fp);
			fwrite(&cdnum,1,sizeof(int),fp);
			fwrite(pcd,1,cdlen,fp);
			fclose(fp);
			//修改表结构描述文件的链接
			if(targettype==0)
			sprintf(sqlbf,"update dt.dt_table set cdfileid=%d,recordlen=%d where tabid=%d",
				fid,wociGetRowLen(srcmt),tabid);
			else 
			sprintf(sqlbf,"update dt.dt_index set cdfileid=%d where indexid=%d",
				fid,indexid);
			conn.DoQuery(sqlbf);
			char tmp[300];
			mysql_escape_string(tmp,fn,strlen(fn));
			sprintf(sqlbf,"insert into dt.dt_cdfilemap values (%d,'%s',0,%d,%d,%d,%d,%d)",
				fid,tmp,targettype,tabid,indexid,sizeof(int)*2+cdlen,cdnum);
			conn.DoQuery(sqlbf);
		}
		return true;
}

//建立表并更新复用字段值(dt_index.reusecols)
bool SysAdmin::CreateIndexTable(MySQLConn &conn,int srcmt,int tabid,int indexid, const char *tabname, const char *solecolsname,const char *pathval, bool forcecreate)
{
		//建立索引表和目标表、索引表的索引
		AutoMt idxtarget(dts,100);
		//每一个独立索引都需要建立索引表
		wociClear(idxtarget);
		wociCopyColumnDefine(idxtarget,srcmt,solecolsname);
		//查找该独立索引附带的非独立索引，并以此为依据建立索引表
		AutoMt idxsubmt(dts,100);
		idxsubmt.FetchAll("select * from dt_index where reuseindexid=%d order by indexidinidxtab",
					indexid);
		int srn=idxsubmt.Wait();
		char colsname[300];
		for(int j=0;j<srn;j++) {
			strcpy(colsname,idxsubmt.PtrStr("columnsname",j));
			//重复的字段自动剔除
			wociCopyColumnDefine(idxtarget,srcmt,colsname);
		}
		//重构索引复用段
		char reusedcols[300];
		int pcol[20];
		int cn1;
		cn1=wociConvertColStrToInt(srcmt,solecolsname,pcol);
		reusedcols[0]=0;
		int tcn=wociGetMtColumnsNum(idxtarget);
		if(tcn>cn1) {
			for(int i=cn1;i<tcn;i++) {
				if(i!=cn1) strcat(reusedcols,",");
				wociGetColumnName(idxtarget,i,reusedcols+strlen(reusedcols));
			}
		}
		{
			AutoStmt st(dts);
			if(strlen(reusedcols)>0)
			 st.Prepare("update dt_index set reusecols='%s' where indexid=%d",
				reusedcols,indexid);
			else
			 st.Prepare("update dt_index set reusecols=null where indexid=%d",
				indexid);
			st.Execute(1);
			st.Wait();
		}
		//索引表公共字段
		wociAddColumn(idxtarget,"dtfid",NULL,COLUMN_TYPE_INT,10,0);
		wociAddColumn(idxtarget,"blockstart",NULL,COLUMN_TYPE_INT,10,0);
		wociAddColumn(idxtarget,"blocksize",NULL,COLUMN_TYPE_INT,10,0);
		wociAddColumn(idxtarget,"blockrownum",NULL,COLUMN_TYPE_INT,10,0);
		wociAddColumn(idxtarget,"startrow",NULL,COLUMN_TYPE_INT,10,0);
		wociAddColumn(idxtarget,"rownum",NULL,COLUMN_TYPE_INT,10,0);
		//如果索引表已存在，先删除
		char sqlbf[3000];
		bool exist=conn.TouchTable(tabname);
		if(exist && !forcecreate) return false;
		if( exist ) {
			printf("Index table '%s' has exist,dropped!\n",tabname);
			sprintf(sqlbf,"drop table %s",tabname);
			conn.DoQuery(sqlbf);
		}
		CreateTableOnMysql(pathval,conn,idxtarget,tabname,tabid,indexid,1,true);
		{
				char emptytabname[300];
				sprintf(emptytabname,"template.pri_%s",tabname);
				if(conn.TouchTable(emptytabname)) {
					printf("Empty Temp table '%s' has exist,skip create.\n",emptytabname);
					sprintf(sqlbf,"drop table %s",emptytabname);
					conn.DoQuery(sqlbf);
				}
				//else
				{
					wociGetCreateTableSQL(idxtarget,sqlbf,emptytabname,true);
					conn.DoQuery(sqlbf);
					printf(sqlbf);
					printf("\n");
				}
		}
		return true;
}

//createtype: 0--- datatable and indextable 1--datatable 2--indextable
bool SysAdmin::CreateIndex(char *dttabname, char *idxtabname, int createtype, MySQLConn &conn, int tabid, int indexid, bool forcecreate)
{
			AutoMt mt(dts,10);
			mt.FetchAll("select * from dt_index where indexid=%d and issoledindex=1",indexid);
			int rn=mt.Wait();
			if(rn<1)
				ThrowWith("Indexid is invalid or not a soled :%d",indexid);

			char colsname[1000];
			//char idxname[300];
			strcpy(colsname,mt.PtrStr("columnsname",0));
			if(createtype==0 || createtype==2) {
			  CreateIndex(idxtabname,conn,mt.GetInt("indexidinidxtab",0),colsname,forcecreate);
			}
			if(createtype==0 || createtype==1) {
				CreateIndex(dttabname,conn,mt.GetInt("indexidindattab",0),colsname,forcecreate);
			}
			
			//查找该独立索引附带的非独立索引，并以此为依据建立索引表
			AutoMt idxsubmt(dts,100);
			idxsubmt.FetchAll("select * from dt_index where reuseindexid=%d order by indexidinidxtab",
						indexid);
			int srn=idxsubmt.Wait();
			for(int j=0;j<srn;j++) {
				strcpy(colsname,idxsubmt.PtrStr("columnsname",j));
				CreateIndex(idxtabname,conn,idxsubmt.GetInt("indexidinidxtab",j),colsname,forcecreate);
				CreateIndex(dttabname,conn,idxsubmt.GetInt("indexidindattab",j),colsname,forcecreate);
			}
			return true;
}

void SysAdmin::CreateIndex(char *dtname, MySQLConn &conn, int id, char *colsname, bool forcecreate)
{
	char sqlbf[3000];	
	if(forcecreate) {
		sprintf(sqlbf,"drop index %s_%d on %s",dtname,
			id,dtname);
		conn.DoQuery(sqlbf);
	}
	sprintf(sqlbf,"create index %s_%d on %s(%s)",
		dtname,id,
		dtname,colsname);
	conn.DoQuery(sqlbf);
}

#define revint(v) ((v>>24)|(v<<24)|(v>>8&0xff00)|(v<<8&0xff0000))

int DestLoader::Load() {
	//Check deserved temporary(middle) fileset
	AutoMt mdf(psa->GetDTS(),10);
	mdf.FetchAll("select * from dt_middledatafile where procstate=3 and rownum<2");
	int rn=mdf.Wait();
	if(rn<1) {
		lgprintf("没有发现处理完成的数据(Middle loaded,dt.middledatafile.procstate=3).");
		return 0;
	}
	srctabid=mdf.GetInt("srctabid",0);
	indexid=mdf.GetInt("indexid",0);
	subdatasetid=mdf.GetInt("subdatasetid",0);
	tabid=mdf.GetInt("tabid",0);
	partid=mdf.GetInt("partid",0);
	taskid=mdf.GetInt("taskid",0);
	datasetid=mdf.GetInt("datasetid",0);
	psa->GetSoledInexParam(srctabid,&dp);
	mdf.FetchAll("select * from dt_taskschedule where taskid=%d and taskstatus=3",taskid);
	rn=mdf.Wait();
	if(rn<1) {
		lgprintf("数据抽取过程未结束(taststatus!=2),部分数据已处理(procstate=3).");
		return 0;
	}
	mdf.FetchAll("select * from dt_middledatafile where procstate<3 and taskid=%d",taskid);
	rn=mdf.Wait();
	if(rn>0) {
		lgprintf("数据抽取过程已结束(taststatus=2),部分数据未处理(procstate<3).");
		return 0;
	}
	AutoMt idxmt(psa->GetDTS(),10);
	idxmt.FetchAll("select * from dt_index where tabid=%d and issoledindex=1",tabid);
	int idxrn=idxmt.Wait();
	for(int i=0;i<idxrn;i++) {
		indexid=idxmt.GetInt("indexid",i);
		mdf.FetchAll("select * from dt_indexfilemap where datasetid=%d and indexid=%d order by fileid",
		datasetid,indexid);
		rn=mdf.Wait();
		AutoMt datmt(psa->GetDTS(),100);
		datmt.FetchAll("select * from dt_datafilemap where datasetid=%d and tabid=%d and indexid=%d order by fileid",datasetid,tabid,
			indexid);
		int datrn=datmt.Wait();

		for(int k=0;k<datrn;k++) {
			//Build table data file link information.
			if(k+1==datrn) {
				dt_file df;
				df.Open(datmt.PtrStr("filename",k),2,datmt.GetInt("fileid",k));
				df.SetFileHeader(0,NULL);
			}
			else {
				dt_file df;
				df.Open(datmt.PtrStr("filename",k),2,datmt.GetInt("fileid",k));
				df.SetFileHeader(0,datmt.PtrStr("filename",k+1));
			}
		}
	    lgprintf("开始数据装入(DestLoading),文件数:%d,tabid:%d,datasetid:%d,taskid:%d ,indexid:%d ...",
		  rn,tabid,datasetid,taskid,indexid);
		int off=dp.GetOffset(indexid);
		char fn[300];
		const char *pathval=psa->GetPathName(0,"msys");
#ifdef WIN32
		sprintf(fn,"%stmpidx\\pri_%s_%d.MYD",pathval,dp.idxp[off].idxtbname,taskid);
#else
		sprintf(fn,"%stmpidx/pri_%s_%d.MYD",pathval,dp.idxp[off].idxtbname,taskid);
#endif		
		//struct _finddata_t ft;
		FILE *fp =NULL;
		fp=fopen(fn,"a+b");
		if(fp==NULL) 
			ThrowWith("Open file %s for writing failed!",fn);
		int totidxrn=0;
		for(int i=0;i<rn;i++) {
			//Build index data file link information.
			if(i+1==rn) {
				dt_file df;
				lgprintf("create file '%s',it's last file.",mdf.PtrStr("filename",i));
				df.Open(mdf.PtrStr("filename",i),2,mdf.GetInt("fileid",i));
				df.SetFileHeader(0,NULL);
			}
			else {
				dt_file df;
				lgprintf("create file '%s',next file :'%s'.",mdf.PtrStr("filename",i),
					mdf.PtrStr("filename",i+1));
				df.Open(mdf.PtrStr("filename",i),2,mdf.GetInt("fileid",i));
				df.SetFileHeader(0,mdf.PtrStr("filename",i+1));
			}
			file_mt idxf;
			idxf.Open(mdf.PtrStr("filename",i),0);
			int mt=idxf.ReadBlock(0,0);
			lgprintf("Get %d index row from file '%s'.",wociGetMemtableRows(mt),mdf.PtrStr("filename",i));
			while(mt) {
				wociCopyToMySQL(mt,0,0,fp);
				totidxrn+=wociGetMemtableRows(mt);
				mt=idxf.ReadBlock(-1,0);
			}
		}
		fclose(fp);
		fp=fopen(fn,"rb");
		fseek(fp,0,SEEK_END);
		long fsz=ftell(fp);//_filelength(_fileno(fp));
		fclose(fp);
		lgprintf("Build index file %s,size:%d",fn,fsz);
		char srcfn[300];
#ifdef WIN32
		sprintf(srcfn,"%stemplate\\pri_%s.frm",pathval,dp.idxp[off].idxtbname);
		sprintf(fn,"%stmpidx\\pri_%s_%d.frm",pathval,dp.idxp[off].idxtbname,taskid);
		if(!CopyFile(srcfn,fn,FALSE))
#else
		char cmdl[300];
		sprintf(srcfn,"%stemplate/pri_%s.frm",pathval,dp.idxp[off].idxtbname);
		sprintf(fn,"%stmpidx/pri_%s_%d.frm",pathval,dp.idxp[off].idxtbname,taskid);
		if(uCopyFile(srcfn,fn)!=1)
		 //sprintf(cmdl,"cp %s %s\r\n",srcfn,fn);
		 //lgprintf("System command :'%s'\n",cmdl);
		 //if(system(cmdl)==-1)
#endif
		  ThrowWith("Copy file '%s' to '%s' failed!\n",srcfn,fn);

#ifdef WIN32
		sprintf(srcfn,"%stemplate\\pri_%s.MYI",pathval,dp.idxp[off].idxtbname);
		sprintf(fn,"%stmpidx\\pri_%s_%d.MYI",pathval,dp.idxp[off].idxtbname,taskid);
		if(!CopyFile(srcfn,fn,FALSE))
#else
		sprintf(srcfn,"%stemplate/pri_%s.MYI",pathval,dp.idxp[off].idxtbname);
		sprintf(fn,"%stmpidx/pri_%s_%d.MYI",pathval,dp.idxp[off].idxtbname,taskid);
		if(uCopyFile(srcfn,fn)!=1)
//		sprintf(cmdl,"cp %s %s\r\n",srcfn,fn);
//		lgprintf("System command :'%s'",cmdl);
//		if(system(cmdl)==-1)
#endif
			 ThrowWith("Copy file '%s' to '%s' failed!\n",srcfn,fn);
		totidxrn=revint(totidxrn);
		fsz=revint(fsz);
		int bk=0;
		fp=fopen(fn,"r+b");
		fseek(fp,28,SEEK_SET);
		fwrite(&bk,1,4,fp);
		fwrite(&totidxrn,1,4,fp);
		fseek(fp,68,SEEK_SET);
		fwrite(&bk,1,4,fp);
		fwrite(&fsz,1,4,fp);
		fseek(fp,0,SEEK_END);
		fclose(fp); 
		lgprintf("数据装入(DestLoading)结束 ...");
	}
	AutoStmt updst(psa->GetDTS());
	updst.Prepare("update dt_taskschedule set taskstatus=4 where taskid=%d",
		taskid);
	updst.Execute(1);
	updst.Wait();
	lgprintf("任务状态更新,3(MLoaded)--->4(DLoaded),任务号:%d,数据集编号:%d",taskid,datasetid);
	return 1;
}

int DestLoader::RecreateIndex(SysAdmin *_Psa,MySQLConn &conn) 
{
	AutoMt mdf(psa->GetDTS(),200);
	mdf.FetchAll("select * from dt_taskschedule where taskstatus=4 and rownum<2");
	int rn=mdf.Wait();
	if(rn<1) {
		return 0;
	}
	taskid=mdf.GetInt("taskid",0);
	srctabid=mdf.GetInt("srctabid",0);
	datasetid=mdf.GetInt("datasetid",0);
	mdf.FetchAll("select distinct indexid,tabid from dt_middledatafile where taskid=%d",taskid);
	rn=mdf.Wait();
	tabid=mdf.GetInt("tabid",0);
	
	//check intergrity.
	int newdsid=datasetid;
	mdf.FetchAll("select count(*) rn from dt_index where tabid=%d and issoledindex=1",tabid);
	mdf.Wait();

	if(mdf.GetInt("rn",0)!=rn) 
	{
		lgprintf("出现错误: 装入独立索引数(%d)和索引参数表中的值(%d)不符.",
			rn,mdf.GetInt("rn",0));
		return 0; //dump && destload(create temporary index table) have not complete.
	}
	// Get new & old datasetid
	mdf.FetchAll("select datasetid,databasename from dt_table where tabid=%d",tabid);
	mdf.Wait();
	char dbname[100];
	strcpy(dbname,mdf.PtrStr("databasename",0));
	conn.SelectDB(dbname);
	int olddsid=mdf.GetInt("datasetid",0);
	char sqlbf[3000];
	mdf.FetchAll("select * from dt_index where tabid=%d order by indexidindattab",tabid);
	rn=mdf.Wait();
	int psoledid=-1;
	sprintf(sqlbf,"update dt.dt_table set recordnum=0 where tabid=%d",tabid);
	conn.DoQuery(sqlbf);
	conn.DoQuery("flush tables");
	lgprintf("数据已关闭.");
	lgprintf("开始索引重建,tabid:%d,独立索引数 :%d,datasetid=%d",
		tabid,rn,datasetid);
	int i;
	for(i=0;i<rn;i++) {
		int soled=mdf.GetInt("issoledindex",i);
		if(soled) {
		// 目标表备份--〉源表转移到目标表。
			int indexidinidxtab=mdf.GetInt("indexidinidxtab",i);
			char *tbname=mdf.PtrStr("indextabname",i);
			char *colsname=mdf.PtrStr("columnsname",i);
			int indexid=mdf.GetInt("indexid",i);
			if(mdf.GetInt("issoledpindex",i)==1) psoledid=indexid;
			sprintf(sqlbf,"bakidx.%s_%d",tbname,olddsid);
			bool bakex=conn.TouchTable(sqlbf);
			sprintf(sqlbf,"%s.%s",dbname,tbname);
			bool dstex=conn.TouchTable(sqlbf);
			sprintf(sqlbf,"tmpidx.pri_%s_%d",tbname,taskid);
			bool srcex=conn.TouchTable(sqlbf);
			if(bakex && dstex &&srcex) {
				sprintf(sqlbf,"drop table bakidx.%s_%d",tbname,olddsid);
				conn.DoQuery(sqlbf);
				lgprintf("备份索引表已删除.");
			}
			if(dstex && srcex) {
				sprintf(sqlbf,"alter table %s.%s rename bakidx.%s_%d",
					dbname,tbname,tbname,olddsid);
				conn.DoQuery(sqlbf);
				lgprintf("备份索引表已建立.");
			}
			//源表不存在，有可能是上次非正常运行，已有部分索引表成功建立。
			if(srcex) {
				sprintf(sqlbf,"alter table tmpidx.pri_%s_%d rename %s.%s",
					tbname,taskid,dbname,tbname);
				conn.DoQuery(sqlbf);
				lgprintf("在线索引表已建立.");
			}
			if(dstex) {
				_Psa->CreateIndex(tbname,conn,indexidinidxtab,colsname,true);
				lgprintf("创建索引:%s.%s",tbname,colsname);
				for(int j=0;j<rn;j++) {
					if(mdf.GetInt("reuseindexid",j)==indexid) {
						_Psa->CreateIndex(tbname,conn,mdf.GetInt("indexidinidxtab",j),
							mdf.PtrStr("columnsname",j),true);
						lgprintf("创建索引:%s.%s",tbname,mdf.PtrStr("columnsname",j));
					}
				}
			}
		}
	}
	if(psoledid==-1) 
		ThrowWith("No primary soled index define in dt_index on tableid: %d",tabid);
	lgprintf("索引建立完成.");
	mdf.FetchAll("select * from dt_datafilemap where datasetid=%d and isfirstindex=1 order by fileid",
		datasetid);
	rn=mdf.Wait();
		
	int sumrn=0;
	for(i=0;i<rn;i++) sumrn+=mdf.GetInt("recordnum",i);
	lgprintf("数据源准备完毕,记录数:%d.",sumrn);
	
	sprintf(sqlbf,"update dt.dt_table set datasetid=%d,recordnum=%d,firstdatafileid=%d where tabid=%d",
		datasetid,sumrn,mdf.GetInt("fileid",0),tabid);
	conn.DoQuery(sqlbf);
	conn.DoQuery("flush tables");
	lgprintf("数据已成功上线.");
	AutoStmt updst(psa->GetDTS());
	updst.Prepare("update dt_taskschedule set taskstatus=5 where taskid=%d",
		taskid);
	updst.Execute(1);
	updst.Wait();
	lgprintf("任务状态4(DestLoaded)-->5(Complete),taskid:%d.",taskid);
	return 1;
}
