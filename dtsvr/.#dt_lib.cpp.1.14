#include "dt_common.h"
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include "dt_lib.h"
#include "zlib.h"
#include "dtio.h"
#include <sys/wait.h>
#define COMPRESSLEVEL 5

#define	SRCBUFLEN 2500000
#define DSTBUFLEN 2500000
#define PREPPARE_ONLINE_DBNAME "preponl"
#define FORDELETE_DBNAME "fordelete"
// 2005/08/27修改，partid等效于subdatasetid

//固定为10MB
#define FIX_MAXINDEXRN 10

// 为保持wdbi库的连续运行(dtadmin单独升级),TestColumn在此实现。理想位置是到wdbi库实现
bool TestColumn(int mt,const char *colname)
{
	int colct=wociGetColumnNumber(mt);
	char tmp[300];
	for(int i=0;i<colct;i++) {
		wociGetColumnName(mt,i,tmp);
		if(STRICMP(colname,tmp)==0) return true;
	}
	return false;
}

int CopyMySQLTable(const char *path,const char *sdn,const char *stn,
				   const char *ddn,const char *dtn)
{
	char srcf[300],dstf[300];
	// check destination directory
	sprintf(dstf,"%s%s",path,ddn);
	xmkdir(dstf);
	sprintf(srcf,"%s%s/%s%s",path,sdn,stn,".frm");
	sprintf(dstf,"%s%s/%s%s",path,ddn,dtn,".frm");
	mCopyFile(srcf,dstf);
	sprintf(srcf,"%s%s/%s%s",path,sdn,stn,".MYD");
	sprintf(dstf,"%s%s/%s%s",path,ddn,dtn,".MYD");
	mCopyFile(srcf,dstf);
	sprintf(srcf,"%s%s/%s%s",path,sdn,stn,".MYI");
	sprintf(dstf,"%s%s/%s%s",path,ddn,dtn,".MYI");
	mCopyFile(srcf,dstf);
	
	sprintf(srcf,"%s%s/%s%s",path,sdn,stn,".DTP");
	{
		FILE *fsrc=fopen(srcf,"rb");
		if(fsrc!=NULL) {
			fclose(fsrc) ;
			sprintf(dstf,"%s%s/%s%s",path,ddn,dtn,".DTP");
			mCopyFile(srcf,dstf);
		}	
	}
	return 1;
}

/*
int CreateMtFromFile(int maxrows,char *filename)
{
FILE *fp=fopen(filename,"rb");
if(!fp)
ThrowWith("CreateMt from file '%s' which could not open.",filename);
int cdlen=0,cdnum=0;
fread(&cdlen,sizeof(int),1,fp);
fread(&cdnum,sizeof(int),1,fp);
revInt(&cdnum);
revInt(&cdlen);
if(cdlen==0 || cdnum==0)
ThrowWith("Could not read columns info from file 's' !",filename);
char *pbf=new char[cdlen];
if(fread(pbf,1,cdlen,fp)!=cdlen) {
delete [] pbf;
ThrowWith("Could not read columns info from file 's' !",filename);
}
int mt=wociCreateMemTable();
wociImport(mt,NULL,0,pbf,cdnum,cdlen,maxrows,0);
delete []pbf;
return mt;
}
*/



void SysAdmin::CreateDT(int tabid) 
{
	wociSetTraceFile("cdt建立目标表结构/");
	lgprintf("解析源表,重构表结构,目标表编号%d.",tabid);
	int tabp=wociSearchIK(dt_table,tabid);
	int srctabid=dt_table.GetInt("srctabid",tabp);
	int srctabp=wociSearchIK(dt_srctable,srctabid);
	
	int srcid=dt_srctable.GetInt("srcsysid",srctabp);
	int srcidp=wociSearchIK(dt_srcsys,srcid);
	
	//建立到数据源的连接
	AutoHandle srcsys;
	srcsys.SetHandle(BuildSrcDBC(srcidp));
	//构造源数据的内存表结构
	AutoMt srcmt(srcsys,0);
	srcmt.SetHandle(GetSrcTableStructMt(srctabp,tabp,srcsys));
	if(wociGetRowLen(srcmt)<1) 
		ThrowWith( "源表解析错误,记录长度为%d",wociGetRowLen(srcmt)) ;
	char tbname[150],idxname[150];
	GetTableName(tabid,-1,tbname,idxname,TBNAME_DEST);
	lgprintf("重建目标表结构（CreateDP)以前需要禁止对表的访问.由于数据或索引结构可能有变化,因此在结构重建后不做数据恢复.");
	lgprintf("记录数清零...");
	CloseTable(tabid,tbname,true);
	CreateTableOnMysql(srcmt,tbname,true);
	CreateAllIndexTable(tabid,srcmt,TBNAME_DEST,true);
	char sqlbf[300];
	sprintf(sqlbf,"update dt.dt_table set cdfileid=1 , recordlen=%d where tabid=%d",
		wociGetRowLen(srcmt), tabid);
	DoQuery(sqlbf);//update dt.dt_table set cdfileid=1 and recordlen=367 where tabid=220
}


DataDump::DataDump(int dtdbc,int maxmem,int _blocksize):fnmt(dtdbc,300)
{
	this->dtdbc=dtdbc;
	//Create fnmt and build column structrues.
	//fnmt.FetchAll("select * from dt_middledatafile where rownum<1");
	fnmt.FetchAll("select * from dt_middledatafile limit 3");
	fnmt.Wait();
	fnmt.Reset();
	taskid=srctabid=indexid=0;
	memlimit=maxmem*1024*1000;
	maxblockrn=0;
	blocksize=_blocksize*1024;
}

int DataDump::BuildMiddleFilePath(int _fid) {
	int fid=_fid;
	sprintf(tmpfn,"%smddt_%d.dat",dp.tmppath[0]
		,fid);
	sprintf(tmpidxfn,"%smdidx_%d.dat",dp.tmppath[0],
		fid);
	while(true) {
		int freem=GetFreeM(tmpfn);
		if(freem<1024) {
			lgprintf("Available space on hard disk('%s') less then 1G : %dM,waitting 5 minutes for free...",tmpfn,freem);
			mSleep(300000);
		}
		else break;
	}
	return fid;
}

void DataDump::ProcBlock(int partid,AutoMt *pCur,int idx,AutoMt &blockmt,int _fid)
{
	freeinfo1("Start ProcBlock");
	int fid=BuildMiddleFilePath(_fid);
	blockmt.Reset();
	int cur=*pCur;
	char *idxcolsname=dp.idxp[idx].idxcolsname;
	int *ikptr=NULL;
	int strow=-1;
	int subrn=0;
	int blockrn=0;
	if(maxblockrn<MIN_BLOCKRN) ThrowWith("目标表的数据块大小(%d)不合适，至少为%d.",maxblockrn,MIN_BLOCKRN);
	if(maxblockrn>MAX_BLOCKRN) ThrowWith("目标表的数据块大小(%d)不合适，不能超过%d.",maxblockrn,MAX_BLOCKRN);
	//最坏情况下,索引记录数等于数据记录数
	AutoMt idxdt(0,MAX_BLOCKRN);
	wociCopyColumnDefine(idxdt,cur,idxcolsname);
	wociAddColumn(idxdt,"idx_blockoffset","",COLUMN_TYPE_INT,0,0);
	//	wociAddColumn(idxdt,"idx_storesize","",COLUMN_TYPE_INT,0,0);
	wociAddColumn(idxdt,"idx_startrow","",COLUMN_TYPE_INT,0,0);
	wociAddColumn(idxdt,"idx_rownum","",COLUMN_TYPE_INT,0,0);
	wociAddColumn(idxdt,"idx_fid","",COLUMN_TYPE_INT,0,0);
	idxdt.Build();
	freeinfo1("After Build indxdt mt");
	void *idxptr[20];
	int pidxc1[10];
	bool pkmode=false;
	sorttm.Start();
	int cn1=wociConvertColStrToInt(cur,idxcolsname,pidxc1);
	//屏蔽PK模式，全部按普通模式处理
	//if(cn1==1 && wociGetColumnType(cur,pidxc1[0])==COLUMN_TYPE_INT)
	//	pkmode=true;
	if(!pkmode) {
		wociSetSortColumn(cur,idxcolsname);
		wociSortHeap(cur);
	}
	else {
		wociSetIKByName(cur,idxcolsname);
		wociOrderByIK(cur);
		wociGetIntAddrByName(cur,idxcolsname,0,&ikptr);
	}
	sorttm.Stop();
	int idx_blockoffset=0,idx_store_size=0,idx_startrow=0,idx_rownum=0;
	int idxc=cn1;
	idxptr[idxc++]=&idx_blockoffset;
	//	idxptr[idxc++]=&idx_store_size;
	idxptr[idxc++]=&idx_startrow;
	idxptr[idxc++]=&idx_rownum;
	idxptr[idxc++]=&fid;
	idxptr[idxc]=NULL;
	dt_file df;
	df.Open(tmpfn,1,fid);
	idx_blockoffset=df.WriteHeader(cur);
	dt_file di;
	di.Open(tmpidxfn,1);
	di.WriteHeader(idxdt,wociGetMemtableRows(idxdt));
	idxdt.Reset();
	int totidxrn=0;
	int rn=wociGetMemtableRows(cur);
	adjtm.Start();
	for(int i=0;i<rn;i++) {
		int thisrow=pkmode?wociGetRawrnByIK(cur,i):wociGetRawrnBySort(cur,i);
		//int thisrow=wociGetRawrnByIK(cur,i);
		if(strow==-1) {
			strow=thisrow;
			idx_startrow=blockrn;
		}
		//子块分割
		else 
			if(pkmode?(ikptr[strow]!=ikptr[thisrow]):
			(wociCompareSortRow(cur,strow,thisrow)!=0) ){
				//if(ikptr[strow]!=ikptr[thisrow]) {
				for(int c=0;c<cn1;c++) {
					idxptr[c]=pCur->PtrVoid(pidxc1[c],strow);
				}
				idx_rownum=blockrn-idx_startrow;
				wociInsertRows(idxdt,idxptr,NULL,1);
				totidxrn++;
				int irn=wociGetMemtableRows(idxdt);
				if(irn>MAX_BLOCKRN-2) {
					int *pbo=idxdt.PtrInt("idx_blockoffset",0);
					int pos=irn-1;
					while(pos>=0 && pbo[pos]==idx_blockoffset) pos--;
					if(pos>0) {
						di.WriteMt(idxdt,COMPRESSLEVEL,pos+1,false);
						if(pos+1<irn) 
							wociCopyRowsTo(idxdt,idxdt,0,pos+1,irn-pos-1);
						else wociReset(idxdt);
					}
					else ThrowWith("数据预处理错误,分区号%d,索引字段'%s',超过允许索引块长度%d.",partid,idxcolsname,MAX_BLOCKRN);
				}
				strow=thisrow;
				idx_startrow=blockrn;
			}
			//blockmt.QuickCopyFrom(pcur,blockrn,thisrow);
			wociCopyRowsTo(cur,blockmt,-1,thisrow,1);
			blockrn++;//=wociGetMemtableRows(blockmt);
			//块和子块的分割
			if(blockrn>=maxblockrn) {
				adjtm.Stop();
				fiotm.Start();
				for(int c=0;c<cn1;c++) {
					idxptr[c]=pCur->PtrVoid(pidxc1[c],strow);
				}
				idx_rownum=blockrn-idx_startrow;
				wociInsertRows(idxdt,idxptr,NULL,1);
				totidxrn++;
				idx_blockoffset=df.WriteMt(blockmt,COMPRESSLEVEL,0,false);
				idx_startrow=0;
				strow=-1;blockrn=0;
				blockmt.Reset();
				fiotm.Stop();
				adjtm.Start();
			}
	}
	adjtm.Stop();
	//保存最后的块数据
	if(blockrn) {
		for(int c=0;c<cn1;c++) {
			idxptr[c]=pCur->PtrVoid(pidxc1[c],strow);
		}
		idx_rownum=blockrn-idx_startrow;
		wociInsertRows(idxdt,idxptr,NULL,1);
		totidxrn++;
		idx_blockoffset=df.WriteMt(blockmt,COMPRESSLEVEL,0,false);
		idx_startrow=0;
		strow=-1;blockrn=0;
		blockmt.Reset();
	}
	//保存索引数据
	{
		di.WriteMt(idxdt,COMPRESSLEVEL,0,false);
		di.SetFileHeader(totidxrn,NULL);
	}
	//保存文件索引
	{
		void *ptr[20];
		//		int subdatasetid=((partid%100)*100+(idx%100))*10000+(datasetid%10000);
		int subdatasetid=partid;
		ptr[0]=&fid;ptr[1]=&taskid;ptr[2]=&partid;
		ptr[3]=&subdatasetid;ptr[4]=&srctabid;ptr[5]=&dp.tabid;
		int rn=df.GetRowNum();
		int fl=df.GetLastOffset();
		ptr[6]=&rn;ptr[7]=&fl;
		char now[10];
		wociGetCurDateTime(now);
		ptr[8]=tmpfn;ptr[9]=tmpidxfn;ptr[10]=now;
		int state=1;
		ptr[11]=&state;
		char nuldt[10];
		memset(nuldt,0,10);
		ptr[12]=now;//nuldt;
		ptr[13]=&dp.idxp[idx].idxid;
		ptr[14]=dp.idxp[idx].idxcolsname;
		ptr[15]=dp.idxp[idx].idxreusecols;
		ptr[16]=&datasetid;
		ptr[17]=NULL;
		wociInsertRows(fnmt,ptr,NULL,1);
	}
	freeinfo1("End ProcBlock");
}


int DataDump::heteroRebuild(SysAdmin &sp)
{
	bool ec=wociIsEcho();
	wociSetEcho(FALSE);
	AutoMt mt(sp.GetDTS(),100);
	mt.FetchAll("select * from dt_taskschedule where taskstatus=%d limit 100",HETERO_NEW);
	int rn=mt.Wait();
	if(rn<1) return 0;
	wociSetTraceFile("hdr异构数据重建/");
	taskid=mt.GetInt("taskid",0);
	char srcdbn[150],srctabname[150],dstdbn[150],dsttabname[150];
	int id1=mt.GetInt("tabid",0);
	int id2=mt.GetInt("pretaskid",0);
	mt.FetchAll("select * from dt_table where tabid=%d",id1);
	if(mt.Wait()<1)
		ThrowWith("找不到DP表(%d).",id1);
	strcpy(dstdbn,mt.PtrStr("databasename",0));
	strcpy(dsttabname,mt.PtrStr("tabname",0));
	mt.FetchAll("select * from dt_table where tabid=%d",id2);
	if(mt.Wait()<1)
		ThrowWith("找不到DP表(%d).",id2);
	strcpy(srcdbn,mt.PtrStr("databasename",0));
	strcpy(srctabname,mt.PtrStr("tabname",0));
	
	lgprintf("Heterogenenous rebuild table from '%s.%s' to '%s.%s'.",srcdbn,srctabname,dstdbn,dsttabname);
	mt.FetchAll("select pathval from dt_path where pathtype='msys'");
	rn=mt.Wait();
	if(rn<1) 
		ThrowWith("找不到MySQL数据目录(dt_path.pathtype='msys'),数据转移异常中止.");
	char dtpath[300];
	strcpy(dtpath,mt.PtrStr(0,0));
	
	mt.FetchAll("select * from dt_table where tabname=lower('%s') and databasename=lower('%s')",dsttabname,dstdbn);
	int tabid=-1;
	rn=mt.Wait();
	int recordnum=mt.GetInt("recordnum",0);
	if(rn<0) ThrowWith("找不到目标表'%s.%s',无法继续！",dstdbn,dsttabname);
	if(recordnum>0) ThrowWith("目标表非空(记录数%d),无法继续！",recordnum);
	int dsttabid=mt.GetInt("tabid",0);
	mt.FetchAll("select * from dt_table where tabname=lower('%s') and databasename=lower('%s')",srctabname,srcdbn);
	rn=mt.Wait();
	if(rn<1) 
		ThrowWith("源表'%s.%s'不存在.",srcdbn,srctabname);
	tabid=mt.GetInt("tabid",0);
	datasetid=mt.GetInt("datasetid",0);
	recordnum=mt.GetInt("recordnum",0);
	srctabid=abs(mt.GetInt("srctabid",0));
	if(recordnum<1) ThrowWith("源表'%s.%s'为空表，无法继续.",srcdbn,srctabname);
	int firstdatafileid=mt.GetInt("firstdatafileid",0);
	double totalbytes=mt.GetDouble("totalbytes",0);
	int datafilenum=mt.GetInt("datafilenum",0);
	lgprintf("源表'%s.%s' id:%d,数据集编号:%d,记录数:%d,首文件编号:%d",
		srcdbn,srctabname,tabid,datasetid,recordnum,firstdatafileid);
	sp.GetSoledIndexParam(srctabid,&dp,dsttabid);
	if(xmkdir(dp.tmppath[0])) 
		ThrowWith("临时主路径无法建立,源表:%d,任务号:%d,路径:%s.",
		srctabid,taskid,dp.tmppath[0]);
	if(xmkdir(dp.tmppath[1]))
		ThrowWith("临时备用路径无法建立,源表:%d,任务号:%d,路径:%s.",
		srctabid,taskid,dp.tmppath[1]);
	int realrn=memlimit/dp.rowlen;
	sp.UpdateTaskStatus(HETERO_DUMPING,taskid);
	fnmt.Reset();
	bool dumpcomplete=false;
	try {
		//if(realrn>dp.maxrecnum) realrn=dp.maxrecnum;
		{
			AutoStmt st(dtdbc);
			st.Prepare("delete from dt_middledatafile where datasetid=%d and taskid=%d",datasetid,taskid);
			st.Execute(1);
			st.Wait();
		}
		maxblockrn=sp.GetMaxBlockRnFromSrcTab(srctabid);
		AutoMt blockmt(0,maxblockrn);
		file_mt mtf(true);
		mt.FetchAll("select * from dt_datafilemap where fileid=%d and fileflag!=2",firstdatafileid);
		int rn=mt.Wait();
		if(rn<1) 
			ThrowWith("Data file not found ,fileid:%d,table :'%s.%s'.",
			firstdatafileid,srcdbn,srctabname);
		mtf.Open(mt.PtrStr("filename",0),0,firstdatafileid);
		int smt;
		AutoMt dtmt(0,realrn);
		smt=mtf.ReadBlock(-1,0,0);
		if(smt) rn=wociGetMemtableRows(smt);
		else rn=0;
		wociCopyColumnDefine(dtmt,smt,NULL);
		dtmt.Build();  
		blockmt.Clear();
		wociCopyColumnDefine(blockmt,smt,NULL);
		blockmt.Build();
		rn=1;
		int crn=0;
		int drn=0;
        drn=wociGetMemtableRows(dtmt);
		while(rn>0 || drn>0)
		{
			if(drn+rn>realrn || rn==0) {
				lgprintf("开始数据处理");
				for(int i=0;i<dp.soledindexnum;i++) {
					ProcBlock(0,&dtmt,i,blockmt,sp.NextFileID());
				}
				lgprintf("数据处理结束");
				wociReset(dtmt);
			}
			if(rn>0) {
				wociCopyRowsTo(smt,dtmt,-1,0,rn);
				smt=mtf.ReadBlock(-1,0,0);
				if(smt) rn=wociGetMemtableRows(smt);
				else rn=0;
				crn+=rn;
				if(crn>50000) {
					printf(".");
					fflush(stdout);
					crn=0;
				}
			}
			drn=wociGetMemtableRows(dtmt);
		}
		wociSetEcho(ec);
		dumpcomplete=true;
		wociAppendToDbTable(fnmt,"dt_middledatafile",dtdbc,true);
		sp.UpdateTaskStatus(DUMPED,taskid);
	}	
	catch(...) {
		int frn=wociGetMemtableRows(fnmt);
		errprintf("数据重建异常终止，任务号:%d,中间文件数:%d.",taskid,frn);
		bool restored=false;
		if(dumpcomplete) {
			//当前任务的导出以完成，但修改DP参数失败.重试10次,如果仍然失败,则放弃.
			int retrytimes=0;
			while(retrytimes<10 &&!restored) {
				restored=true;
				try {
					wociAppendToDbTable(fnmt,"dt_middledatafile",dtdbc,true);
					sp.UpdateTaskStatus(DUMPED,taskid);
				}
				catch(...) {
					lgprintf("任务%d导出已完成,但写入dt参数表(dt_middledatafile)失败,一分钟后重试(%d)...",taskid,++retrytimes);
					restored=false;
					mSleep(60000);
				}
			}
		}
		if(!restored) {
			int i;
			wociMTPrint(fnmt,0,NULL);
			//先做恢复任务状态的操作,因为任务状态的人工调整最为容易.如果数据库连接一直没有恢复,
			//则任务状态恢复会引起异常,后续的删除文件和记录的操作不会被执行,可以由人工来确定是否可恢复,如何恢复
			errprintf("恢复任务状态.");
			sp.UpdateTaskStatus(HETERO_NEW,taskid);
			errprintf("删除中间文件...");
			for(i=0;i<frn;i++) {
				errprintf("\t %s \t %s",fnmt.PtrStr("datafilename",i),
					fnmt.PtrStr("indexfilename",i));
			}
			for(i=0;i<frn;i++) {
				unlink(fnmt.PtrStr("datafilename",i));
				unlink(fnmt.PtrStr("indexfilename",i));
			}
			errprintf("删除中间文件记录...");
			AutoStmt st(dtdbc);
			st.Prepare("delete from dt_middledatafile where datasetid=%d and taskid=%d",datasetid,taskid);
			st.Execute(1);
			st.Wait();
			throw;
		}
	}
	
	lgprintf("数据抽取结束,任务状态1-->2,taskid:%d",taskid);
	lgprintf("结束");
	return 0;
}

int DataDump::DoDump(SysAdmin &sp) {
	int tabid=0;
	taskid=sp.GetFirstTaskID(NEWTASK,srctabid,datasetid,tabid);
	if(taskid<1) return 0;
	wociSetTraceFile("dump数据导出/");
	sorttm.Clear();
	fiotm.Clear();
	adjtm.Clear();
	sp.GetSoledIndexParam(srctabid,&dp,tabid);
	sp.OutTaskDesc("执行数据导出任务: ",taskid);
	if(xmkdir(dp.tmppath[0])) 
		ThrowWith("临时主路径无法建立,源表:%d,任务号:%d,路径:%s.",
		srctabid,taskid,dp.tmppath[0]);
	if(xmkdir(dp.tmppath[1]))
		ThrowWith("临时备用路径无法建立,源表:%d,任务号:%d,路径:%s.",
		srctabid,taskid,dp.tmppath[1]);
	AutoHandle srcdbc;
	srcdbc.SetHandle(sp.BuildSrcDBCFromSrcTableID(srctabid));
	int partoff=0;
	{	
		AutoMt srctstmt(0,10);
		sp.BuildMtFromSrcTable(srcdbc,srctabid,&srctstmt);
		srctstmt.AddrFresh();
		int srl=wociGetRowLen(srctstmt);
		char tabname[150];
		sp.GetTableName(tabid,-1,tabname,NULL,TBNAME_DEST);
		AutoMt dsttstmt(dtdbc,10);
		dsttstmt.FetchFirst("select * from %s",tabname);
		int tstrn=dsttstmt.Wait();
		if(srctstmt.CompareMt(dsttstmt)!=0 ) {
			dsttstmt.FetchFirst("select * from dt_taskschedule where tabid=%d and (taskstatus!=0 or strategyforpileup!=0)",tabid);
			int appendrn=dsttstmt.Wait();
			if(tstrn>0 && appendrn>0) 
				ThrowWith("表%s中已经有数据数据，但源表格式被修改，不能增量导入数据，请导入新的目标表中。",tabname);
			lgprintf("源表数据格式发生变化，重新解析源表... ");
			if(tstrn==0) {
				sp.CreateDT(tabid);
				sp.Reload();
				sp.GetSoledIndexParam(srctabid,&dp,tabid);
			}
			else {
				//由于目标表有数据，暂时不修改dt_table.recordlen
				dp.rowlen=srl;
			}
		}
		else if(srl!=dp.rowlen) {
			lgprintf("目标表中的记录长度错误，%d修改为%d",dp.rowlen,srl);
			AutoStmt st(dtdbc);
			st.Prepare("update dt_table set recordlen=%d where tabid=%d",srl,tabid);
			st.Execute(1);
			st.Wait();
		}
	}
	
	int realrn=memlimit/dp.rowlen;
	lgprintf("导出数据块%d字节(记录数:%d)",realrn*dp.rowlen,realrn);
	//if(realrn>dp.maxrecnum) realrn=dp.maxrecnum;
	{
		lgprintf("清除上次导出的数据...");
		
		AutoMt clsmt(dtdbc,100);
		AutoStmt st(dtdbc);
		int clsrn=0;
		do {
			clsmt.FetchAll("select * from dt_middledatafile where datasetid=%d and taskid=%d limit 100",datasetid,taskid);
			clsrn=clsmt.Wait();
			for(int i=0;i<clsrn;i++) {
				unlink(clsmt.PtrStr("datafilename",i));
				unlink(clsmt.PtrStr("indexfilename",i));
			}
			st.Prepare("delete from dt_middledatafile where datasetid=%d and taskid=%d limit 100",datasetid,taskid);
			st.Execute(1);
			st.Wait();
		} while(clsrn>0);
	}
	//realrn=50000;
	//indexparam *ip=&dp.idxp[dp.psoledindex];
	maxblockrn=blocksize/dp.rowlen;
	{
		//在作数据导出时设置块记录数,以后的处理和查询以此为依据
		//字段maxrecinblock的使用方法变更为:程序根据后台设置的参数自动计算,管理控制台只读
		lgprintf("设置目标数据块%d字节(记录数:%d)",maxblockrn*dp.rowlen,maxblockrn);
		AutoStmt st(dtdbc);
		st.Prepare("update dt_table set maxrecinblock=%d where tabid=%d",maxblockrn,dp.tabid);
		st.Execute(1);
		st.Wait();
	}
	sp.Reload();
	maxblockrn=sp.GetMaxBlockRnFromSrcTab(srctabid);
	AutoMt blockmt(0,maxblockrn);
	fnmt.Reset();
	int partid=0;
	fnorder=0;
	try {
		sp.UpdateTaskStatus(DUMPING,taskid);
	}
	catch(char *str) {
		lgprintf(str);
		return 0;
	}
	bool dumpcomplete=false;
	
	try {
		bool ec=wociIsEcho();
		wociSetEcho(TRUE);
		
		while(partid=sp.GetDumpSQL(taskid,partoff++,dumpsql),partid!=-1) {
			//idxdt.Reset();
			
			TradeOffMt dtmt(0,realrn);
			
			sp.BuildMtFromSrcTable(srcdbc,srctabid,dtmt.Cur());
			sp.BuildMtFromSrcTable(srcdbc,srctabid,dtmt.Next());
			blockmt.Clear();
			sp.BuildMtFromSrcTable(srcdbc,srctabid,&blockmt);
			//blockmt.Build(stmt);
			
			AutoStmt stmt(srcdbc);
			stmt.Prepare(dumpsql);
			wociReplaceStmt(*dtmt.Cur(),stmt);
			wociReplaceStmt(*dtmt.Next(),stmt);
			dtmt.Cur()->AddrFresh();
			dtmt.Next()->AddrFresh();
			//			dtmt.Cur()->Build(stmt);
			//			dtmt.Next()->Build(stmt);
			//准备数据索引表插入变量数组
			dtmt.FetchFirst();
			
			int rn=dtmt.Wait();
			while(rn>0) {
				dtmt.FetchNext();
				lgprintf("开始数据处理");
				freeinfo1("before call prcblk");
				for(int i=0;i<dp.soledindexnum;i++) {
					ProcBlock(partid,dtmt.Cur(),i/*dp.psoledindex*/,blockmt,sp.NextFileID());
				}
				lgprintf("数据处理结束");
				freeinfo1("after call prcblk");
				rn=dtmt.Wait();
			}
			//delete dtmt;
			//delete stmt;
		}
		wociSetEcho(ec);
		dumpcomplete=true;
		wociAppendToDbTable(fnmt,"dt_middledatafile",dtdbc,true);
		sp.UpdateTaskStatus(DUMPED,taskid);
		
	}
	catch(...) {
		int frn=wociGetMemtableRows(fnmt);
		errprintf("数据导出异常终止，任务号:%d,分区号:%d,中间文件数:%d.",taskid,partid,frn);
		bool restored=false;
		if(dumpcomplete) {
			//当前任务的导出以完成，但修改DP参数失败.重试10次,如果仍然失败,则放弃.
			int retrytimes=0;
			while(retrytimes<10 &&!restored) {
				restored=true;
				try {
					wociAppendToDbTable(fnmt,"dt_middledatafile",dtdbc,true);
					sp.UpdateTaskStatus(DUMPED,taskid);
				}
				catch(...) {
					lgprintf("任务%d导出已完成,但写入dt参数表(dt_middledatafile)失败,一分钟后重试(%d)...",taskid,++retrytimes);
					restored=false;
					mSleep(60000);
				}
			}
		}
		if(!restored) {
			int i;
			wociMTPrint(fnmt,0,NULL);
			//先做恢复任务状态的操作,因为任务状态的人工调整最为容易.如果数据库连接一直没有恢复,
			//则任务状态恢复会引起异常,后续的删除文件和记录的操作不会被执行,可以由人工来确定是否可恢复,如何恢复
			errprintf("恢复任务状态.");
			sp.UpdateTaskStatus(NEWTASK,taskid);
			errprintf("删除中间文件...");
			for(i=0;i<frn;i++) {
				errprintf("\t %s \t %s",fnmt.PtrStr("datafilename",i),
					fnmt.PtrStr("indexfilename",i));
			}
			for(i=0;i<frn;i++) {
				unlink(fnmt.PtrStr("datafilename",i));
				unlink(fnmt.PtrStr("indexfilename",i));
			}
			errprintf("删除中间文件记录...");
			AutoStmt st(dtdbc);
			st.Prepare("delete from dt_middledatafile where datasetid=%d and taskid=%d",datasetid,taskid);
			st.Execute(1);
			st.Wait();
			throw;
		}
	}
	
	lgprintf("数据抽取结束,任务状态1-->2,taskid:%d",taskid);
	lgprintf("sort time :%11.6f file io time :%11.6f adjust data time:%11.6f",
		sorttm.GetTime(),fiotm.GetTime(),adjtm.GetTime());
	lgprintf("结束");
	//lgprintf("按任意键继续...");
	//getchar();
	//MYSQL中的MY_ISAM不支持事务处理，对MYSQL表的修改不需要提交.
	return 0;
}

MiddleDataLoader::MiddleDataLoader(SysAdmin *_sp):
indexmt(0,0),mdindexmt(0,0),blockmt(0,0),mdf(_sp->GetDTS(),MAX_MIDDLE_FILE_NUM)
{
		  sp=_sp;
		  tmpfilenum=0;
		  pdtf=NULL;
		  pdtfid=NULL;
		  dtfidlen=0;
}



//homotgeneous rebuild index
int MiddleDataLoader::homo_reindex(const char *dbname,const char *tname) {
	//Check deserved temporary(middle) fileset
	//检查状态为1的任务
	wociSetTraceFile("hri同构重建索引/"); 
	mdf.FetchAll("select * from dt_table where databasename=lower('%s') and tabname=lower('%s')",dbname,tname);
	int rn=mdf.Wait();
	if(rn<1) ThrowWith("同构重建索引:在dt_table中'%s.%s'目标表无记录。",dbname,tname);
	int srctabid=abs(*mdf.PtrInt("srctabid",0));
	int tabid=*mdf.PtrInt("tabid",0);
	int blockmaxrn=*mdf.PtrInt("maxrecinblock",0);
	int datasetid=mdf.GetInt("datasetid",0);
	
	mdf.FetchAll("select * from dt_indexfilemap where tabid=%d and fileflag!=2 order by indexid,fileid",tabid);
	int irn=mdf.Wait();
	if(irn<1) {
		ThrowWith("同构重建索引:在dt_indexfilemap中%d目标表无索引数据文件的记录。",tabid);
	}
	sp->OutTaskDesc("同构索引重建:",0,tabid,srctabid,datasetid);
	try {
		int oldidxid=-1;
		for(int iid=0;iid<irn;iid++) {
			//取基本参数
			int indexid=mdf.GetInt("indexid",iid);
			/*
			AutoMt idxsubmt(sp->GetDTS(),100);
			idxsubmt.FetchAll("select * from dt_index where indexid=%d ",indexid);
			rn=idxsubmt.Wait();
			if(rn<1) {
			ThrowWith("同构重建索引:在dt_index中%d目标表无%d索引的记录。",tabid,indexid);
			}
			*/
			char idxtabname[100],dttabname[100];
			sp->GetTableName(tabid,indexid,dttabname,idxtabname,TBNAME_PREPONL);
			//strcpy(idxtabname,idxsubmt.PtrStr("indextabname",0));
			printf("\n处理文件%s--",mdf.PtrStr("filename",iid));
			fflush(stdout);
			
			//读全部索引数据
			char dtfn[300];
			dt_file idxf;
			idxf.Open(mdf.PtrStr("filename",iid),0);
			AutoMt idxmt(0);
			idxmt.SetHandle(idxf.CreateMt(idxf.GetRowNum()));
			int brn=0;
			int sbrn=0;
			while( (sbrn=idxf.ReadMt(-1,0,idxmt,false))>0) brn+=sbrn;
			
			//把索引数据文件的后缀由idx替换为dat就是数据文件.
			AutoMt destmt(0);
			strcpy(dtfn,mdf.PtrStr("filename",iid));
			strcpy(dtfn+strlen(dtfn)-3,"dat");
			//从数据文件取自段结构，内存表大小为目标表的每数据块最大行数。
			file_mt dtf;
			dtf.Open(dtfn,0);
			destmt.SetHandle(dtf.CreateMt(blockmaxrn));
			
			//早期数据的目标表索引使用的名字与同构索引将创建的索引名不相同，
			//例如tab_cdmavoicdr200308中的索引名为tab_cdmavoicdr2_x,这里将新建的名称为tab_cdmavoicdr200308_x
			//所以CreateIndex调用不能正确删除原索引，需要重新创建表。
			
			
			//建立索引表
			AutoMt idxtarget(0,brn);
			char colsname[300];
			int pblockc[20];
			int stcn=sp->CreateIndexMT(idxtarget,destmt,indexid,pblockc,colsname,oldidxid!=indexid),bcn=stcn;
			// 取独立索引和复用索引在blockmt(目标数据块内存表)结构中的位置，
			// 检查结构描述文件建立的索引是否和系统参数表中指定的字段数相同。
			void *indexptr[40];
			
			//建立目标表结构 ?
			//if(oldidxid!=indexid) sp->CreateTableOnMysql(destmt,dttabname,true);
			oldidxid=indexid;
			
			//设置对idxtarget插入记录需要的结构和变量。
			int dtfid,blockstart,blocksize,blockrn=0,startrow,rownum;
			indexptr[stcn++]=&dtfid;
			indexptr[stcn++]=&blockstart;
			indexptr[stcn++]=&blocksize;
			indexptr[stcn++]=&blockrn;
			indexptr[stcn++]=&startrow;
			indexptr[stcn++]=&rownum;
			indexptr[stcn]=NULL;
			
			char nidxfn[300];
			sprintf(nidxfn,"%s.reidx",mdf.PtrStr("filename",iid));
			dt_file nidxf;
			nidxf.Open(nidxfn,1);
			
			lgprintf("开始数据处理(同构索引重建)....");
			int oldblockstart=-1;
			int dspct=0;
			int totct=0;
			
			for(int i=0;i<brn;i++) {
				//直接使用字段名称会造成idx_rownum字段的名称不匹配，早期的idx数据文件中的字段名为rownum.
				dtfid=*idxmt.PtrInt(bcn,i);
				blockstart=*idxmt.PtrInt(bcn+1,i);
				blocksize=*idxmt.PtrInt(bcn+2,i);
				blockrn=*idxmt.PtrInt(bcn+3,i);
				startrow=*idxmt.PtrInt(bcn+4,i);
				rownum=*idxmt.PtrInt(bcn+5,i);
				if(oldblockstart!=blockstart) {
					int mt=dtf.ReadBlock(blockstart,0,1,true);
					destmt.SetHandle(mt,true);
					oldblockstart=blockstart;
				}
				int c;
				totct+=rownum;if(totct-dspct>200000) {printf(".");fflush(stdout);dspct=totct;}
				for(c=0;c<bcn;c++) {
					indexptr[c]=destmt.PtrVoid(pblockc[c],startrow);
				}
				wociInsertRows(idxtarget,indexptr,NULL,1);
				
			} // end of for(...)
			nidxf.WriteHeader(idxtarget,dtfid);
			int idxfsize=nidxf.WriteMt(idxtarget,COMPRESSLEVEL,0,false);
			nidxf.SetFileHeader(wociGetMemtableRows(idxtarget),NULL);
		}// end of for
		for(int i=0;i<irn;i++) {
			//Replace files...
			char dtfn[300];
			sprintf(dtfn,"%s.reidx",mdf.PtrStr("filename",i));
			unlink(mdf.PtrStr("filename",i));
			rename(dtfn,mdf.PtrStr("filename",i));
		}
		lgprintf("数据集编号为%d的任务,状态-->30(等待装入).",datasetid);
		//如果是单分区处理任务，必须是所有相同数据集的任务状态为30，才能启动下一步的操作（数据装入）。
		char sqlbf[300];
		sprintf(sqlbf,"update dt.dt_taskschedule set taskstatus=30 where datasetid=%d",
			datasetid);
		sp->DoQuery(sqlbf);
		
	} // end of try
	catch (...) {
		errprintf("同构索引重建出现异常，tabid:%d.",tabid);
		errprintf("删除已处理的索引数据文件.");
		int i;
		errprintf("删除文件...");
		char fn[300];
		for(i=0;i<irn;i++) {
			sprintf(fn,"%s.reidx",mdf.PtrStr("filename",i));
			errprintf("\t %s ",fn);
		}
		for(i=0;i<irn;i++) {
			sprintf(fn,"%s.reidx",mdf.PtrStr("filename",i));
			unlink(fn);
		}
		throw ;
	}
	printf("\n");
	lgprintf("数据处理结束,共处理%d个文件.",irn);
	return 1;
  }
  
  int MiddleDataLoader::CreateLike(const char *dbn,const char *tbn,const char *nsrctbn,const char *ndsttbn,const char *taskdate)
  {
	  int tabid=0,srctabid=0;
	  AutoMt mt(sp->GetDTS(),10);
	  char tdt[21];
	  if(strcmp(taskdate,"now")==0) 
		  wociGetCurDateTime(tdt);
	  else {
		  mt.FetchAll("select adddate(cast('%s' AS DATETIME),interval 0 day) as tskdate",taskdate);
		  if(mt.Wait()!=1) 
			  ThrowWith("日期格式错误:'%s'",taskdate);
		  memcpy(tdt,mt.PtrDate("tskdate",0),7);
		  if(wociGetYear(tdt)==0)
			  ThrowWith("日期格式错误:'%s'",taskdate);
	  }
	  mt.FetchAll("select * from dt_table where databasename='%s' and tabname='%s'",dbn,ndsttbn);
	  if(mt.Wait()>0) 
		  ThrowWith("表 %s.%s 已经存在。",dbn,ndsttbn);
	  
	  AutoMt tabmt(sp->GetDTS(),10);
	  tabmt.FetchAll("select * from dt_table where databasename='%s' and tabname='%s'",dbn,tbn);
	  if(tabmt.Wait()!=1) 
		  ThrowWith("参考表 %s.%s 不存在。",dbn,tbn);
	  int reftabid=tabmt.GetInt("tabid",0);
	  int refsrctabid=abs(tabmt.GetInt("srctabid",0));
	  if(refsrctabid<1) 
		  ThrowWith("参考表 %s.%s 没有源表信息。",dbn,tbn);
	  //填充目标表信息
	  strcpy(tabmt.PtrStr("tabdesc",0),ndsttbn);
	  strcpy(tabmt.PtrStr("tabname",0),ndsttbn);
	  *tabmt.PtrInt("cdfileid",0)=0;
	  *tabmt.PtrDouble("recordnum",0)=0;
	  *tabmt.PtrInt("datasetid",0)=0;
	  *tabmt.PtrInt("firstdatafileid",0)=0;
	  *tabmt.PtrInt("datafilenum",0)=0;
	  *tabmt.PtrDouble("totalbytes",0)=0;
	  tabid=sp->NextTableID();
	  *tabmt.PtrInt("tabid",0)=tabid;
	  // 对应的源表稍后修改
	  
	  AutoMt srctabmt(sp->GetDTS(),10);
	  srctabmt.FetchAll("select * from dt_srctable where srctabid=%d",refsrctabid);
	  if(srctabmt.Wait()!=1) 
		  ThrowWith("参考表 %s.%s 不存在。",dbn,tbn);
	  if(strlen(srctabmt.PtrStr("extsql",0))>0) 
		  ThrowWith("参考表的源表中指定了数据抽取语句，不能做类似创建。");
	  //填充源表信息
	  srctabid=sp->NextTableID();
	  *srctabmt.PtrInt("srctabid",0)=srctabid;
	  *tabmt.PtrInt("srctabid",0)=srctabid;
	  *srctabmt.PtrInt("tabid",0)=tabid;
	  strcpy(srctabmt.PtrStr("srctabname",0),nsrctbn);
	  
	  AutoMt indexmt(sp->GetDTS(),200);
	  indexmt.FetchAll("select * from dt_index where tabid=%d",reftabid);
	  int irn=indexmt.Wait();
	  if(irn<1)
		  ThrowWith("参考表 %s.%s 没有建立索引。",dbn,tbn);
	  int soledct=1;
	  //填充索引信息，重建复用关系
	  for(int ip=0;ip<irn;ip++) {
		  int refidxid=indexmt.GetInt("indexid",ip);
		  int idxid=*indexmt.PtrInt("indexid",ip)=sp->NextIndexID();
		  *indexmt.PtrInt("tabid",ip)=tabid;
		  *indexmt.PtrInt("cdfileid",0)=0;
		  if(indexmt.GetInt("issoledindex",ip)>0) {
			  sprintf(indexmt.PtrStr("indextabname",ip),
				  "%sidx%d",ndsttbn,soledct++);
			  for(int schidx=0;schidx<irn;schidx++) {
				  if(indexmt.GetInt("reuseindexid",schidx)==refidxid) {
					  *indexmt.PtrInt("reuseindexid",schidx)=idxid;
					  strcpy(indexmt.PtrStr("indextabname",schidx),
						  indexmt.PtrStr("indextabname",ip));
				  }
			  }
		  }
	  }
	  AutoMt partmt(sp->GetDTS(),500);
	  partmt.FetchAll("select * from dt_srcpartinfo where srctabid=%d",refsrctabid);
	  int prn=partmt.Wait();
	  if(prn>0) {
		  for(int pp=0;pp<prn;pp++) {
			  *partmt.PtrInt("partid",pp)=sp->NextTableID();
			  *partmt.PtrInt("srctabid",pp)=srctabid;
		  }
	  }
	  
	  AutoMt taskmt(sp->GetDTS(),500);
	  taskmt.FetchAll("select * from dt_taskschedule where tabid=%d",reftabid);
	  int trn=taskmt.Wait();
	  if(trn<1) 
		  ThrowWith("参考表 %s.%s 没有任务信息。",dbn,tbn);
	  if(trn==1 && taskmt.GetInt("partid",0)>0) 
		  ThrowWith("参考表 %s.%s 按分区拆分任务,但只发现一个任务",dbn,tbn);
	  if(trn>1 && (taskmt.GetInt("partid",0)==0 || trn!=prn) )
		  ThrowWith("参考表 %s.%s 按分区拆分任务,但任务数与分区数不一致",dbn,tbn);
	  int datasetid=sp->NextDatasetID();
	  for(int tp=0;tp<trn;tp++) {
		  *taskmt.PtrInt("taskid",tp)=sp->NextDatasetID();
		  *taskmt.PtrInt("datasetid",tp)=datasetid;
		  *taskmt.PtrInt("srctabid",tp)=srctabid;
		  if(trn>1)
			  *taskmt.PtrInt("partid",tp)=partmt.GetInt("partid",tp);
		  else
			  *taskmt.PtrInt("partid",tp)=0;
		  memset(taskmt.PtrDate("launchtime",tp),0,7);
		  memcpy(taskmt.PtrDate("begintime",tp),tdt,7);
		  memset(taskmt.PtrDate("endtime",tp),0,7);
		  memset(taskmt.PtrDate("lastlaunchtime",tp),0,7);
		  *taskmt.PtrInt("taskstatus",tp)=0;
		  sprintf(taskmt.PtrStr("datasetdetail",tp),"%s.%s",dbn,ndsttbn);
		  *taskmt.PtrInt("tabid",tp)=tabid;
	  }
	  
	  try {
		  wociAppendToDbTable(tabmt,"dt_table",sp->GetDTS(),true);
		  wociAppendToDbTable(srctabmt,"dt_srctable",sp->GetDTS(),true);
		  wociAppendToDbTable(indexmt,"dt_index",sp->GetDTS(),true);
		  wociAppendToDbTable(partmt,"dt_srcpartinfo",sp->GetDTS(),true);
		  wociAppendToDbTable(taskmt,"dt_taskschedule",sp->GetDTS(),true);
	  }
	  catch(...) {
		  //恢复数据，回退所有操作
		  AutoStmt st(sp->GetDTS());
		  st.DirectExecute("delete dt_table where tabid=%d",tabid);
		  st.DirectExecute("delete dt_srctable where tabid=%d",tabid);
		  st.DirectExecute("delete dt_index where tabid=%d",tabid);
		  st.DirectExecute("delete dt_srcpartinfo where srctabid=%d",srctabid);
		  st.DirectExecute("delete dt_taskschedule where tabid=%d",tabid);
		  errprintf("作类似创建时数据提交失败，已删除数据。");
		  throw;
	  }
	  {
		  char dtstr[100];
		  wociDateTimeToStr(tdt,dtstr);
		  lgprintf("创建成功,源表'%s',目标表'%s',开始时间'%s'.",nsrctbn,ndsttbn,dtstr);
	  }
	  return 0;
}

//DT data&index File Check
int MiddleDataLoader::dtfile_chk(const char *dbname,const char *tname) {
	//Check deserved temporary(middle) fileset
	//检查状态为1的任务
	mdf.FetchAll("select * from dt_table where databasename=lower('%s') and tabname=lower('%s')",dbname,tname);
	int rn=mdf.Wait();
	if(rn<1) ThrowWith("DP文件检查:在dt_table中'%s.%s'目标表无记录。",dbname,tname);
	int firstfid=mdf.GetInt("firstdatafileid",0);
	int srctabid=abs(*mdf.PtrInt("srctabid",0));
	int tabid=*mdf.PtrInt("tabid",0);
	int blockmaxrn=*mdf.PtrInt("maxrecinblock",0);
	int datasetid=mdf.GetInt("datasetid",0);
	double totrc=mdf.GetDouble("recordnum",0);
	sp->OutTaskDesc("目标表检查 :",0,tabid);
	char *srcbf=new char[SRCBUFLEN];//每一次处理的最大数据块（解压缩后）。
	int errct=0;
	mdf.FetchAll("select * from dt_indexfilemap where tabid=%d and fileflag!=2 order by indexid,fileid",tabid);
	int irn=mdf.Wait();
	if(irn<1) {
		ThrowWith("DP文件检查:在dt_indexfilemap中%d目标表无索引数据文件的记录。",tabid);
	}
	
	{
		AutoMt datmt(sp->GetDTS(),100);
		datmt.FetchAll("select * from dt_datafilemap where fileid=%d",firstfid);
		if(datmt.Wait()!=1) 
			ThrowWith("开始数据文件(编号%d)在系统中没有记录.",firstfid);
		char linkfn[300];
		strcpy(linkfn,datmt.PtrStr("filename",0));
		datmt.FetchAll("select * from dt_datafilemap where tabid=%d and fileflag!=2 and isfirstindex=1 order by subdatasetid,fileid",tabid);
		int rn1=datmt.Wait();
		if(firstfid!=datmt.GetInt("fileid",0)) 
			ThrowWith("开始数据文件(编号%d)在设置错误，应该是%d..",firstfid,datmt.GetInt("fileid",0));
		int lfn=0;
		while(true) {
			file_mt dtf;
			lfn++;
			dtf.Open(linkfn,0);
			const char *fn=dtf.GetNextFileName();
			if(fn==NULL) {
				printf("%s==>结束.\n",linkfn);
				break;
			}
			printf("%s==>%s\n",linkfn,fn);
			strcpy(linkfn,fn);
		}
		if(lfn!=rn1) 
			ThrowWith("文件链接错误，缺失%d个文件.",rn1-lfn);
	}
	
	mytimer chktm;
	chktm.Start();
	try {
		int oldidxid=-1;
		for(int iid=0;iid<irn;iid++) {
			//取基本参数
			int indexid=mdf.GetInt("indexid",iid);
			
			AutoMt idxsubmt(sp->GetDTS(),100);
			idxsubmt.FetchAll("select * from dt_index where indexid=%d ",indexid);
			rn=idxsubmt.Wait();
			if(rn<1) {
				ThrowWith("DP文件检查:在dt_index中%d目标表无%d索引的记录。",tabid,indexid);
			}
			
			printf("检查文件%s--\n",mdf.PtrStr("filename",iid));
			fflush(stdout);
			
			//遍历全部索引数据
			char dtfn[300];
			dt_file idxf;
			idxf.Open(mdf.PtrStr("filename",iid),0);
			AutoMt idxmt(0);
			idxmt.SetHandle(idxf.CreateMt(1));
			idxmt.SetHandle(idxf.CreateMt(FIX_MAXINDEXRN*1024*1024/wociGetRowLen(idxmt)));
			int brn=0;//idxf.ReadMt(-1,0,idxmt,false);
			int sbrn=0;
			while( (sbrn=idxf.ReadMt(-1,0,idxmt,true))>0) brn+=sbrn;
			int thiserrct=errct;
			//把索引数据文件的后缀由idx替换为dat就是数据文件.
			AutoMt destmt(0);
			strcpy(dtfn,mdf.PtrStr("filename",iid));
			strcpy(dtfn+strlen(dtfn)-3,"dat");
			//从数据文件取字段结构，内存表大小为目标表的每数据块最大行数。
			//destmt.SetHandle(dtf.CreateMt(blockmaxrn));
			FILE *fp=fopen(dtfn,"rb");
			if(fp==NULL)
				ThrowWith("DP文件检查:文件'%s'错误.",dtfn);
			fseek(fp,0,SEEK_END);
			unsigned int flen=ftell(fp);
			fseek(fp,0,SEEK_SET);
			block_hdr *pbhdr=(block_hdr *)srcbf;
			
			int oldblockstart=-1;
			int dspct=0;
			int totct=0;
			int blockstart,blocksize;
			int rownum;
			int bcn=wociGetColumnPosByName(idxmt,"dtfid");
			int bkf=0;
			sbrn=idxf.ReadMt(0,0,idxmt,true);
			int ist=0;
			for(int i=0;i<brn;i++) {
				//直接使用字段名称会造成idx_rownum字段的名称不匹配，早期的idx数据文件中的字段名为rownum.
				//dtfid=*idxmt.PtrInt(bcn,i);
				if(i>=sbrn) {
					ist=sbrn;
					sbrn+=idxf.ReadMt(-1,0,idxmt,true);
				}
				blockstart=*idxmt.PtrInt(bcn+1,i-ist);
				blocksize=*idxmt.PtrInt(bcn+2,i-ist);
				//blockrn=*idxmt.PtrInt(bcn+3,i);
				//startrow=*idxmt.PtrInt(bcn+4,i);
				rownum=*idxmt.PtrInt(bcn+5,i-ist);
				if(oldblockstart!=blockstart) {
					try {
						//dtf.ReadMt(blockstart,blocksize,mdf,1,1,srcbf);
						fseek(fp,blockstart,SEEK_SET);
						if(fread(srcbf,1,blocksize,fp)!=blocksize) {
							errprintf("读数据错误，位置:%d,长度:%d,索引序号:%d.\n",blockstart,blocksize,i);
							throw -1;
						}
						pbhdr->ReverseByteOrder();
						if(!dt_file::CheckBlockFlag(pbhdr->blockflag))
						{
							errprintf("错误的块标识，位置:%d,长度:%d,索引序号:%d.\n",blockstart,blocksize,i);
							throw -1;
						}
						if(pbhdr->blockflag!=bkf) {
							bkf=pbhdr->blockflag;
							//if(bkf==BLOCKFLAG) printf("数据块类型:WOCI.\n");
							//else if(bkf==MYSQLBLOCKFLAG)
							//  printf("数据块类型:MYISAM.\n");
							printf("数据块类型: %s .\n",dt_file::GetBlockTypeName(pbhdr->blockflag));
							printf("压缩类型:%d.\n",pbhdr->compressflag);
						}
						if(pbhdr->storelen!=blocksize-sizeof(block_hdr))
						{
							errprintf("错误的块长度，位置:%d,长度:%d,索引序号:%d.\n",blockstart,blocksize,i);
							throw -1;
						}
					}
					catch (...) {
						if(errct++>100) {
							errprintf("太多的错误，已放弃检查！");
							throw;
						}	
					}
					//int mt=dtf.ReadBlock(blockstart,0,1,true);
					//destmt.SetHandle(mt,true);
					oldblockstart=blockstart;
				}
				totct+=rownum;
				if(totct-dspct>200000) {
					printf("%d/%d    --- %d%%\r",i,brn,i*100/brn);
					fflush(stdout);
					dspct=totct;
				}
			} // end of for(...)
			if(ftell(fp)!=flen) {
				errprintf("文件长度不匹配，数据文件长度:%d,索引文件指示的结束位置:%d\n",flen,ftell(fp));
				errct++;
			}
			printf("文件检查完毕，错误数 ：%d.    \n",errct-thiserrct);
			fclose(fp);
		}// end of for
	} // end of try
	catch (...) {
		errprintf("DP文件检查出现异常，tabid:%d.",tabid);
	}
	delete []srcbf;
	if(errct>0)
		errprintf("DP文件检查出现错误，可能需要使用异构重建方式建立索引.");
	printf("\n");
	chktm.Stop();
	lgprintf("DP文件检查结束,共处理%d个文件,发现%d个错误(%.2fs).",irn,errct,chktm.GetTime());
	return 1;
  }
  
  
  void MiddleDataLoader::CheckEmptyDump() {
	  mdf.FetchAll("select * from dt_taskschedule where taskstatus=2 limit 100");
	  int rn=mdf.Wait();
	  if(rn>0) {
		  while(--rn>=0) {
			  AutoMt tmt(sp->GetDTS(),10);
			  tmt.FetchAll("select * from dt_middledatafile where taskid=%d and procstate!=3 limit 10",mdf.GetInt("taskid",rn));
			  if(tmt.Wait()<1) {
				  AutoStmt st(sp->GetDTS());
				  st.Prepare(" update dt_taskschedule set taskstatus=3 where taskid=%d",mdf.GetInt("taskid",rn));
				  st.Execute(1);
				  st.Wait();
				  lgprintf("任务%d的数据为空，修改为已整理。",mdf.GetInt("taskid",rn));
			  }
		  }
	  }
  }
  // MAXINDEXRN 缺省值500MB,LOADIDXSIZE缺省值1600MB
  // MAXINDEXRN 为最终索引文件,记录长度对应索引表.
  // LOADIDXSIZE 存储临时索引,记录长度从数据导出时的索引文件中内存表计算.
  
  //2005/08/24修改： MAXINDEXRN不再使用
  //2005/11/01修改： 装入状态分为1(待装入），2（正装入),3（已装入);取消10状态(原用于区分第一次和第二次装入)
  //2005/11/01修改： 索引数据装入内存时的策略改为按索引分段。
  int MiddleDataLoader::Load(int MAXINDEXRN,int LOADTIDXSIZE,bool useOldBlock) {
	  //Check deserved temporary(middle) fileset
	  //检查状态为1的任务，1为抽取结束等待装入.
	  int subdatasetid=0;
	  CheckEmptyDump();
	  mdf.FetchAll("select * from dt_middledatafile where procstate<=1 order by datasetid,indexid,subdatasetid limit 100");
	  int rn=mdf.Wait();
	  //如果索引超过LOADIDXSIZE,需要分批处理,则只在处理第一批数据时清空DT_DATAFILEMAP/DT_INDEXFILEMAP表
	  //区分第一次和第二次装入的意义：如果一份数据子集（指定数据集-〉分区(subdatasetid)->索引)被导出后，在开始装入以前，要
	  //  先删除上次正在装入的数据（注意：已上线的数据不在这里删除，而在装入结束后删除).
	  bool firstbatch=true;
	  if(rn<1) return 0;
	  
	  //检查该数据子集是否第一次装入
	  subdatasetid=mdf.GetInt("subdatasetid",0);
	  int indexid=mdf.GetInt("indexid",0);
	  int datasetid=mdf.GetInt("datasetid",0);
	  mdf.FetchAll("select procstate from dt_middledatafile where subdatasetid=%d and datasetid=%d and indexid=%d and procstate>1 limit 10",
		  subdatasetid,datasetid,indexid);
	  firstbatch=mdf.Wait()<1;//数据子集没有正整理或已整理的记录。
	  
	  //取出中间文件记录
	  mdf.FetchAll("select * from dt_middledatafile where subdatasetid=%d  and datasetid=%d and indexid=%d and procstate<=1 order by mdfid limit %d",
		  subdatasetid,datasetid,indexid,MAX_MIDDLE_FILE_NUM);
	  rn=mdf.Wait();
	  if(rn<1) 
		  ThrowWith("MiddleDataLoader::Load : 确定数据子集后找不到中间数据记录(未处理)。");
	  
	  
	  //取基本参数
	  int idxtlimit=0,idxdlimit=0;//临时区(多个抽取数据文件对应)和目标区(单个目标数据文件对应)的索引最大记录数.
	  wociSetTraceFile("dr数据整理/");
	  int srctabid=mdf.GetInt("srctabid",0);
	  //indexid=mdf.GetInt("indexid",0);
	  //datasetid=mdf.GetInt("datasetid",0);
	  int tabid=mdf.GetInt("tabid",0);
	  int taskid=mdf.GetInt("taskid",0);
	  int compflag=5;
	  bool col_object=false; // useOldBlock=true时，忽略col_object
	  //取压缩类型和数据块类型
	  {
		  AutoMt tmt(sp->GetDTS(),10);
		  tmt.FetchAll("select compflag from dt_taskschedule where taskid=%d",taskid);
		  if(tmt.Wait()>0)
			  compflag=tmt.GetInt("compflag",0);
		  tmt.FetchAll("select * from dt_table where tabid=%d",tabid);
		  if(tmt.Wait()>0) {
			  if(TestColumn(tmt,"blocktype")) 
				  col_object=tmt.GetInt("blocktype",0)&1; // bit 1 means column object block type.
		  }
	  }
	  
	  //从dt_datafilemap(存blockmt文件表)和dt_indexfilemap(存indexmt文件表)
	  //建立内存表结构
	  char fn[300];
	  AutoMt fnmt(sp->GetDTS(),MAX_DST_DATAFILENUM);
	  //	  fnmt.FetchAll("select * from dt_datafilemap where fileflag!=1 and rownum<1");
	  fnmt.FetchAll("select * from dt_datafilemap limit 2");
	  fnmt.Wait();
	  wociReset(fnmt);
	  AutoMt fnidxmt(sp->GetDTS(),MAX_DST_DATAFILENUM);
	  //	  fnidxmt.FetchAll("select * from dt_indexfilemap where rownum<1");
	  fnidxmt.FetchAll("select * from dt_indexfilemap limit 2");
	  fnidxmt.Wait();
	  wociReset(fnidxmt);
#ifdef __unix
	  long long dispct=0,lstdispct=0,llt=0;
#else
	  __int64 dispct=0,lstdispct=0,llt=0;
#endif
	  sp->OutTaskDesc("数据重组 :",taskid);
	  int start_mdfid=0,end_mdfid=0;
	  char sqlbf[200];
	  try {	
		  tmpfilenum=rn;
		  //索引数据文件遍历，累加索引总行数
		  int idxrn=0;
		  int i;
		  int mdrowlen=0;
		  //取索引记录的长度(临时索引数据记录)
		  {
			  dt_file df;
			  df.Open(mdf.PtrStr("indexfilename",0),0);
			  mdrowlen=df.GetRowLen();
		  }
		  lgprintf("临时索引数据记录长度:%d",mdrowlen);  
		  int lmtrn=-1,lmtfn=-1;
		  //检查临时索引的内存用量,判断当前的参数设置是否可以一次装入全部索引记录
		  for( i=0;i<rn;i++) {
			  dt_file df;
			  df.Open(mdf.PtrStr("indexfilename",i),0);
			  if(mdrowlen==0) 
				  mdrowlen=df.GetRowLen();
			  idxrn+=df.GetRowNum();
			  llt=idxrn;
			  llt*=mdrowlen;
			  llt/=(1024*1024); //-->(MB)
			  if(llt>LOADTIDXSIZE && lmtrn==-1) { //使用的临时索引超过内存允许参数的上限，需要拆分
				  if(i==0) 
					  ThrowWith("MLoader:内存参数DP_LOADTIDXSIZE设置太低:%dMB，\n"
					  "不足以装载至少一个临时抽取块:%dMB。\n",LOADTIDXSIZE,(int)llt);
				  lmtrn=idxrn-df.GetRowNum();
				  lmtfn=i;
			  }
		  }
		  if(lmtrn!=-1) { //使用的临时索引超过内存允许参数的上限，需要拆分
			  lgprintf("MLoader:数据整理超过内存限制%dMB,需要处理文件数%d,数据(子)集%d,起始点:%d,截至点:%d,文件数:%d .",LOADTIDXSIZE,rn,subdatasetid,mdf.GetInt("mdfid",0),mdf.GetInt("mdfid",lmtfn-1),lmtfn);
			  lgprintf("索引需要内存%dM ",idxrn*mdrowlen/(1024*1024));
			  idxrn=lmtrn;
			  //fix a bug
			  rn=lmtfn;
		  }
		  lgprintf("数据整理实际使用内存%dM,索引列宽%d.",idxrn*mdrowlen/(1024*1024),mdrowlen);
		  start_mdfid=mdf.GetInt("mdfid",0);
		  end_mdfid=mdf.GetInt("mdfid",rn-1);
		  lgprintf("索引记录数:%d",idxrn);
		  //为防止功能重入,中间文件状态修改.
		  lgprintf("修改中间文件的处理状态(subdatasetid:%d,%d个文件)：1-->2",subdatasetid,rn);
		  sprintf(sqlbf,"update dt.dt_middledatafile set procstate=2 where subdatasetid=%d  and datasetid=%d and indexid=%d and procstate<=1 and mdfid>=%d and mdfid<=%d and taskid=%d",
			  subdatasetid,datasetid,indexid,start_mdfid,end_mdfid,taskid);
		  int ern=sp->DoQuery(sqlbf);
		  if(ern!=rn) {
			  if(ern>0) {  //上面的UPdate语句修改了一部分记录状态,且不可恢复,需要对数据子集作重新装入.
				  ThrowWith("MLoader修改中间文件的处理状态异常，可能是与其它进程冲突。\n"
					  " 部分文件的处理状态不一致，请立即停止所有的数据整理任务，重新作数据整理操作。\n"
					  "   taskid:%d,tabid:%d,datasetid:%d,subdatasetid:%d,srctabid:%d,indexid:%d.\n",
					  taskid,tabid,datasetid,subdatasetid,srctabid,indexid);
			  }
			  else //上面的update语句未产生实际修改操作,其它进程可以继续处理.
				  ThrowWith("MLoader修改中间文件的处理状态异常，可能是与其它进程冲突。\n"
				  "   taskid:%d,tabid:%d,datasetid:%d,subdatasetid:%d,srctabid:%d,indexid:%d.\n",
				  taskid,tabid,datasetid,subdatasetid,srctabid,indexid);
		  }
		  
		  	//ThrowWith("调试终止---%d组数据.",dispct);
	if(firstbatch) {
		lgprintf("删除分区编号为%d的数据和索引记录(数据集%d,索引%d)...",subdatasetid,datasetid,indexid);
		AutoMt dfnmt(sp->GetDTS(),MAX_DST_DATAFILENUM);
		dfnmt.FetchAll("select * from dt_datafilemap where subdatasetid=%d and datasetid=%d and indexid=%d and fileflag=1",subdatasetid,datasetid,indexid);
		int dfn=dfnmt.Wait();
		if(dfn>0) {
			AutoStmt st(sp->GetDTS());
			for(int di=0;di<dfn;di++)
			{
				lgprintf("删除'%s'和附加的depcp,dep5文件",dfnmt.PtrStr("filename",di));
				unlink(dfnmt.PtrStr("filename",di));
				char tmp[300];
				sprintf(tmp,"%s.depcp",dfnmt.PtrStr("filename",di));
				unlink(tmp);
				sprintf(tmp,"%s.dep5",dfnmt.PtrStr("filename",di));
				unlink(tmp);
			}
			st.Prepare(" delete from dt_datafilemap where subdatasetid=%d and datasetid=%d and indexid=%d and fileflag=1",subdatasetid,datasetid,indexid);
			st.Execute(1);
			st.Wait();
		}
		
		dfnmt.FetchAll("select * from dt_indexfilemap where subdatasetid=%d and datasetid=%d and indexid=%d and fileflag=1",subdatasetid,datasetid,indexid);
		dfn=dfnmt.Wait();
		if(dfn>0) {
			AutoStmt st(sp->GetDTS());
			for(int di=0;di<dfn;di++)
			{
				lgprintf("删除'%s'和附加的depcp,dep5文件",dfnmt.PtrStr("filename",di));
				unlink(dfnmt.PtrStr("filename",di));
				char tmp[300];
				sprintf(tmp,"%s.depcp",dfnmt.PtrStr("filename",di));
				unlink(tmp);
				sprintf(tmp,"%s.dep5",dfnmt.PtrStr("filename",di));
				unlink(tmp);
			}
			st.Prepare(" delete from dt_indexfilemap where subdatasetid=%d and datasetid=%d and indexid=%d and fileflag=1",subdatasetid,datasetid,indexid);
			st.Execute(1);
			st.Wait();
		}
	}

		  //建立中间索引(中间文件数据块索引)内存表mdindexmt和目标数据块内存表blockmt
		  int maxblockrn=sp->GetMaxBlockRnFromSrcTab(srctabid);
		  {
			  dt_file idf;
			  idf.Open(mdf.PtrStr("indexfilename",0),0);
			  mdindexmt.SetHandle(idf.CreateMt(idxrn));
			  //wociAddColumn(idxmt,"dtfileid",NULL,COLUMN_TYPE_INT,4,0);
			  //idxmt.SetMaxRows(idxrn);
			  mdindexmt.Build();
			  idf.Open(mdf.PtrStr("datafilename",0),0);
			  blockmt.SetHandle(idf.CreateMt(maxblockrn));
			  //mdblockmt.SetHandle(idf.CreateMt(maxblockrn));
		  }
		  int crn=0;
		  //	wociGetIntAddrByName(idxmt,"dtfileid",0,&pdtfid);
		  // pdtfid为一个字符数组，偏移为x的值表示中间索引内存表第x行的文件序号(Base0);
		  if(pdtfid)
			  delete [] pdtfid;
		  pdtfid=new unsigned short [idxrn];
		  dtfidlen=idxrn;
		  //pdtf为file_mt对象的数组。存放数据文件对象。
		  if(pdtf) delete [] pdtf;
		  pdtf=new file_mt[rn];
		  //mdindexmt.SetMaxRows(idxrn);
		  //读入全部索引数据到mdindexmt(中间索引内存表),并打开全部数据文件
		  //pdtfid指向对应的文件序号。
		  lgprintf("读索引数据...");
		  for(i=0;i<rn;i++) {
			  dt_file df;
			  df.Open(mdf.PtrStr("indexfilename",i),0);
			  int brn=0;
			  int sbrn=0;
			  while( (sbrn=df.ReadMt(-1,0,mdindexmt,false))>0) brn+=sbrn;
			  
			  for(int j=crn;j<crn+brn;j++)
				  pdtfid[j]=(unsigned short )i;
			  crn+=brn;
			  
			  //pdtf[i].SetParalMode(true);
			  pdtf[i].Open(mdf.PtrStr("datafilename",i),0);
			  //		if(crn>10000000) break; ///DEBUG
		  }
		  lgprintf("索引数据:%d.",crn);
		  //对mdindexmt(中间索引内存表)做排序。
		  //由于排序不涉及内存表的数据排列，而是新建记录顺序表，因此，
		  // pdtfid作为内存表外的等效内存表字段，不需做处理。
		  lgprintf("排序('%s')...",mdf.PtrStr("soledindexcols",0));
		  {
			  char sort[300];
			  sprintf(sort,"%s,idx_fid,idx_blockoffset",mdf.PtrStr("soledindexcols",0));
			  wociSetSortColumn(mdindexmt,sort);
			  wociSortHeap(mdindexmt);
		  }
		  lgprintf("排序完成.");
		  //取得全部独立索引结构
		  sp->GetSoledIndexParam(srctabid,&dp,tabid);
		  //dp.tabid=tabid;
		  //检查需要处理的中间数据是否使用主独立索引，如果是，isfirstidx=1.
		  int isfirstidx=0;
		  indexparam *ip;
		  {
			  int idxp=dp.GetOffset(indexid);
			  ip=&dp.idxp[idxp];
			  if(idxp==dp.psoledindex) isfirstidx=1;
		  }
		  //从结构描述文件建立indexmt,indexmt是目标索引内存表。是建立目标索引表的数据源。
		  //indexmt.SetHandle(CreateMtFromFile(MAXINDEXRN,ip->cdsfilename));
		  int pblockc[20];
		  char colsname[500];
		  void *indexptr[40];
		  indexmt.SetMaxRows(1);
		  int stcn=sp->CreateIndexMT(indexmt,blockmt,indexid,pblockc,colsname,true),bcn=stcn;
		  llt=FIX_MAXINDEXRN;
		  llt*=1024*1024; //==> to bytes;
		  llt/=wociGetRowLen(indexmt); //==> to rownum;
		  idxdlimit=(int)llt;
		  //idxdlimit=DEFAULT_IDX_BLOCK_ROWNUM;
		  //lgprintf("目标索引字段长度%d,每个目标文件最大允许记录数:%d.",wociGetRowLen(indexmt),idxdlimit);
		  indexmt.SetMaxRows(idxdlimit);
		  sp->CreateIndexMT(indexmt,blockmt,indexid,pblockc,colsname,true);
		  //int pblockc1[20];
		  bool pkmode=false;
		  //int bcn1=wociConvertColStrToInt(blockmt,ip->idxcolsname,pblockc1);
		  
		  //取独立索引和复用索引在blockmt(目标数据块内存表)结构中的位置，
		  // 检查结构描述文件建立的索引是否和系统参数表中指定的字段数相同。
		  /*
		  int pblockc1[20];
		  int pblockc2[20];
		  bool pkmode=false;
		  int bcn1=wociConvertColStrToInt(blockmt,ip->idxcolsname,pblockc1);
		  if(bcn1==1 && wociGetColumnType(blockmt,pblockc1[0])==COLUMN_TYPE_INT)
		  pkmode=true;
		  int bcn2=wociConvertColStrToInt(blockmt,ip->idxreusecols,pblockc2);
		  if(wociGetColumnNumber(indexmt)!=bcn1+bcn2+6) {
		  ThrowWith("Column number error,subdatasetid:%d,colnum:%d,deserved:%d",
		  subdatasetid,wociGetColumnNumber(indexmt),bcn1+bcn2+6);
		  }
		  //设置dt_index中的idxfieldnum
		  sprintf(sqlbf,"update dt.dt_index set idxfieldnum=%d where indexid=%d or reuseindexid=%d",
		  bcn1+bcn2,indexid,indexid);
		  lgprintf("设置dt_index中的索引字段数(idxfieldnum).");
		  conn.DoQuery(sqlbf);
		  */
		  //取独立索引在mdindexmt(中间索引存表)结构中的位置。
		  //设置对indexmt插入记录需要的结构和变量。
		  int pidxc1[20];
		  int cn1=wociConvertColStrToInt(mdindexmt,ip->idxcolsname,pidxc1);
		  int dtfid,blockstart,blocksize,blockrn=0,startrow,rownum;
		  //int stcn=bcn1+bcn2;
		  indexptr[stcn++]=&dtfid;
		  indexptr[stcn++]=&blockstart;
		  indexptr[stcn++]=&blocksize;
		  indexptr[stcn++]=&blockrn;
		  indexptr[stcn++]=&startrow;
		  indexptr[stcn++]=&rownum;
		  indexptr[stcn]=NULL;
		  //indexmt中的blocksize,blockstart?,blockrownum需要滞后写入，
		  //因而需要取出这些字段的首地址。
		  int *pblocksize;
		  int *pblockstart;
		  int *pblockrn;
		  wociGetIntAddrByName(indexmt,"blocksize",0,&pblocksize);
		  wociGetIntAddrByName(indexmt,"blockstart",0,&pblockstart);
		  wociGetIntAddrByName(indexmt,"blockrownum",0,&pblockrn);
		  //mdindexmt中下列字段是读中间数据文件的关键项。
		  int *poffset,*pstartrow,*prownum;
		  wociGetIntAddrByName(mdindexmt,"idx_blockoffset",0,&poffset);
		  wociGetIntAddrByName(mdindexmt,"idx_startrow",0,&pstartrow);
		  wociGetIntAddrByName(mdindexmt,"idx_rownum",0,&prownum);
		  
		  //indexmt 记录行数计数复位
		  int indexmtrn=0;
		  
		  //建立目标数据文件和目标索引文件对象(dt_file).
		  // 目标数据文件和目标索引文件一一对应，目标数据文件中按子块方式存储内存表
		  //  目标索引文件中为一个单一的内存表，文件头结构在写入内存表时建立
		  dtfid=sp->NextFileID();
		  dp.usingpathid=0;
		  sprintf(fn,"%s%d_%d_%d_%d_%d.dat",dp.dstpath[0],srctabid,datasetid,indexid,subdatasetid,dtfid);
		  dt_file dstfile;
		  dstfile.Open(fn,1);
		  blockstart=dstfile.WriteHeader(blockmt,0,dtfid);
		  char idxfn[300];
		  sprintf(idxfn,"%s%d_%d_%d_%d_%d.idx",dp.dstpath[0],srctabid,datasetid,indexid,subdatasetid,dtfid);
		  dt_file idxf;
		  idxf.Open(idxfn,1);
		  idxf.WriteHeader(indexmt,0,dtfid);
		  
		  startrow=0;
		  rownum=0;
		  blockrn=0;
		  int subtotrn=0;
		  int idxtotrn=0;
		  lgprintf("开始数据处理(MiddleDataLoading)....");
		  
		  /*******按照Sort顺序遍历mdindexmt(中间索引内存表)***********/
		  //
		  //
		  lgprintf("创建文件,编号:%d...",dtfid);
		  int firstrn=wociGetRawrnBySort(mdindexmt,0);
		  mytimer arrtm;
		  arrtm.Start();
		  for(i=0;i<idxrn;i++) {
			  int thisrn=wociGetRawrnBySort(mdindexmt,i);
			  int rfid=pdtfid[thisrn];
			  int sbrn=prownum[thisrn];
			  int sbstart=pstartrow[thisrn];
			  int sameval=mdindexmt.CompareRows(firstrn,thisrn,pidxc1,cn1);
			  
			  if(sameval!=0) {
				  //要处理的数据块和上次的数据块不是一个关键字，
				  // 所以，先保存上次的关键字索引，关键字的值从blockmt中提取。
				  // startrow变量始终保存第一个未存储关键字索引的数据块开始行号。
				  int c;
				  for(c=0;c<bcn;c++) {
					  indexptr[c]=blockmt.PtrVoid(pblockc[c],startrow);
				  }
				  //			for(c=0;c<bcn2;c++) {
				  //				indexptr[bcn1+c]=blockmt.PtrVoid(pblockc2[c],startrow);
				  //			}
				  if(rownum>0) {
					  wociInsertRows(indexmt,indexptr,NULL,1);
					  idxtotrn++;
				  }
				  firstrn=thisrn;
				  //这里，出现startrow暂时指向无效行的情况(数据未填充).
				  startrow=blockrn;
				  rownum=0;
			  }
			  //从数据文件中读入数据块
			  int mt=pdtf[rfid].ReadBlock(poffset[thisrn],0,true);
			  //2005/08/24 修改： 索引数据文件为多块数据顺序存储
			  
			  //由于结束当前文件有可能还要增加一条索引,因此判断内存表满的条件为(idxdlimit-1)
			  int irn=wociGetMemtableRows(indexmt);
			  if(irn>=(idxdlimit-2))
			  {
				  int pos=irn-1;
				  //如果blocksize，blockrn等字段还未设置，则不清除
				  while(pos>=0 && pblockstart[pos]==blockstart) pos--;
				  if(pos>0) {
					  //保存已经设置完整的索引数据,false参数表示不需要删除位图区.
					  idxf.WriteMt(indexmt,COMPRESSLEVEL,pos+1,false);
					  if(pos+1<irn) 
						  wociCopyRowsTo(indexmt,indexmt,0,pos+1,irn-pos-1);
					  else wociReset(indexmt);
				  }
				  else 
				  /*				  int irn=irn1-1;
				  //如果blocksize，blockrn等字段还为设置，则不清除
				  while(irn>=0 && pblockstart[irn]==blockstart ) {irn--;}
				  if(irn>0) {
				  int idxfsize=idxf.WriteMt(indexmt,COMPRESSLEVEL,irn+1);
				  if(irn<irn1) 
				  wociCopyRowsTo(indexmt,indexmt,0,irn,irn1-irn-1);
				  else wociReset(indexmt);
				  }
				  else 
				  */
				  ThrowWith("目标表%d,索引号%d,装入时索引超过最大单一块允许记录数%d",tabid,indexid,idxdlimit);
			  }
			  //数据块拆分 
			  //检查数据块是否需要拆分
			  // 增加一个循环，用于处理mt中的sbrn本省大于maxblockrn的异常情况：
			  //	由于异常原因导致临时导出块大于最终数据块，在索引聚合良好时，会出现不能一次容纳所有临时记录
			  while(true) {
				  if(blockrn+sbrn>maxblockrn ) {
					  //每个数据块至少需要达到最大值的80%。
					  if(blockrn<maxblockrn*.8 ) {
						  //如果不足80%，把当前处理的数据块拆分
						  int rmrn=maxblockrn-blockrn;
						  wociCopyRowsTo(mt,blockmt,-1,sbstart,rmrn);
						  rownum+=rmrn;
						  sbrn-=rmrn;
						  sbstart+=rmrn;
						  blockrn+=rmrn;
					  }
					  
					  //保存块数据
					  if(useOldBlock) 
						  blocksize=dstfile.WriteMt(blockmt,compflag,0,false)-blockstart;
					  else if(col_object)
						  blocksize=dstfile.WriteMySQLMt(blockmt,compflag)-blockstart;
					  else 
						  blocksize=dstfile.WriteMySQLMt(blockmt,compflag,false)-blockstart;
					  //保存子快索引
					  if(startrow<blockrn) {
						  int c;
						  for(c=0;c<bcn;c++) {
							  indexptr[c]=blockmt.PtrVoid(pblockc[c],startrow);
						  }
						  if(rownum>0) {
							  wociInsertRows(indexmt,indexptr,NULL,1);
							  dispct++;
							  idxtotrn++;
						  }
					  }
					  int irn=wociGetMemtableRows(indexmt);
					  int irn1=irn;
					  while(--irn>=0) {
						  if(pblockstart[irn]==blockstart) {
							  pblocksize[irn]=blocksize;
							  pblockrn[irn]=blockrn;
						  }
						  else break;
					  }
					  
					  blockstart+=blocksize;
					  subtotrn+=blockrn;
					  //数据文件长度超过2G时拆分
					  if(blockstart>2000000000 ) {
						  //增加文件对照表记录(dt_datafilemap)
						  {
							  void *fnmtptr[20];
							  fnmtptr[0]=&dtfid;
							  fnmtptr[1]=fn;
							  fnmtptr[2]=&subdatasetid;
							  fnmtptr[3]=&dp.dstpathid[dp.usingpathid];
							  fnmtptr[4]=&dp.tabid;
							  fnmtptr[5]=&ip->idxid;
							  fnmtptr[6]=&isfirstidx;
							  fnmtptr[7]=&blockstart;
							  fnmtptr[8]=&subtotrn;
							  fnmtptr[9]=&datasetid;
							  int procstatus=0;
							  fnmtptr[10]=&procstatus;
							  //int compflag=COMPRESSLEVEL;
							  fnmtptr[11]=&compflag;
							  int fileflag=1;
							  fnmtptr[12]=&fileflag;
							  fnmtptr[13]=NULL;
							  wociInsertRows(fnmt,fnmtptr,NULL,1);
						  }
						  //
						  //增加索引数据对照表记录(dt_indexfilemap)
						  {
							  //int irn1=wociGetMemtableRows(indexmt);
							  //idxf.WriteHeader(indexmt,dtfid);
							  //false表示不需要删除标记位图区
							  int idxfsize=idxf.WriteMt(indexmt,COMPRESSLEVEL,0,false);
							  void *fnmtptr[20];
							  fnmtptr[0]=&dtfid;
							  fnmtptr[1]=idxfn;
							  fnmtptr[2]=&subdatasetid;
							  fnmtptr[3]=&dp.dstpathid[dp.usingpathid];
							  fnmtptr[4]=&dp.tabid;
							  fnmtptr[5]=&ip->idxid;
							  fnmtptr[6]=&isfirstidx;
							  fnmtptr[7]=&idxfsize;
							  fnmtptr[8]=&idxtotrn;
							  fnmtptr[9]=&datasetid;
							  //int compflag=COMPRESSLEVEL;
							  fnmtptr[10]=&compflag;
							  int fileflag=1;
							  fnmtptr[11]=&fileflag;
							  fnmtptr[12]=NULL;
							  wociInsertRows(fnidxmt,fnmtptr,NULL,1);
						  }
						  //
						  dtfid=sp->NextFileID();
						  sprintf(fn,"%s%d_%d_%d_%d_%d.dat",dp.dstpath[0],srctabid,datasetid,indexid,subdatasetid,dtfid);
						  
						  dstfile.SetFileHeader(subtotrn,fn);
						  dstfile.Open(fn,1);
						  blockstart=dstfile.WriteHeader(blockmt,0,dtfid);
						  printf("\r                                                                            \r");
						  lgprintf("创建文件,编号:%d...",dtfid);
						  sprintf(idxfn,"%s%d_%d_%d_%d_%d.idx",dp.dstpath[0],srctabid,datasetid,indexid,subdatasetid,dtfid);
						  
						  idxf.SetFileHeader(idxtotrn,idxfn);
						  // create another file
						  idxf.Open(idxfn,1);
						  idxf.WriteHeader(indexmt,0,dtfid);
						  indexmt.Reset();
						  subtotrn=0;
						  blockrn=0;
						  idxtotrn=0;
						  //lgprintf("创建文件,编号:%d...",dtfid);
						  
					  } // end of IF blockstart>2000000000)
					  blockmt.Reset();
					  blockrn=0;
					  firstrn=thisrn;
					  startrow=blockrn;
					  rownum=0;
					  dispct++;
					  if(dispct-lstdispct>=200) {
						  lstdispct=dispct;
						  arrtm.Stop();
						  double tm1=arrtm.GetTime();
						  arrtm.Start();
						  printf("  已生成%lld数据块,用时%.0f秒,预计还需要%.0f秒          .\r",dispct,tm1,(tm1*(idxrn-i))/i);
						  fflush(stdout);
					  }
			} //end of blockrn+sbrn>maxblockrn
			if(blockrn+sbrn>maxblockrn) {
				int rmrn=maxblockrn-blockrn;
				wociCopyRowsTo(mt,blockmt,-1,sbstart,rmrn);
				rownum+=rmrn;
				sbrn-=rmrn;
				sbstart+=rmrn;
				blockrn+=rmrn;
			}
			else {
				wociCopyRowsTo(mt,blockmt,-1,sbstart,sbrn);
				rownum+=sbrn;
				blockrn+=sbrn;
				break;
			}
		} // end of while(true)
	} // end of for(...)
	
	if(blockrn>0) {
		
		//保存子快索引
		int c;
		for( c=0;c<bcn;c++) {
			indexptr[c]=blockmt.PtrVoid(pblockc[c],startrow);
		}
		//for(c=0;c<bcn2;c++) {
		//	indexptr[bcn1+c]=blockmt.PtrVoid(pblockc2[c],startrow);
		//}
		if(rownum>0) {
			wociInsertRows(indexmt,indexptr,NULL,1);
			dispct++;
		}
		//保存块数据
		//保存块数据
		if(useOldBlock)
			blocksize=dstfile.WriteMt(blockmt,compflag,0,false)-blockstart;
		else if(col_object)
			blocksize=dstfile.WriteMySQLMt(blockmt,compflag)-blockstart;
		else 
			blocksize=dstfile.WriteMySQLMt(blockmt,compflag,false)-blockstart;
		int irn=wociGetMemtableRows(indexmt);
		while(--irn>=0) {
			if(pblockstart[irn]==blockstart) {
				pblocksize[irn]=blocksize;
				pblockrn[irn]=blockrn;
			}
			else break;
		}
		blockstart+=blocksize;
		subtotrn+=blockrn;
		//增加文件对照表记录(dt_datafilemap)
		{
			void *fnmtptr[20];
			fnmtptr[0]=&dtfid;
			fnmtptr[1]=fn;
			fnmtptr[2]=&subdatasetid;
			fnmtptr[3]=&dp.dstpathid[dp.usingpathid];
			fnmtptr[4]=&dp.tabid;
			fnmtptr[5]=&ip->idxid;
			fnmtptr[6]=&isfirstidx;
			fnmtptr[7]=&blockstart;
			fnmtptr[8]=&subtotrn;
			fnmtptr[9]=&datasetid;
			int procstatus=0;
			fnmtptr[10]=&procstatus;
			//int compflag=COMPRESSLEVEL;
			fnmtptr[11]=&compflag;
			int fileflag=1;
			fnmtptr[12]=&fileflag;
			fnmtptr[13]=NULL;
			
			wociInsertRows(fnmt,fnmtptr,NULL,1);
		}
		//增加索引数据对照表记录(dt_indexfilemap)
		{
			//int irn1=wociGetMemtableRows(indexmt);
			//idxf.WriteHeader(indexmt,dtfid);
			//false参数表示不需要删除标记位图区
			int idxfsize=idxf.WriteMt(indexmt,COMPRESSLEVEL,0,false);
			void *fnmtptr[20];
			fnmtptr[0]=&dtfid;
			fnmtptr[1]=idxfn;
			fnmtptr[2]=&subdatasetid;
			fnmtptr[3]=&dp.dstpathid[dp.usingpathid];
			fnmtptr[4]=&dp.tabid;
			fnmtptr[5]=&ip->idxid;
			fnmtptr[6]=&isfirstidx;
			fnmtptr[7]=&idxfsize;
			fnmtptr[8]=&idxtotrn;
			fnmtptr[9]=&datasetid;
			//int compflag=COMPRESSLEVEL;
			fnmtptr[10]=&compflag;
			int fileflag=1;
			fnmtptr[11]=&fileflag;
			fnmtptr[12]=NULL;
			wociInsertRows(fnidxmt,fnmtptr,NULL,1);
		}
		//
		
		//
		dstfile.SetFileHeader(subtotrn,NULL);
		idxf.SetFileHeader(idxtotrn,NULL);
		indexmt.Reset();
		blockmt.Reset();
		blockrn=0;
		startrow=blockrn;
		rownum=0;
	}
	
	wociAppendToDbTable(fnmt,"dt_datafilemap",sp->GetDTS(),true);
	wociAppendToDbTable(fnidxmt,"dt_indexfilemap",sp->GetDTS(),true);
	lgprintf("修改中间文件的处理状态(数据集%d,索引%d,分区号:%d,%d个文件)：2-->3",datasetid,indexid,subdatasetid,rn);
	sprintf(sqlbf,"update dt.dt_middledatafile set procstate=3 where subdatasetid=%d and datasetid=%d and indexid=%d and procstate=%d",subdatasetid,datasetid,indexid,2);
	sp->DoQuery(sqlbf);
	}
	catch (...) {
		int frn=wociGetMemtableRows(fnmt);
		int fidxrn=wociGetMemtableRows(fnidxmt);
		errprintf("数据整理出现异常，分区:%d,taskid:%d.",subdatasetid ,taskid);
		errprintf("恢复中间文件的处理状态(分区:%d,%d个文件)：2-->1",subdatasetid,rn);
		sprintf(sqlbf,"update dt.dt_middledatafile set procstate=1 where subdatasetid=%d and datasetid=%d and indexid=%d and mdfid>=%d and mdfid<=%d",subdatasetid,datasetid,indexid,start_mdfid,end_mdfid);
		sp->DoQuery(sqlbf);
		errprintf("删除已整理的数据和索引文件.");
		int i;
		errprintf("删除数据文件...");
		for(i=0;i<frn;i++) {
			errprintf("\t %s ",fnmt.PtrStr("filename",i));
		}
		for(i=0;i<frn;i++) {
			unlink(fnmt.PtrStr("filename",i));
		}
		errprintf("删除索引文件...");
		for(i=0;i<fidxrn;i++) {
			errprintf("\t %s ",fnidxmt.PtrStr("filename",i));
		}
		for(i=0;i<fidxrn;i++) {
			unlink(fnidxmt.PtrStr("filename",i));
		}
		errprintf("删除已处理数据文件和索引文件记录...");
		AutoStmt st(sp->GetDTS());
		for(i=0;i<frn;i++) {
			st.Prepare("delete from dt_datafilemap where subdatasetid=%d and datasetid=%d and indexid=%d and fileflag=1 and fileid=%d",subdatasetid,datasetid,indexid,fnmt.PtrInt("fileid",i));
			st.Execute(1);
			st.Wait();
		}
		for(i=0;i<fidxrn;i++) {
			st.Prepare("delete from dt_indexfilemap where subdatasetid=%d and datasetid=%d and indexid=%d and fileflag=1 and fileid=%d",subdatasetid,datasetid,indexid,fnidxmt.PtrInt("fileid",i));
			st.Execute(1);
			st.Wait();
		}
		wociCommit(sp->GetDTS());
		
		//		st.Prepare("delete from dt_datafilemap where subdatasetid=%d and fileflag=1",subdatasetid);
		//		st.Execute(1);
		//		st.Wait();
		//		st.Prepare("delete from dt_indexfilemap where subdatasetid=%d and fileflag=1",subdatasetid);
		//		st.Execute(1);
		//		st.Wait();
		throw ;
	}
	
	lgprintf("数据处理(MiddleDataLoading)结束,共处理数据包%d个.",dispct);
	lgprintf("生成%d个数据文件,已插入dt_datafilemap表.",wociGetMemtableRows(fnmt));
	//wociMTPrint(fnmt,0,NULL);
	lgprintf("生成%d个索引文件,已插入dt_indexfilemap表.",wociGetMemtableRows(fnidxmt));
	//wociMTPrint(fnidxmt,0,NULL);
	//检查是否最后一批数据
	try
	{
		//mdf.FetchAll("select * from dt_taskschedule where taskid=%d and taskstatus>=2",
		//	taskid);
		//int rn=mdf.Wait();
		//if(rn>=1) {
		//针对多分区处理的任务，检查其他分区的数据（其他数据子集）是否整理完毕。
		//  如果是单分区处理任务，则以下查询总是返回空记录集。
		mdf.FetchAll("select * from dt_middledatafile where procstate!=3 and taskid=%d",
			taskid);
		int rn=mdf.Wait();
		if(rn==0) {
			lgprintf("最后一批数据已处理完,任务状态2-->3,taskid:%d",taskid);
			//如果是单分区处理任务，必须是所有相同数据集的任务状态为3，才能启动下一步的操作（数据装入）。
			sprintf(sqlbf,"update dt.dt_taskschedule set taskstatus=3 where taskid=%d",
				taskid);
			sp->DoQuery(sqlbf);
			//重新创建表结构。
			//sp->CreateDT(tabid);
			//}
			lgprintf("删除中间临时文件...");
			mdf.FetchAll("select * from dt_middledatafile where subdatasetid=%d and datasetid=%d and indexid=%d and taskid=%d and procstate=3",subdatasetid,datasetid,indexid,taskid);
			{
				int dfn=mdf.Wait();
				for(int di=0;di<dfn;di++) {
					lgprintf("删除文件'%s'",mdf.PtrStr("datafilename",di));
					unlink(mdf.PtrStr("datafilename",di));
					lgprintf("删除文件'%s'",mdf.PtrStr("indexfilename",di));
					unlink(mdf.PtrStr("indexfilename",di));
				} 
				lgprintf("删除记录...");
				AutoStmt st(sp->GetDTS());
				st.Prepare("delete from dt_middledatafile where subdatasetid=%d and datasetid=%d and indexid=%d and taskid=%d and procstate=3",subdatasetid,datasetid,indexid,taskid);
				st.Execute(1);
				st.Wait();
			}
		}
		
	}
	catch(...) {
		errprintf("数据整理任务已完成，但任务状态调整或临时中间文件删除时出现错误，需要人工调整。\n任务:%d,分区:%d。",
			taskid,subdatasetid);
		throw;
	}
	return 1;
	//Load index data into memory table (indexmt)
  }
  
  //索引数据表清空,但保留表结构和索引结构
  bool SysAdmin::EmptyIndex(int tabid)
  {
	  AutoMt indexmt(dts,MAX_DST_INDEX_NUM);
	  indexmt.FetchAll("select databasename from dt_table where tabid=%d",tabid);
	  int rn=indexmt.Wait();
	  char dbn[150];
	  strcpy(dbn,indexmt.PtrStr("databasename",0));
	  if(rn<1) ThrowWith("清空索引表时找不到%d目标表.",tabid);
	  indexmt.FetchAll("select * from dt_index where tabid=%d and issoledindex=1",tabid);
	  rn=indexmt.Wait();
	  if(rn<1) ThrowWith("清空索引表时找不到独立索引记录(%d目标表).",tabid);
	  char sqlbf[300];
	  for(int i=0;i<rn;i++) {
		  lgprintf("清空索引表%s.%s...",dbn,indexmt.PtrStr("indextabname",i));
		  sprintf(sqlbf,"truncate table %s.%s",dbn,indexmt.PtrStr("indextabname",i));
		  DoQuery(sqlbf);
	  }
	  return true;
  }
  
  
  int SysAdmin::BuildMtFromSrcTable(int srcsys,int srctabid,AutoMt *mt) {
	  int srctabp=wociSearchIK(dt_srctable,srctabid);
	  const char *srctbn=dt_srctable.PtrStr("srctabname",srctabp);
	  AutoStmt srcst(srcsys);
	  if(TestColumn(dt_srctable,"fmttable")) {
		  const char *tmp=dt_srctable.PtrStr("fmttable",srctabp);
		  if(strlen(tmp)>1) srctbn=tmp;
	  }
	  srcst.Prepare("select * from %s.%s",dt_srctable.PtrStr("srcschedulename",srctabp),
		  srctbn);
	  wociBuildStmt(*mt,srcst,mt->GetMaxRows());
	  return 0;
  }
  
  int SysAdmin::GetSrcTableStructMt(int srctabp, int tabp, int srcsys)
  {
	  AutoStmt srcst(srcsys);
	  const char *srctbn=dt_srctable.PtrStr("srctabname",srctabp);
	  if(TestColumn(dt_srctable,"fmttable")) {
		  const char *tmp=dt_srctable.PtrStr("fmttable",srctabp);
		  if(strlen(tmp)>1) srctbn=tmp;
	  }
	  srcst.Prepare("select * from %s.%s",dt_srctable.PtrStr("srcschedulename",srctabp),
		  srctbn);
	  int mt=wociCreateMemTable();
	  wociBuildStmt(mt,srcst,10);
	  return mt;
  }
  
  //如果去掉字段描述文件的支持,则下面的函数会大大简化
  bool SysAdmin::CreateTableOnMysql(int srcmt,const char *tabname,bool forcecreate)
  {
	  //如果目标表已存在，先删除
	    	char sqlbf[3000];
			bool exist=conn.TouchTable(tabname);
			if(exist && !forcecreate) 
				ThrowWith("Create MySQL Table '%s' failed,table already exists.",tabname);
			if(exist) {
				printf("table %s has exist,dropped.\n",tabname);
				sprintf(sqlbf,"drop table %s",tabname);
				conn.DoQuery(sqlbf);
			}
			//建立目标标及其表结构的描述文件
			wociGetCreateTableSQL(srcmt,sqlbf,tabname,true);
			//strcat(sqlbf," PACK_KEYS = 1");
			//printf("%s.\n",sqlbf);
			conn.DoQuery(sqlbf);
			mSleep(300);			
			return true;
  }
  
  void SysAdmin::CloseTable(int tabid,char *tbname,bool cleandt) {
	  char tabname[150];
	  lgprintf("清空%d表...",tabid);
	  AutoStmt st(dts);
	  if(cleandt)
		  st.Prepare("update dt_table set recordnum=0,firstdatafileid=0,datasetid=0,totalbytes=0 where tabid=%d",tabid);
	  else
		  st.Prepare("update dt_table set recordnum=0 where tabid=%d",tabid);
	  st.Execute(1);
	  st.Wait();
	  wociCommit(dts);
	  if(tbname==NULL) {
		  GetTableName(tabid,-1,tabname,NULL,TBNAME_DEST);
	  }
	  else strcpy(tabname,tbname);
	  {
		  lgprintf("删除DP参数文件.");
		  char basedir[300];
		  char streamPath[300];
		  char tbntmp[200];
		  AutoMt mt(dts,100);
		  mt.FetchAll("select * from dt_path where pathtype='msys'");
		  if(mt.Wait()!=1) ThrowWith("查找基本目录失败，请检查dt_path表和同义词定义.");
		  strcpy(basedir,mt.PtrStr("pathval",0));
		  strcpy(tbntmp,tabname);
		  char *psep=strstr(tbntmp,".");
		  if(psep==NULL) 
			  ThrowWith("Invalid table name format'%s',should be dbname.tbname.",tbname);
		  *psep='/';
		  sprintf(streamPath,"%s%s.DTP",basedir,tbntmp);
		  unlink(streamPath);
	  }
    	 conn.FlushTables(tabname);
		 lgprintf("表'%s'已清空...",tabname);
  }	
  
  //建立表并更新复用字段值(dt_index.reusecols)
  //数据上线有以下几种情况
  //1. 有完整的两组数据文件,需要备份原有的表和数据记录.
  //2. 上线前表中无数据,不需要备份原有的表和数据记录.
  //3. 上线前后使用同一组数据文件,但要使用新的表和索引结构替换原数据,这时也不需要备份原有的表和数据记录.
  
  void SysAdmin::DataOnLine(int tabid) {
	  char tbname[150],idxname[150];
	  char tbname_p[150],idxname_p[150];
	  bool ec=wociIsEcho();
	  wociSetEcho(FALSE);
	  lgprintf("%d表上线...",tabid);
	  AutoMt mt(dts,100);
	  mt.FetchAll("select sum(recordnum) rn,sum(filesize) tsize,count(*) fnum from dt_datafilemap where tabid=%d and fileflag=1 and isfirstindex=1",tabid);
	  mt.Wait();
	  int sumrn=mt.GetInt("rn",0);
	  double tsize=mt.GetDouble("tsize",0);
	  int fnum=mt.GetInt("fnum",0);
	  mt.FetchAll("select sum(recordnum) rn,sum(filesize) tsize,count(*) fnum from dt_datafilemap where tabid=%d and (fileflag=0 or fileflag is null) and isfirstindex=1",tabid);
	  mt.Wait();
	  bool needbackup=mt.GetInt("rn",0)>0;
	  bool sharemode=false;
	  if(sumrn==0 && !needbackup) 
		  ThrowWith("上线的数据为空，上线失败(tabid:%d)。",tabid);
	  if(sumrn==0) {
		  needbackup=false; //不需要备份
		  sharemode=true;
		  sumrn=mt.GetInt("rn",0);
		  tsize=mt.GetDouble("tsize",0);
		  fnum=mt.GetInt("fnum",0);
	  }
	  mt.FetchAll("select * from dt_index where tabid=%d and issoledindex=1",tabid);
	  int rn=mt.Wait();
	  if(rn<1)
		  ThrowWith("找不到对应于%d表的任何索引。",tabid);
	  //后续操作涉及dt_table,dt_datafilemap等核心参数表的修改，需要关闭表。
	  AutoStmt st(dts);
	  try {
	  CloseTable(tabid,NULL,false);
	  if(needbackup) {
		  st.Prepare("update dt_datafilemap set fileflag=2 where tabid=%d and fileflag=0",tabid);
		  st.Execute(1);
		  st.Wait();
		  st.Prepare("update dt_indexfilemap set fileflag=2 where tabid=%d and fileflag=0",tabid);
		  st.Execute(1);
		  st.Wait();
	  }
	  if(!sharemode) {
		  st.Prepare("update dt_datafilemap set fileflag=0 where tabid=%d and fileflag=1",tabid);
		  st.Execute(1);
		  st.Wait();
		  st.Prepare("update dt_indexfilemap set fileflag=0 where tabid=%d and fileflag=1",tabid);
		  st.Execute(1);
		  st.Wait();
	  }
	  
	  //if(!needbackup) DropDTTable(tabid,TBNAME_DEST);
	  for(int i=0;i<rn;i++) {
		  int indexid=mt.GetInt("indexid",i);
		  GetTableName(tabid,indexid,tbname,idxname,TBNAME_DEST);
		  if(needbackup) {
			  GetTableName(tabid,indexid,tbname_p,idxname_p,TBNAME_FORDELETE);
			  conn.RenameTable(idxname,idxname_p,true);
		  }
		  GetTableName(tabid,indexid,tbname_p,idxname_p,TBNAME_PREPONL);
		  conn.RenameTable(idxname_p,idxname,true);
	  }
	  if(needbackup) {
		  GetTableName(tabid,-1,tbname_p,idxname_p,TBNAME_FORDELETE);
		  conn.RenameTable(tbname,tbname_p,true);
	  }
	  GetTableName(tabid,-1,tbname_p,idxname_p,TBNAME_PREPONL);
	  conn.RenameTable(tbname_p,tbname,true);
	  
	  mt.FetchAll("select * from dt_datafilemap where tabid=%d and (fileflag=0 or fileflag is null) and isfirstindex=1 order by datasetid,indexid,subdatasetid,fileid",
		  tabid);
	  rn=mt.Wait();
	  
	  st.Prepare("update dt_table set datasetid=%d,recordnum=%d,firstdatafileid=%d,totalbytes=%15.0f,"
		  "datafilenum=%d where tabid=%d",
		  mt.GetInt("datasetid",0),sumrn,mt.GetInt("fileid",0),tsize,fnum,tabid);
	  st.Execute(1);
	  st.Wait();
	  wociCommit(dts);
	  BuildDTP(tbname);
	  lgprintf("表'%s'成功上线,记录数%d. MySQL刷新...",tbname,sumrn);
	  conn.FlushTables(tbname);
	  wociSetEcho(ec);
	}
	catch(...) {
	  if(!sharemode) {
		  lgprintf("恢复文件类型,正常->待装入");
		  st.Prepare("update dt_datafilemap set fileflag=1 where tabid=%d and fileflag=0",tabid);
		  st.Execute(1);
		  st.Wait();
		  st.Prepare("update dt_indexfilemap set fileflag=1 where tabid=%d and fileflag=0",tabid);
		  st.Execute(1);
		  st.Wait();
	  }
	  if(needbackup) {
		  lgprintf("恢复文件类型,待删除->正常");
		  st.Prepare("update dt_datafilemap set fileflag=0 where tabid=%d and fileflag=2",tabid);
		  st.Execute(1);
		  st.Wait();
		  st.Prepare("update dt_indexfilemap set fileflag=0 where tabid=%d and fileflag=2",tabid);
		  st.Execute(1);
		  st.Wait();
	  }
	  throw;
	}		
		
  }
  
  void SysAdmin::BuildDTP(const char *tbname)
  {
	  lgprintf("建立DP参数文件.");
	  char basedir[300];
	  char streamPath[300];
	  char tbntmp[200];
	  AutoMt mt(dts,100);
	  mt.FetchAll("select * from dt_path where pathtype='msys'");
	  if(mt.Wait()!=1) ThrowWith("查找基本目录失败，请检查dt_path表和同义词定义.");
	  strcpy(basedir,mt.PtrStr("pathval",0));
	  
	  dtioStream *pdtio=new dtioStreamFile(basedir);
	  strcpy(tbntmp,tbname);
	  char *psep=strstr(tbntmp,".");
	  if(psep==NULL) 
		  ThrowWith("Invalid table name format'%s',should be dbname.tbname.",tbname);
	  *psep=0;
	  psep++;
#ifdef WIN32
	  sprintf(streamPath,"%s%s\\%s.DTP",basedir,tbntmp,psep);
#else
	  sprintf(streamPath,"%s%s/%s.DTP",basedir,tbntmp,psep);
#endif
	  pdtio->SetStreamName(streamPath);
	  pdtio->SetWrite(false);
	  pdtio->StreamWriteInit(DTP_BIND);
	  
	  pdtio->SetOutDir(basedir);
	  {
		  dtioDTTable dtt(tbntmp,psep,pdtio,false);
		  dtt.FetchParam(dts);
		  dtt.SerializeParam();
	  }
	  pdtio->SetWrite(true);
	  pdtio->StreamWriteInit(DTP_BIND);
	  pdtio->SetOutDir(basedir); 
	  {
		  dtioDTTable dtt(tbntmp,psep,pdtio,false);
		  dtt.FetchParam(dts);
		  dtt.SerializeParam();
	  }
	  delete pdtio;
  }
  
  //表名必须是全名(含数据库名)
  void SysAdmin::GetPathName(char *path,const char *tbname,const char *surf) {
	  char dbname[150];
	  strcpy(dbname,tbname);
	  char *dot=strstr(dbname,".");
	  if(dot==NULL) 
		  ThrowWith("表名必须是全名('%s')",tbname);
	  char *mtbname=dot+1;
	  *dot=0;
	  const char *pathval=GetMySQLPathName(0,"msys");
#ifdef WIN32
	  sprintf(path,"%s\\%s\\%s.%s",pathval,dbname,mtbname,surf);
#else
	  sprintf(path,"%s/%s/%s.%s",pathval,dbname,mtbname,surf);
#endif
  }
  
  //type TBNAME_DEST: destination name
  //type TBNAME_PREPONL: prepare for online
  //type TBNAME_FORDELETE: fordelete 
  
  void SysAdmin::GetTableName(int tabid,int indexid,char *tbname,char *idxname,int type) {
	  char tbname1[150],idxname1[150],dbname[130];
	  if(tabid==-1 && indexid==-1) 
		  ThrowWith("Invalid parameter on call SysAdmin::GetTableName.");
	  AutoMt mt(dts,10);
	  if(indexid!=-1) {
		  mt.FetchAll("select * from dt_index where indexid=%d and issoledindex=1",indexid);
		  int rn=mt.Wait();
		  if(rn<1)
			  ThrowWith("Indexid is invalid or not a soled :%d",indexid);
		  strcpy(idxname1,mt.PtrStr("indextabname",0));
		  tabid=mt.GetInt("tabid",0);
	  }
	  mt.FetchAll("select * from dt_table where tabid=%d",tabid);
	  int rn=mt.Wait();
	  if(rn<1)
		  ThrowWith("Tabid is invalid  :%d",tabid);
	  strcpy(tbname1,mt.PtrStr("tabname",0));
	  strcpy(dbname,mt.PtrStr("databasename",0));
	  if(type!=TBNAME_DEST) {
		  if(indexid!=-1) {
			  strcat(idxname1,"_");
			  strcat(idxname1,dbname);
		  }
		  strcat(tbname1,"_");
		  strcat(tbname1,dbname);
		  if(type==TBNAME_PREPONL)
			  strcpy(dbname,PREPPARE_ONLINE_DBNAME);
		  else if(type==TBNAME_FORDELETE)
			  strcpy(dbname,FORDELETE_DBNAME);
		  else ThrowWith("Invalid table name type :%d.",type);
	  }
	  sprintf(tbname,"%s.%s",dbname,tbname1);
	  if(indexid!=-1)
		  sprintf(idxname,"%s.%s",dbname,idxname1);
  }
  
  void SysAdmin::CreateAllIndex(int tabid,int nametype,bool forcecreate,int ci_type)
  {
	  AutoMt mt(dts,MAX_DST_INDEX_NUM);
	  mt.FetchAll("select * from dt_index where tabid=%d and issoledindex=1 order by indexidindattab",tabid);
	  int rn=mt.Wait();
	  if(rn<1)
		  ThrowWith("找不到%d表的独立索引。",tabid);
	  for(int i=0;i<rn;i++)
		  CreateIndex(mt.GetInt("indexid",i),nametype,forcecreate,ci_type);
  }
  
  void SysAdmin::RepairAllIndex(int tabid,int nametype)
  {
	  AutoMt mt(dts,MAX_DST_INDEX_NUM);
	  mt.FetchAll("select * from dt_index where tabid=%d and issoledindex=1 order by indexidindattab",tabid);
	  int rn=mt.Wait();
	  if(rn<1)
		  ThrowWith("找不到%d表的独立索引。",tabid);
	  for(int i=0;i<rn;i++) {
		  int indexid=mt.GetInt("indexid",i);
		  char tbname[100],idxname[100];
		  GetTableName(-1,indexid,tbname,idxname,nametype);
		  lgprintf("索引表刷新...");
		  FlushTables(idxname);
		  lgprintf("索引表重建:%s...",idxname);
		  
		  char fn[500];
		  GetPathName(fn,idxname,"MYI");
		  char cmdline[500];
		  // -n 选项用于强制使用排序方式修复
		  sprintf(cmdline,"myisamchk -rqnv --tmpdir=\"%s\" %s ",GetMySQLPathName(0,"msys"),fn);
		  int rt=system(cmdline);
		  wait(&rt);
		  if(rt)
			  ThrowWith("索引重建失败!");
		  //char sqlbf[3000];
		  //sprintf(sqlbf,"repair table %s quick",idxname);
		  //conn.DoQuery(sqlbf);
	  }
  }
  
  void SysAdmin::CreateIndex(int indexid,int nametype,bool forcecreate,int ci_type)
  {
	  AutoMt mt(dts,10);
	  mt.FetchAll("select * from dt_index where indexid=%d and issoledindex=1",indexid);
	  int rn=mt.Wait();
	  if(rn<1)
		  ThrowWith("Indexid is invalid or not a soled :%d",indexid);
	  char colsname[300];
	  strcpy(colsname,mt.PtrStr("columnsname",0));
	  char tbname[100],idxname[100];
	  GetTableName(-1,indexid,tbname,idxname,nametype);
	  //建立独立索引：
	  if(ci_type==CI_ALL || ci_type==CI_IDX_ONLY)
		  CreateIndex(idxname,mt.GetInt("indexidinidxtab",0),colsname,forcecreate);
	  if(ci_type==CI_ALL || ci_type==CI_DAT_ONLY)
		  CreateIndex(tbname,mt.GetInt("indexidindattab",0),colsname,forcecreate);
	  
	  //建立依赖索引：
	  //查找该独立索引附带的非独立索引，并以此为依据建立索引表
	  mt.FetchAll("select * from dt_index where reuseindexid=%d order by indexidinidxtab",
		  indexid);
	  int srn=mt.Wait();
	  for(int j=0;j<srn;j++) {
		  strcpy(colsname,mt.PtrStr("columnsname",j));
		  if(ci_type==CI_ALL || ci_type==CI_IDX_ONLY)
			  CreateIndex(idxname,mt.GetInt("indexidinidxtab",j),colsname,forcecreate);
		  if(ci_type==CI_ALL || ci_type==CI_DAT_ONLY)
			  CreateIndex(tbname,mt.GetInt("indexidindattab",j),colsname,forcecreate);
	  }
  }
  
  void SysAdmin::CreateIndex(const char *dtname, int id, const char *colsname, bool forcecreate)
  {
	  //create index语句中的索引名称不允许带数据库名。
	  const char *tbname=strstr(dtname,".");
	  if(tbname==NULL) tbname=dtname;
	  else tbname++;
	  char sqlbf[300];
	  if(forcecreate) {
		  sprintf(sqlbf,"drop index %s_%d on %s",tbname,
			  id,dtname);
		  conn.DoQuery(sqlbf);
	  }
	  sprintf(sqlbf,"create index %s_%d on %s(%s)",
		  tbname,id,
		  dtname,colsname);
	  lgprintf("建立索引:%s.",sqlbf);
	  conn.DoQuery(sqlbf);
  }
#ifdef WORDS_BIGENDIAN
#define revlint(v) v
#else
#define revlint(V)   { char def_temp[8];\
	((mbyte*) &def_temp)[0]=((mbyte*)(V))[7];\
	((mbyte*) &def_temp)[1]=((mbyte*)(V))[6];\
	((mbyte*) &def_temp)[2]=((mbyte*)(V))[5];\
	((mbyte*) &def_temp)[3]=((mbyte*)(V))[4];\
	((mbyte*) &def_temp)[4]=((mbyte*)(V))[3];\
	((mbyte*) &def_temp)[5]=((mbyte*)(V))[2];\
	((mbyte*) &def_temp)[6]=((mbyte*)(V))[1];\
	((mbyte*) &def_temp)[7]=((mbyte*)(V))[0];\
  memcpy(V,def_temp,sizeof(LLONG)); }
#endif                          
  
  int DestLoader::Load(bool directIOSkip) {
	  //Check deserved temporary(middle) fileset
	  AutoMt mdf(psa->GetDTS(),MAX_DST_DATAFILENUM);
	  //	  mdf.FetchAll("select * from dt_taskschedule where (taskstatus=3 or taskstatus=30) and rownum<2");
	  mdf.FetchAll("select * from dt_taskschedule where (taskstatus=3 or taskstatus=30) limit 2");
	  int rn=mdf.Wait();
	  if(rn<1) {
		  printf("没有发现处理完成等待装入的数据(任务状态=3).\n");
		  return 0;
	  }
	  char sqlbf[1000];
	  srctabid=mdf.GetInt("srctabid",0);
	  taskid=mdf.GetInt("taskid",0);
	  partid=mdf.GetInt("partid",0);
	  int appendmode=mdf.GetInt("strategyforpileup",0);
	  datasetid=mdf.GetInt("datasetid",0);
	  bool preponl=mdf.GetInt("taskstatus",0)==3;
	  lgprintf("装入类型:%s.",preponl?"新装入":"重装入");
	  //	  mdf.FetchAll("select * from dt_taskschedule where taskstatus!=%d and datasetid=%d and rownum<2",preponl?3:30,datasetid);
	  mdf.FetchAll("select * from dt_taskschedule where taskstatus<%d and datasetid=%d limit 2",preponl?3:30,datasetid);
	  rn=mdf.Wait();
	  if(rn>0) {
		  printf("数据装入时，数据集%d包含的任务中，一些任务状态还未整理,例如任务号%d(状态%d).\n",datasetid,
			  mdf.GetInt("taskid",0),mdf.GetInt("taskstatus",0));
		  return 0;
	  }
	  
	  mdf.FetchAll("select * from dt_taskschedule where taskstatus>%d and datasetid=%d limit 2",preponl?3:30,datasetid);
	  rn=mdf.Wait();
	  if(rn>0) {
		  if(!preponl) {
			  lgprintf("数据装入时，发现增量装入数据子集，但任务状态为重新装入(30)，应该是新增装入(3),数据集%d，任务号%d(状态%d).\n",datasetid,
				  mdf.GetInt("taskid",0),mdf.GetInt("taskstatus",0));
			  return 0;
		  }
		  // 2005/08/27修改，partid等效于subdatasetid
		  mdf.FetchAll("select count(*) fn,sum(recordnum) rn from dt_datafilemap where datasetid=%d and subdatasetid=%d and fileflag=1 ",datasetid,partid);
		  mdf.Wait();
		  if(mdf.GetInt("fn",0)<1) {
			  lgprintf("数据装入时，发现增量装入数据子集，但找不到数据文件,任务号:%d.",taskid);
			  //char ans[100];
			  //sprintf(choose,"继续吗(Y/N)?");
			  //if(!GetYesNo(choose,false)) {
				AutoStmt st(psa->GetDTS());
				st.DirectExecute(" update dt_taskschedule set taskstatus=5 where taskid=%d",taskid); 
				lgprintf("取消装入，任务%d恢复为已完成。 ",taskid);
				return 0;
			  //}
		  }
		  if(appendmode==0) 
			  lgprintf("数据集%d的分区%d即将被替换，原有数据记录被置为待删除(fileflag=2).",datasetid,partid);
		  lgprintf("新的分区有%d个文件，%15.f条记录.",mdf.GetInt("fn",0),mdf.GetDouble("rn",0));
		  if(appendmode==0) {
			  mdf.FetchAll("select count(*) fn,sum(recordnum) rn from dt_datafilemap where datasetid=%d and subdatasetid=%d and fileflag=0 ",datasetid,partid);
			  mdf.Wait();
			  lgprintf("老的分区有%d个文件，%15.f条记录.",mdf.GetInt("fn",0),mdf.GetDouble("rn",0));
		  }
		  AutoStmt st(psa->GetDTS());
		  if(appendmode==0) {
			  st.DirectExecute(" update dt_datafilemap set fileflag=2 where subdatasetid=%d and datasetid=%d and fileflag=0 ",partid,datasetid);
			  st.DirectExecute(" update dt_indexfilemap set fileflag=2 where subdatasetid=%d and datasetid=%d and fileflag=0 ",partid,datasetid);
		  }
		  st.DirectExecute(" update dt_datafilemap set fileflag=0 where subdatasetid=%d and datasetid=%d and fileflag=1 ",partid,datasetid);
		  st.DirectExecute(" update dt_indexfilemap set fileflag=0 where subdatasetid=%d and datasetid=%d and fileflag=1 ",partid,datasetid);
		  st.DirectExecute(" update dt_taskschedule set taskstatus=30 where datasetid=%d",datasetid);
		  lgprintf("数据集%d的任务已变换为重新装入(30).",datasetid);
		  preponl=false;
	  }
	  
	  wociSetTraceFile("dl数据装载/");
	  psa->OutTaskDesc("数据装载 :",taskid);
	  //	  mdf.FetchAll("select * from dt_datafilemap where datasetid=%d and procstatus=0 and fileflag=%d and rownum<2",
	  mdf.FetchAll("select * from dt_datafilemap where datasetid=%d and procstatus=0 and fileflag=%d limit 2",
		  datasetid,preponl?1:0);
	  if(mdf.Wait()<1) {
		  errprintf("任务%d指示已完成数据整理，但找不到对应数据集%d的数据记录。\n可能是数据文件记录不存在或状态非空闲(0).\n",taskid,datasetid);
		  return 0;
	  }
	  indexid=mdf.GetInt("indexid",0);
	  //mdf.FetchAll("select * from dt_datafilemap where datasetid=%d and indexid=%d ",datasetid,indexid);
	  subdatasetid=mdf.GetInt("subdatasetid",0);
	  tabid=mdf.GetInt("tabid",0);
	  
	  mdf.FetchAll("select * from dt_table where tabid=%d",tabid);
	  if(mdf.Wait()<1) {
		  errprintf("找不到数据文件对应的目标表(%d).\n",tabid);
		  return 0;
	  }
	  //char dbname[300];
	  //strcpy(dbname,mdf.PtrStr("databasename",0));
	  //conn.SelectDB(dbname);
	  //partid=mdf.GetInt("partid",0);
	  //dumpparam dpsrc;
	  //psa->GetSoledIndexParam(srctabid,&dpsrc);
	  
	  psa->GetSoledIndexParam(srctabid,&dp,tabid);
	  
	  AutoMt idxmt(psa->GetDTS(),10);
	  idxmt.FetchAll("select * from dt_index where tabid=%d and issoledindex=1",tabid);
	  int idxrn=idxmt.Wait();
	  int totdatrn=0;
	  try {
		  //为防止功能重入,数据文件状态修改.
		  mdf.FetchAll("select * from dt_datafilemap where datasetid=%d  and fileflag=%d order by subdatasetid,fileid",
			  datasetid,preponl?1:0);
		  totdatrn=rn=mdf.Wait();
		  lgprintf("修改数据文件的处理状态(datasetid:%d,%d个文件)：0-->1",datasetid,rn);
		  sprintf(sqlbf,"update dt.dt_datafilemap set procstatus=1 where datasetid=%d and "
			  "procstatus=0 and fileflag=%d",datasetid,preponl?1:0);
		  if(psa->DoQuery(sqlbf)!=rn) 
			  ThrowWith("修改数据文件的处理状态异常，可能是与其它进程冲突。\n"
			  "   taskid:%d,tabid:%d,datasetid:%d,srctabid:%d.\n",
			  taskid,tabid,datasetid,srctabid);
	  for(int i=0;i<idxrn;i++) {
		  indexid=idxmt.GetInt("indexid",i);
		  mdf.FetchAll("select * from dt_indexfilemap where datasetid=%d and indexid=%d and fileflag=%d order by subdatasetid,fileid",
			  datasetid,indexid,preponl?1:0);
		  rn=mdf.Wait();
		  if(rn<1) ThrowWith("找不到索引数据文件(indexid:%d,datasetid:%d,fileflag:%d).",indexid,datasetid,preponl?1:0);
		  //索引数据表的结构从文件提取，比从template中提取更准确。
		  int off=dp.GetOffset(indexid);
		  //{
		  dt_file idxf;
		  idxf.Open(mdf.PtrStr("filename",0),0);
		  AutoMt indexmt(0);
		  indexmt.SetHandle(idxf.CreateMt(10));
		  /*
		  if(conn.TouchTable(dp.idxp[off].idxtbname)) {
		  printf("table %s has exist,dropped.\n",dp.idxp[off].idxtbname);
		  sprintf(sqlbf,"drop table %s",dp.idxp[off].idxtbname);
		  conn.DoQuery(sqlbf);
		  }
		  //建立目标标及其表结构的描述文件
		  wociGetCreateTableSQL(idxmt,sqlbf,dp.idxp[off].idxtbname,true);
		  conn.DoQuery(sqlbf);
		  */
		  //}
		  
		  AutoMt datmt(psa->GetDTS(),MAX_DST_DATAFILENUM);
		  datmt.FetchAll("select * from dt_datafilemap where datasetid=%d and tabid=%d and "
			  "indexid=%d and procstatus=1 and fileflag=%d order by subdatasetid,fileid",
			  datasetid,tabid,indexid,preponl?1:0);
		  int datrn=datmt.Wait();
		  //防止功能重入或并行运行时的重复执行
		  if(datrn<1) continue;
		  char fn[300];
		  bool isfixed=false;
		  int k=0;
		  const char *pathval=psa->GetMySQLPathName(0,"msys");		
			  for(k=0;k<datrn;k++) {
				  //Build table data file link information.
				  if(k+1==datrn) {
					  dt_file df;
					  df.Open(datmt.PtrStr("filename",k),2,datmt.GetInt("fileid",k));
					  df.SetFileHeader(0,NULL);
				  }
				  else {
					  dt_file df;
					  df.Open(datmt.PtrStr("filename",k),2,datmt.GetInt("fileid",k));
					  df.SetFileHeader(0,datmt.PtrStr("filename",k+1));
				  }
			  }
			  lgprintf("开始数据装入(DestLoading),文件数:%d,tabid:%d,datasetid:%d,taskid:%d ,indexid:%d ...",
				  rn,tabid,datasetid,taskid,indexid);
			  //原来的方式为不建立索引(FALSE参数)
			  //2005/12/01修改为建立索引（在空表之上),在索引重建过程中(::RecreateIndex,taskstaus 4->5),
			  //  使用repair table ... quick来快速建立索引结构。
			  // BUG FIXING
			  //**
			  psa->CreateIndexTable(indexid,indexmt,-1,TBNAME_PREPONL,TRUE,CI_IDX_ONLY);
			  //psa->CreateIndexTable(indexid,indexmt,-1,TBNAME_PREPONL,FALSE);
			  char tbname[150],idxname[150];
			  psa->GetTableName(tabid,indexid,tbname,idxname,TBNAME_PREPONL);
			  psa->GetPathName(fn,idxname,"MYD");
			  //struct _finddata_t ft;
			  FILE *fp =NULL;
			  if(!directIOSkip) {
				  fp=fopen(fn,"wb");
				  if(fp==NULL) 
					  ThrowWith("Open file %s for writing failed!",fn);
			  }
			  LLONG totidxrn=0;
			  //lgprintf("索引文件：%s",mdf.PtrStr("filename",0));
			  for(k=0;k<rn;k++) {
				  //Build index data file link information.
				  if(k+1==rn) {
					  dt_file df;
					  df.Open(mdf.PtrStr("filename",k),2,mdf.GetInt("fileid",k));
					  df.SetFileHeader(0,NULL);
					  //lgprintf(
				  }
				  else {
					  dt_file df;
					  df.Open(mdf.PtrStr("filename",k),2,mdf.GetInt("fileid",k));
					  df.SetFileHeader(0,mdf.PtrStr("filename",k+1));
				  }
				  file_mt idxf;
				  idxf.Open(mdf.PtrStr("filename",k),0);
				  int rn_fromtab=mdf.GetInt("recordnum",k);
				  int mt=idxf.ReadBlock(0,0);
				  isfixed=wociIsFixedMySQLBlock(mt);
				  LLONG startat=totidxrn;
				  try {
					  AutoStmt st(psa->GetDTS());
					  st.DirectExecute("use preponl");
					  lgprintf("生成索引数据...");
					  while(mt) {
						  if(!directIOSkip)
							  wociCopyToMySQL(mt,0,0,fp);
						  else wociAppendToDbTable(mt,idxname,psa->GetDTS(),true);
						  totidxrn+=wociGetMemtableRows(mt);
						  wociMTPrint(mt,10,NULL);
						  if(totidxrn-startat<rn_fromtab)
							  mt=idxf.ReadBlock(-1,0);
						  else break;
					  }
				  }
				  catch(...) {
					  AutoStmt st(psa->GetDTS());
					  st.DirectExecute("use dt");
					  throw;
				  }
				  {
					  AutoStmt st(psa->GetDTS());
					  st.DirectExecute("use dt");
					  lgprintf("索引数据:%lld行.",totidxrn);
				  }
			  }
			  if(!directIOSkip) {
				  fclose(fp);
				  fp=fopen(fn,"rb");
				  fseeko(fp,0,SEEK_END);
				  LLONG fsz=ftello(fp);//_filelength(_fileno(fp));
				  fclose(fp);
				  //索引数据表的结构从文件提取，比从template中提取更准确。
				  psa->GetPathName(fn,idxname,"MYI");
				  char tmp[20];
				  memset(tmp,0,20);
				  
				  revlint(&totidxrn);
				  revlint(&fsz);
				  fp=fopen(fn,"r+b");
				  if(fp==NULL) 
					  ThrowWith("无法打开文件'%s'，请检查目录参数设置(dt_path)是否正确。",fn);
				  fseek(fp,28,SEEK_SET);
				  fwrite(&totidxrn,1,8,fp);
				  // reset deleted records count.
				  fwrite(tmp,1,8,fp);
				  fseek(fp,68,SEEK_SET);
				  fwrite(&fsz,1,8,fp);
				  fseek(fp,0,SEEK_END);
				  fclose(fp); 
				  lgprintf("索引表刷新...");
				  psa->FlushTables(idxname);
				  revlint(&fsz);
				  // BUG FIXING
				  //**ThrowWith("调试中断");
				  
				  if(fsz>1024*1024) {
					  lgprintf("压缩索引表:%s....",idxname);
					  char cmdline[300];
					  strcpy(fn+strlen(fn)-3,"TMD");
					  unlink(fn);
					  strcpy(fn+strlen(fn)-3,"MYI");
					  printf("pack:%s\n",fn);
					  sprintf(cmdline,"myisampack -v %s",fn);
					  //sprintf(cmdline,"gdb myisampack",fn);
					  int rt=system(cmdline) ;
					  wait (&rt);
					  if(rt)
						  ThrowWith("索引表%s压缩失败.",idxname);
					  lgprintf("压缩成功。");
				  }
			  }
		  }
	}
	catch(...) {
		  lgprintf("恢复数据文件的处理状态(datasetid:%d,indexid:%d,%d个文件)：1-->0",datasetid,indexid,totdatrn);
		  sprintf(sqlbf,"update dt.dt_datafilemap set procstatus=0 where datasetid=%d and fileflag=%d",
			  datasetid,preponl?1:0);
		  psa->DoQuery(sqlbf);
		  char tbname[150],idxname[150];
		  // BUG FIXING
		  /*
		  psa->GetTableName(tabid,indexid,tbname,idxname,TBNAME_PREPONL);
		  char fn[300];
		  psa->GetPathName(fn,idxname,"MYD");
		  unlink(fn);
		  psa->GetPathName(fn,idxname,"MYI");
		  unlink(fn);
		  psa->GetPathName(fn,idxname,"frm");
		  unlink(fn);
		  */
		  throw;
	}
	lgprintf("数据装入(DestLoading)结束 ...");
	AutoStmt updst(psa->GetDTS());
	updst.Prepare("update dt_taskschedule set taskstatus=%d where datasetid=%d",
		preponl?4:40,datasetid);
	updst.Execute(1);
	updst.Wait();
	lgprintf("任务状态更新,3(MLoaded)--->4(DLoaded),任务号:%d,数据集编号:%d",taskid,datasetid);
	ThrowWith("DEBUG_BREAK_HEAR.");
	return 1;
}


int DestLoader::MoveTable(const char *srcdbn,const char *srctabname,const char * dstdbn,const char *dsttabname)
{
	lgprintf("目标表改名(转移) '%s -> '%s'.",srctabname,dsttabname);
	AutoMt mt(psa->GetDTS(),100);
	mt.FetchAll("select pathval from dt_path where pathtype='msys'");
	int rn=mt.Wait();
	if(rn<1) 
		ThrowWith("找不到MySQL数据目录(dt_path.pathtype='msys'),数据转移异常中止.");
	char dtpath[300];
	strcpy(dtpath,mt.PtrStr(0,0));
	
	mt.FetchAll("select * from dt_table where tabname=lower('%s') and databasename=lower('%s')",dsttabname,dstdbn);
	int ntabid=-1;
	rn=mt.Wait();
	if(rn>0) {
		//if(mt.GetInt("srctabid",0)>0) {
		//	lgprintf("表名称已被占用，并且不能被覆盖（迁移目标表，srctabid>0）。");
		//	return 0;
		//}
		printf("表'%s'已存在(记录数:%d)，删除(Y/N)?",dsttabname,mt.GetInt("recordnum",0));
		char ans[100];
		fgets(ans,100,stdin);
		if(tolower(ans[0])!='y') {
			lgprintf("取消数据转移。 ");
			return 0;
		}
		RemoveTable(dstdbn,dsttabname,false);
		if(mt.GetInt("srctabid",0)>0) 
			ntabid=mt.GetInt("tabid",0);
	}
	int dsttabid=ntabid;
	if(ntabid==-1) {
		//mt.FetchAll("select max(tabid) from dt_table");
		//mt.Wait();
		dsttabid=psa->NextTableID();//mt.PtrInt(0,0)+1;
	}
	mt.FetchAll("select * from dt_table where tabname=lower('%s') and databasename=lower('%s')",srctabname,srcdbn);
	rn=mt.Wait();
	if(rn<1) {
		lgprintf("源表'%s'不存在.",srctabname);
		return 0;
	}
	tabid=mt.GetInt("tabid",0);
	datasetid=mt.GetInt("datasetid",0);
	int recordnum=mt.GetInt("recordnum",0);
	int firstdatafileid=mt.GetInt("firstdatafileid",0);
	double totalbytes=mt.GetDouble("totalbytes",0);
	int datafilenum=mt.GetInt("datafilenum",0);
	//if(recordnum<1) {
	//	lgprintf("源表'%s'数据为空，数据转移失败。",srctabname);
	//	return 0;
	//}
	lgprintf("源表'%s.%s' id:%d,datasetid:%d,recordnum:%d,first data file id :%d",
		srcdbn,srctabname,tabid,datasetid,recordnum,firstdatafileid);
	int idxstart=0;
	//新表不存在，则在dt_table中新建一条记录
	if(ntabid==-1) {
		*mt.PtrInt(0,0)=dsttabid;
		strcat(mt.PtrStr("tabdesc",0),"_r");
		strcpy(mt.PtrStr("tabname",0),dsttabname);
		strcpy(mt.PtrStr("databasename",0),dstdbn);
		if(mt.GetInt("srctabid",0)>0) 
			*mt.PtrInt("srctabid",0)=-*mt.PtrInt("srctabid",0);
		wociAppendToDbTable(mt,"dt_table",psa->GetDTS(),true);
		//mt.FetchAll("select max(indexid) from dt_index");
		//mt.Wait();
		idxstart=psa->NextIndexID();//mt.PtrInt(0,0)+1;
		CopyMySQLTable(dtpath,srcdbn,srctabname,dstdbn,dsttabname);
	}
	//暂时关闭源表和目标表的数据访问，记录数已存在本地变量recordnum。
	char sqlbuf[1000];
	lgprintf("关闭源表和目标表，记录数：%d",recordnum);
	psa->CloseTable(tabid,NULL,false);
	psa->CloseTable(dsttabid,NULL,false);
	//如果是目标表覆盖模式，目标表必须和源表的结构（包括数据和索引）必须一致，否则
	//  后果将不可预料。
	mt.FetchAll("select * from dt_index where tabid=%d order by indexid ",tabid);
	rn=mt.Wait();
	AutoMt idxdmt(psa->GetDTS(),MAX_DST_INDEX_NUM);
	if(ntabid!=-1) {
		idxdmt.FetchAll("select * from dt_index where tabid=%d order by indexid",ntabid);
		if(idxdmt.Wait()!=rn) 
			ThrowWith("目标表的索引数与源表不同，无法执行数据转移操作!");
	}
	//创建索引记录和索引表，修改索引文件和数据文件的tabid,indexid 指向
	for(int i=0;i<rn;i++) {
		int oldidxid=*mt.PtrInt(0,i);
		if(ntabid==-1) {
			*mt.PtrInt(0,i)=idxstart;// indexid
			*mt.PtrInt(1,i)=dsttabid; // tabid
			lgprintf("创建索引，编号 :%d",idxstart);
		}
		else
			idxstart=*idxdmt.PtrInt(0,i);
		if(mt.GetInt("issoledindex",i)==1) {
			char tmpfn[300];
			strcpy(tmpfn,mt.PtrStr("indextabname",i));
			const char *pdfn;
			if(ntabid==-1) {
				sprintf(mt.PtrStr("indextabname",i),"%sidx%d",dsttabname,idxstart);
				pdfn=mt.PtrStr("indextabname",i);
			}
			else pdfn=idxdmt.PtrStr("indextabname",i);
			lgprintf("索引表 '%s.%s'-->'%s.%s...'",srcdbn,tmpfn,dstdbn,pdfn);
			CopyMySQLTable(dtpath,srcdbn,tmpfn,dstdbn,pdfn);
			sprintf(sqlbuf,"update dt.dt_datafilemap set tabid=%d,indexid=%d where tabid=%d and indexid=%d and datasetid=%d and fileflag=0",
				dsttabid,idxstart,tabid,oldidxid,datasetid);
			int un=psa->DoQuery(sqlbuf);
			if(un<1 && recordnum>0) 
				ThrowWith("找不到数据文件记录，表编号%d,索引号%d,数据集号:%d,数据移动异常终止！",
				tabid,oldidxid,datasetid);
			sprintf(sqlbuf,"update dt.dt_indexfilemap set tabid=%d,indexid=%d where tabid=%d and indexid=%d and datasetid=%d and fileflag=0",
				dsttabid,idxstart,tabid,oldidxid,datasetid);
			if(un<1 && recordnum>0) 
				ThrowWith("找不到索引文件记录，表编号%d,索引号%d,数据集号:%d,数据移动异常终止！",
				tabid,oldidxid,datasetid);
			un=psa->DoQuery(sqlbuf);
			if(ntabid==-1) {
				for(int j=0;j<rn;j++) {
					if(mt.GetInt("reuseindexid",j)==oldidxid) {
						*mt.PtrInt("reuseindexid",j)=idxstart;
						strcpy(mt.PtrStr("indextabname",j),mt.PtrStr("indextabname",i));
						lgprintf("索引编号%d复用编号%d.",mt.GetInt("indexid",j),idxstart);
					}
				}
			}
		}
		if(ntabid==-1) 
			idxstart=psa->NextIndexID();
	}
	if(ntabid==-1) 
		wociAppendToDbTable(mt,"dt_index",psa->GetDTS(),true);// waitting not needed.
	sprintf(sqlbuf,"update dt.dt_table set datasetid=%d,recordnum=%d,firstdatafileid=%d,totalbytes=%15.0f,datafilenum=%d where tabid=%d",
		datasetid,recordnum,firstdatafileid,totalbytes,datafilenum,dsttabid);
	psa->DoQuery(sqlbuf);
	sprintf(sqlbuf,"update dt.dt_taskschedule set tabid=%d where datasetid=%d",
		dsttabid,datasetid);
	psa->DoQuery(sqlbuf);
	// reset firstdatafileid of srctable?
	//sprintf(sqlbuf,"update dt.dt_table set datasetid=0,firstdatafileid=0 where tabid=%d",
	//	tabid);
	//conn.DoQuery(sqlbuf);
	//Move操作结束,打开目标表
	lgprintf("MySQL刷新...");
	char tbn[300];
	sprintf(tbn,"%s.%s",dstdbn,dsttabname);
	psa->BuildDTP(tbn);
	psa->FlushTables(tbn);
	lgprintf("删除源表..");
	RemoveTable(srcdbn,srctabname,false);
	lgprintf("数据已从表'%s'转移到'%s'。",srctabname,dsttabname);
	return 1;
}


// 7,10的任务状态处理:
//   1. 从文件系统获取二次压缩后的文件大小.
//   2. 任务状态修改为(8,11) (?? 可以省略)
//   3. 关闭目标表(unlink DTP file,flush table).
//   4. 修改数据/索引映射表中的文件大小和压缩类型.
//   5. 数据/索引 文件替换.
//   6. 任务状态修改为30(等待重新装入).
int DestLoader::ReLoad() {
	
	AutoMt mdf(psa->GetDTS(),10);
	//	mdf.FetchAll("select * from dt_taskschedule where taskstatus in (7,10) and rownum<2");
	mdf.FetchAll("select * from dt_taskschedule where taskstatus in (7,10) limit 2");
	int rn=mdf.Wait();
	if(rn<1) {
		printf("没有发现重新压缩完成等待装入的数据.\n");
		return 0;
	}
	wociSetTraceFile("drcl重新压缩后装入/");
	bool dpcp=mdf.GetInt("taskstatus",0)==7;
	int compflag=mdf.GetInt("compflag",0);
	datasetid=mdf.GetInt("datasetid",0);
	mdf.FetchAll("select * from dt_datafilemap where datasetid=%d and (fileflag=0 or fileflag is null) order by indexid",datasetid);
	rn=mdf.Wait();
	if(rn<1) {
		lgprintf("装入二次压缩数据时找不到数据文件记录。");
		return 1;
	}
	tabid=mdf.GetInt("tabid",0);
	mdf.FetchAll("select * from dt_table where tabid=%d",tabid);
	rn=mdf.Wait();
	if(rn<1) {
		lgprintf("装入二次压缩数据时找不到dt_table记录(tabid:%d).",tabid);
		return 1;
	}
	char dbname[100],tbname[100];
	strcpy(dbname,mdf.PtrStr("databasename",0));
	strcpy(tbname,mdf.PtrStr("tabname",0));
	AutoMt idxmt(psa->GetDTS(),MAX_DST_DATAFILENUM);
	mdf.FetchAll("select * from dt_indexfilemap where datasetid=%d and tabid=%d and (fileflag=0 or fileflag is null) order by indexid,subdatasetid,fileid",
		datasetid,tabid);
	rn=mdf.Wait();
	AutoMt datmt(psa->GetDTS(),MAX_DST_DATAFILENUM);
	datmt.FetchAll("select * from dt_datafilemap where datasetid=%d and tabid=%d and (fileflag=0 or fileflag is null) order by indexid,subdatasetid,fileid",datasetid,tabid);
	int datrn=datmt.Wait();
	AutoStmt updst(psa->GetDTS());
	char tmpfn[300];
	int k;
	unsigned long dtflen[1000];
	unsigned long idxflen[1000];
	//先检查
	for(k=0;k<datrn;k++) {
		sprintf(tmpfn,"%s.%s",datmt.PtrStr("filename",k),dpcp?"depcp":"dep5");
		dt_file df;
		df.Open(tmpfn,0);
		dtflen[k]=df.GetFileSize();
		if(dtflen[k]<1) 
			ThrowWith("file '%s' is empty!",tmpfn);
	}
	for(k=0;k<rn;k++) {
		sprintf(tmpfn,"%s.%s",mdf.PtrStr("filename",k),dpcp?"depcp":"dep5");
		dt_file df;
		df.Open(tmpfn,0);
		idxflen[k]=df.GetFileSize();
		if(idxflen[k]<1) 
			ThrowWith("file '%s' is empty!",tmpfn);
	}
	char sqlbf[200];
	sprintf(sqlbf,"update dt.dt_taskschedule set taskstatus=%d where datasetid=%d", dpcp?8:11,datasetid);
	if(psa->DoQuery(sqlbf)<1) 
		ThrowWith("二次压缩数据重新装入过程修改任务状态异常，可能是与其它进程冲突。\n"
		"  tabid:%d,datasetid:%d.\n",
		tabid,datasetid);
	
	//防止功能重入，修改任务状态
	//后续修改将涉及数据文件的替换,操作数据前先关闭表
	psa->CloseTable(tabid,NULL,false);
	lgprintf("数据已关闭.");
	//用新的数据文件替换原来的文件：先删除原文件，新文件名称更改为原文件并修改文件记录中的文件大小字段。
	lgprintf("开始数据和索引文件替换...");
	for(k=0;k<datrn;k++) {
		updst.Prepare("update dt_datafilemap set filesize=%d,compflag=%d where fileid=%d and fileflag=0",
			dtflen[k],compflag,datmt.GetInt("fileid",k));
		updst.Execute(1);
		updst.Wait();
		const char *filename=datmt.PtrStr("filename",k);
		unlink(filename);
		//sprintf(tmpfn,"%s.%s",filename,dpcp?"dep5":"depcp");
		//rename(filename,tmpfn);
		//lgprintf("rename file '%s' as '%s'",filename,tmpfn);
		sprintf(tmpfn,"%s.%s",filename,dpcp?"depcp":"dep5");
		rename(tmpfn,filename);
		lgprintf("rename file '%s' as '%s'",tmpfn,filename);
	}
	for(int i=0;i<rn;i++) {
		updst.Prepare("update dt_indexfilemap set filesize=%d ,compflag=%d where fileid=%d and fileflag=0",
			idxflen[i],compflag,mdf.GetInt("fileid",i));
		updst.Execute(1);
		updst.Wait();
		const char *filename=mdf.PtrStr("filename",i);
		unlink(filename);
		//sprintf(tmpfn,"%s.%s",filename,dpcp?"dep5":"depcp");
		//rename(filename,tmpfn);
		//lgprintf("rename file '%s' as '%s'",filename,tmpfn);
		sprintf(tmpfn,"%s.%s",filename,dpcp?"depcp":"dep5");
		rename(tmpfn,filename);
		lgprintf("rename file '%s' as '%s'",tmpfn,filename);
	}
	lgprintf("数据和索引文件已成功替换...");
	sprintf(sqlbf,"update dt.dt_taskschedule set taskstatus=30 where datasetid=%d", datasetid);
	psa->DoQuery(sqlbf);
	sprintf(sqlbf,"update dt.dt_datafilemap set procstatus=0 where datasetid=%d and fileflag=0",datasetid);
	lgprintf("任务状态修改为数据整理结束(3),数据文件处理状态改为未处理(0).");
	Load();
	return 1;
}


int DestLoader::RecreateIndex(SysAdmin *_Psa) 
{
	
	AutoMt mdf(psa->GetDTS(),MAX_MIDDLE_FILE_NUM);
	//	mdf.FetchAll("select * from dt_taskschedule where (taskstatus =4 or taskstatus=40 )and rownum<2");
	mdf.FetchAll("select * from dt_taskschedule where (taskstatus =4 or taskstatus=40 ) limit 2");
	int rn=mdf.Wait();
	if(rn<1) {
		return 0;
	}
	taskid=mdf.GetInt("taskid",0);
	srctabid=mdf.GetInt("srctabid",0);
	datasetid=mdf.GetInt("datasetid",0);
	tabid=mdf.GetInt("tabid",0);
	bool preponl=mdf.GetInt("taskstatus",0)==4;
	if(tabid<1) ThrowWith("找不到任务号:%d中Tabid",taskid);
	
	//check intergrity.
	int newdsid=datasetid;
	mdf.FetchAll("select * from dt_index where tabid=%d and issoledpindex=1",tabid);
	rn=mdf.Wait();
	if(rn<1) 
		ThrowWith("目标表%d缺少主索引记录.",tabid);
	
	mdf.FetchAll("select distinct indexid from dt_datafilemap where datasetid=%d and fileflag=%d",datasetid,preponl?1:0);
	rn=mdf.Wait();
	mdf.FetchAll("select * from dt_index where tabid=%d and issoledindex=1",tabid);
	int rni=mdf.Wait();
	if(rni!=rn) 
	{
		lgprintf("出现错误: 装入独立索引数(%d)和索引参数表中的值(%d)不符.",
			rn,rni);
		return 0; //dump && destload(create temporary index table) have not complete.
	}
	char sqlbf[300];
	try {
		sprintf(sqlbf,"update dt.dt_taskschedule set taskstatus=%d where datasetid=%d", 20,datasetid);
		if(psa->DoQuery(sqlbf)<1) 
			ThrowWith("数据装入重建索引过程修改任务状态异常，可能是与其它进程冲突。\n"
			"  tabid:%d,datasetid:%d.\n",
			tabid,datasetid);
		
		lgprintf("开始索引重建,tabid:%d,总索引数 :%d,datasetid=%d",
			tabid,rn,datasetid);
		char tbname[150],idxname[150];
		psa->GetTableName(tabid,-1,tbname,idxname,TBNAME_PREPONL);
		AutoMt destmt(0,10);
		psa->CreateDataMtFromFile(destmt,0,tabid,preponl?1:0);
		psa->CreateTableOnMysql(destmt,tbname,true);
		//2005/12/01 索引改为数据新增后重建(修复)。
		psa->CreateAllIndex(tabid,TBNAME_PREPONL,true,CI_DAT_ONLY);
		lgprintf("建立索引的过程可能需要较长的时间，请耐心等待...",
			tabid,rn,datasetid);
		psa->RepairAllIndex(tabid,TBNAME_PREPONL);
		psa->DataOnLine(tabid);
		lgprintf("索引建立完成.");
		mdf.FetchAll("select * from dt_datafilemap where datasetid=%d and isfirstindex=1 and fileflag!=2 order by subdatasetid,fileid",
			datasetid);
		rn=mdf.Wait();
	}
	catch (...) {
		errprintf("建立索引结构时出现异常错误,恢复处理状态...");
		sprintf(sqlbf,"update dt.dt_taskschedule set taskstatus=%d where datasetid=%d", preponl?3:30,datasetid);
		psa->DoQuery(sqlbf);
		sprintf(sqlbf,"update dt.dt_datafilemap set procstatus=0 where datasetid=%d and "
			"procstatus=1 and fileflag=%d",datasetid,preponl?1:0);
		psa->DoQuery(sqlbf);
		throw;
	}
	//int sumrn=0;
	//for(int i=0;i<rn;i++) sumrn+=mdf.GetInt("recordnum",i);
	//lgprintf("数据源准备完毕,记录数:%d.",sumrn);
	
	//sprintf(sqlbf,"update dt.dt_table set datasetid=%d,recordnum=%d,firstdatafileid=%d ,totalbytes=%15.0f ,datafilenum=%d where tabid=%d",
	//	datasetid,sumrn,mdf.GetInt("fileid",0),totalbytes,datafilenum,tabid);
	//psa->DoQuery(sqlbf);
	
	AutoStmt st(psa->GetDTS());
	st.Prepare("update dt_taskschedule set taskstatus=5 where datasetid=%d",
		datasetid);
	st.Execute(1);
	st.Wait();
	st.Prepare("update dt_datafilemap set procstatus=0 where datasetid=%d and fileflag=0",
		datasetid);
	st.Execute(1);
	st.Wait();
	lgprintf("任务状态4(DestLoaded)-->5(Complete),taskid:%d.",taskid);
	
	lgprintf("删除中间临时文件...");
	mdf.FetchAll("select * from dt_middledatafile where datasetid=%d",datasetid);
	{
		int dfn=mdf.Wait();
		for(int di=0;di<dfn;di++) {
			lgprintf("删除文件'%s'",mdf.PtrStr("datafilename",di));
			unlink(mdf.PtrStr("datafilename",di));
			lgprintf("删除文件'%s'",mdf.PtrStr("indexfilename",di));
			unlink(mdf.PtrStr("indexfilename",di));
		}
		lgprintf("删除记录...");
		st.Prepare("delete from dt_middledatafile where datasetid=%d",datasetid);
		st.Execute(1);
		st.Wait();
	} 
	psa->CleanData(false);
	return 1;
}

thread_rt LaunchWork(void *ptr) 
{
	((worker *) ptr)->work();
	thread_end;
}

//以下代码有错误
//up to 2005/04/13, the bugs of this routine continuous produce error occursionnaly .
//   ReCompress sometimes give up last block of data file,but remain original index record in idx file.
int DestLoader::ReCompress(int threadnum)
{
	AutoMt mdt(psa->GetDTS(),MAX_DST_DATAFILENUM);
	AutoMt mdf(psa->GetDTS(),MAX_DST_DATAFILENUM);
	mdt.FetchAll("select distinct datasetid,srctabid,taskstatus,compflag from dt_taskschedule where (taskstatus=6 or taskstatus=9)");
	int rn1=mdt.Wait();
	int rn;
	int i=0;
	bool deepcmp;
	if(rn1<1) {
		return 0;
	}
	wociSetTraceFile("ddc重新压缩/");
	for(i=0;i<rn1;i++) {
		//taskid=mdt.GetInt("taskid",i);
		srctabid=mdt.GetInt("srctabid",i);
		datasetid=mdt.GetInt("datasetid",i);
		deepcmp=mdt.GetInt("taskstatus",i)==6;
		mdf.FetchAll("select * from dt_datafilemap where datasetid=%d and procstatus =0 and (fileflag=0 or fileflag is null) order by indexid,subdatasetid,fileid",datasetid);
		rn=mdf.Wait();
		if(rn<1) {
			mdf.FetchAll("select * from dt_datafilemap where datasetid=%d and procstatus <>2 and (fileflag=0 or fileflag is null) order by indexid,subdatasetid,fileid",datasetid);
			rn=mdf.Wait();
			if(rn<1) {
				AutoStmt st1(psa->GetDTS());
				st1.Prepare("update dt_taskschedule set taskstatus=%d where datasetid=%d",
					deepcmp?7:10,datasetid);
				st1.Execute(1);
				st1.Wait();
				st1.Prepare("update dt_datafilemap set procstatus =0 where datasetid=%d and fileflag=0",datasetid);
				st1.Execute(1);
				st1.Wait();
				lgprintf("二次压缩任务已完成，任务状态已修改为%d,数据文件处理状态修改为空闲(0)",deepcmp?7:10);
			}
			else lgprintf("datasetid:%d---二次压缩任务未完成,但已没有等待压缩的数据",datasetid);
		}
		else break;
	}
	if(i==rn1) return 0;
	
	//防止重入，修改数据文件状态。
	psa->OutTaskDesc("数据重新压缩任务",0,0,0,datasetid);
	int compflag=mdt.GetInt("compflag",0);
	lgprintf("原压缩类型:%d, 新的压缩类型:%d .",mdf.GetInt("compflag",0),compflag);
	int fid=mdf.GetInt("fileid",0);
	char srcfn[300];
	strcpy(srcfn,mdf.PtrStr("filename",0));
	int origsize=mdf.GetInt("filesize",0);
	char dstfn[300];
	sprintf(dstfn,"%s.%s",srcfn,deepcmp?"depcp":"dep5");
	tabid=mdf.GetInt("tabid",0);
	//dstf.SetFileHeader(0,srcf.GetNextFileName());
	//mdf.SetMaxRows(10);
	mdf.FetchAll("select filename from dt_indexfilemap where fileid=%d and fileflag!=2",
		fid);
	if(mdf.Wait()<1)
		ThrowWith(" 找不到索引文件记录,dt_indexfilemap中的记录已损坏,请检查.\n"
		" 对应的数据文件为:'%s',文件编号: '%d'",srcfn,fid);
	char idxdstfn[300];
	sprintf(idxdstfn,"%s.%s",mdf.PtrStr("filename",0),deepcmp?"depcp":"dep5");
	double dstfilelen=0;
	try {
		AutoStmt st(psa->GetDTS());
		st.Prepare("update dt_datafilemap set procstatus=1 where fileid=%d and procstatus=0 and fileflag!=2",
			fid);
		st.Execute(1);
		st.Wait();
		if(wociGetFetchedRows(st)!=1) {
			lgprintf("处理文件压缩时状态异常,datasetid:%d,fid:%d,可能与其它进程冲突！"
				,datasetid,fid);
			return 1;
		}
		file_mt idxf;
		lgprintf("数据处理，数据文件:'%s',字节数:%d,索引文件:'%s'.",srcfn,origsize,mdf.PtrStr("filename",0));
		idxf.Open(mdf.PtrStr("filename",0),0);
		
		dt_file srcf;
		srcf.Open(srcfn,0,fid);
		dt_file dstf;
		dstf.Open(dstfn,1,fid);
		mdf.SetHandle(srcf.CreateMt());
		int lastoffset=dstf.WriteHeader(mdf,0,fid,srcf.GetNextFileName());
		
		dt_file idxdstf;
		idxdstf.Open(idxdstfn,1,fid);
		mdf.SetHandle(idxf.CreateMt());
		int idxrn=idxf.GetRowNum();
		idxdstf.WriteHeader(mdf,idxf.GetRowNum(),fid,idxf.GetNextFileName());
		//idxdstf.SetFileHeader(wociGetMemtableRows(*pidxmt),idxf.GetNextFileName());
		if(idxf.ReadBlock(-1,0)<0)
			ThrowWith("索引文件读取错误: '%s'",mdf.PtrStr("filename",0));
		AutoMt *pidxmt=(AutoMt *)idxf;
		//lgprintf("从索引文件读入%d条记录.",wociGetMemtableRows(*pidxmt));
		int *pblockstart=pidxmt->PtrInt("blockstart",0);
		int *pblocksize=pidxmt->PtrInt("blocksize",0);
		blockcompress bc(compflag);
		for(i=1;i<threadnum;i++) {
			bc.AddWorker(new blockcompress(compflag));
		}
#define BFNUM 10
		char *srcbf=new char[SRCBUFLEN];//每一次处理的最大数据块（解压缩后）。
		char *dstbf=new char[DSTBUFLEN*BFNUM];//可累积的最多数据(压缩后).
		int dstseplen=DSTBUFLEN;
		bool isfilled[BFNUM];
		int filledlen[BFNUM];
		int filledworkid[BFNUM];
		char *outcache[BFNUM];
		for(i=0;i<BFNUM;i++) {
			isfilled[i]=false;
			filledworkid[i]=0;
			outcache[i]=dstbf+i*DSTBUFLEN;
			filledlen[i]=0;
		}
		int workid=0;
		int nextid=0;
		int oldblockstart=pblockstart[0];
		int lastrow=0;
		int slastrow=0;
		bool iseof=false;
		bool isalldone=false;
		int lastdsp=0;
		mytimer tmr;
		tmr.Start();
		while(!isalldone) {//文件处理完退出
			if(srcf.ReadMt(-1,0,mdf,1,1,srcbf,false,true)<0) {
				iseof=true;
			}
			block_hdr *pbh=(block_hdr *)srcbf;
			int doff=srcf.GetDataOffset(pbh);
			if(pbh->origlen+doff>SRCBUFLEN) 
				ThrowWith("Decompress data exceed buffer length. dec:%d,bufl:%d",
				pbh->origlen+sizeof(block_hdr),SRCBUFLEN);
			bool deliverd=false;
			while(!deliverd) { //任务交付后退出
				worker *pbc=NULL;
				if(!iseof) {
					pbc=bc.GetIdleWorker();
					if(pbc) {
						
						//pbc->Do(workid++,srcbf,pbh->origlen+sizeof(block_hdr),
						//	pbh->origlen/2); //Unlock internal
						pbc->Do(workid++,srcbf,pbh->origlen+doff,doff,
							pbh->origlen/2); //Unlock internal
						deliverd=true;
					}
				}
				pbc=bc.GetDoneWorker();
				while(pbc) {
					char *pout;
					int dstlen=pbc->GetOutput(&pout);//Unlock internal;
					int doneid=pbc->GetWorkID();
					if(dstlen>dstseplen) 
						ThrowWith("要压缩的数据:%d,超过缓存上限:%d.",dstlen,dstseplen);
					//get empty buf:
					for(i=0;i<BFNUM;i++) if(!isfilled[i]) break;
					if(i==BFNUM) ThrowWith("Write cache buffer fulled!.");
					memcpy(outcache[i],pout,dstlen);
					filledworkid[i]=doneid;
					filledlen[i]=dstlen;
					isfilled[i]=true;
					pbc=bc.GetDoneWorker();
					//lgprintf("Fill to cache %d,doneid:%d,len:%d",i,doneid,dstlen);
				}
				bool idleall=bc.isidleall();
				for(i=0;i<BFNUM;i++) {
					if(isfilled[i] && filledworkid[i]==nextid) {
						for(;pblockstart[lastrow]==oldblockstart;) {
							pblockstart[lastrow]=lastoffset;
							pblocksize[lastrow++]=filledlen[i];
							slastrow++;
							if(lastrow==wociGetMemtableRows(*pidxmt)) {
								idxdstf.WriteMt(*pidxmt,compflag,0,false);
								if(idxf.ReadBlock(-1,0)>0) {
									//ThrowWith("索引文件读取错误: '%s'",mdf.PtrStr("filename",0));
									pidxmt=(AutoMt *)idxf;
									//lgprintf("从索引文件读入%d条记录.",wociGetMemtableRows(*pidxmt));
									pblockstart=pidxmt->PtrInt("blockstart",0);
									pblocksize=pidxmt->PtrInt("blocksize",0);
									lastrow=0;
								}
							}
							else if(lastrow>wociGetMemtableRows(*pidxmt)) 
								ThrowWith("索引文件读取错误: '%s'",mdf.PtrStr("filename",0));
							
						}
						lastoffset=dstf.WriteBlock(outcache[i],filledlen[i],0,true);
						oldblockstart=pblockstart[lastrow];
						dstfilelen+=filledlen[i];
						filledworkid[i]=0;
						filledlen[i]=0;
						isfilled[i]=false;
						nextid++;
						tmr.Stop();
						double tm1=tmr.GetTime();
						if(nextid-lastdsp>=50) { 
							printf("已处理%d个数据块(%d%%),%.2f(MB/s) %.0f--%.0f.\r",nextid,slastrow*100/idxrn,lastoffset/tm1/1024/1024,tm1,tm1/slastrow*(idxrn-slastrow));
							fflush(stdout);
							lastdsp=nextid;
						}
						i=-1; //Loop from begining.
					}
				}
				if(idleall && iseof) {
					//					if(bc.isidleall()) {
					isalldone=true;
					break;
					//					}
				}
				if(!pbc) 
					mSleep(20);
			}
		}
		if(lastrow!=wociGetMemtableRows(*pidxmt)) 
			ThrowWith("异常错误：并非所有数据都被处理，已处理%d,应处理%d.",lastrow,wociGetMemtableRows(*pidxmt));
		idxdstf.WriteMt(*pidxmt,compflag,0,false);
		dstf.Close();
		idxdstf.Close();
		st.Prepare("update dt_datafilemap set procstatus=2 where fileid=%d and procstatus=1 and fileflag=0",
			fid);
		st.Execute(1);
		st.Wait();
		delete []srcbf;
		delete []dstbf;
	}
	catch(...) {
		errprintf("数据二次压缩出现异常，文件处理状态恢复...");
		AutoStmt st(psa->GetDTS());
		st.Prepare("update dt_datafilemap set procstatus=0 where fileid=%d and procstatus=1 and fileflag=0",
			fid);
		st.Execute(1);
		st.Wait();
		errprintf("删除数据文件和索引文件");
		unlink(dstfn);
		unlink(idxdstfn);
		throw;
	}
	
	lgprintf("文件转换结束,目标文件:'%s',文件长度(字节):%f.",dstfn,dstfilelen);
	return 1;
}


int DestLoader::ToMySQLBlock(const char *dbn, const char *tabname)
{
	lgprintf("格式转换 '%s.%s' ...",dbn,tabname);
	AutoMt mt(psa->GetDTS(),100);
	mt.FetchAll("select * from dt_table where tabname=lower('%s') and databasename=lower('%s')",tabname,dbn);
	int rn=mt.Wait();
	if(rn<1) {
		printf("表'%s'不存在!",tabname);
		return 0;
	}
	tabid=mt.GetInt("tabid",0);
	datasetid=mt.GetInt("datasetid",0);
	int recordnum=mt.GetInt("recordnum",0);
	int firstdatafileid=mt.GetInt("firstdatafileid",0);
	int srctabid=abs(mt.GetInt("srctabid",0));
	if(recordnum<1) {
		lgprintf("源表'%s'数据为空.",tabname);
		return 0;
	}
	AutoMt mdt(psa->GetDTS(),MAX_DST_DATAFILENUM);
	AutoMt mdf(psa->GetDTS(),MAX_DST_DATAFILENUM);
	wociSetTraceFile("rawBlock格式转换/");
	mdf.FetchAll("select * from dt_datafilemap where datasetid=%d and procstatus =0 and (fileflag=0 or fileflag is null) order by indexid,subdatasetid,fileid",datasetid);
	rn=mdf.Wait();
	/*{
				AutoStmt st1(psa->GetDTS());
				st1.Prepare("update dt_taskschedule set taskstatus=%d where datasetid=%d",
				10,datasetid);
				st1.Execute(1);
				st1.Wait();
				st1.Prepare("update dt_datafilemap set procstatus =0 where datasetid=%d and fileflag=0",datasetid);
				st1.Execute(1);
				st1.Wait();
				lgprintf("文件转换任务已完成，任务状态已修改为%d,数据文件处理状态修改为空闲(0)",10);
				}
	*/
	//防止重入，修改数据文件状态。
	int fid=mdf.GetInt("fileid",0);
	char srcfn[300];
	strcpy(srcfn,mdf.PtrStr("filename",0));
	int origsize=mdf.GetInt("filesize",0);
	char dstfn[300];
	sprintf(dstfn,"%s.%s",srcfn,"dep5");
	tabid=mdf.GetInt("tabid",0);
	
	//dstf.SetFileHeader(0,srcf.GetNextFileName());
	//mdf.SetMaxRows(10);
	mdf.FetchAll("select filename from dt_indexfilemap where fileid=%d and fileflag!=2",
		fid);
	rn=mdf.Wait();
	char idxdstfn[300];
	sprintf(idxdstfn,"%s.%s",mdf.PtrStr("filename",0),"dep5");
	double dstfilelen=0;
	try {
		AutoStmt st(psa->GetDTS());
		st.Prepare("update dt_datafilemap set procstatus=1 where fileid=%d and procstatus=0 and fileflag!=2",
			fid);
		st.Execute(1);
		st.Wait();
		if(wociGetFetchedRows(st)!=1) {
			lgprintf("处理文件转换时状态异常,datasetid:%d,fid:%d,可能与其它进程冲突！"
				,datasetid,fid);
			return 1;
		}
		file_mt idxf;
		lgprintf("数据处理，数据文件:'%s',字节数:%d,索引文件:'%s'.",srcfn,origsize,mdf.PtrStr("filename",0));
		idxf.Open(mdf.PtrStr("filename",0),0);
		if(idxf.ReadBlock(-1,0)<0)
			ThrowWith("索引文件读取错误: '%s'",mdf.PtrStr("filename",0));
		
		file_mt srcf;
		srcf.Open(srcfn,0,fid);
		dt_file dstf;
		dstf.Open(dstfn,1,fid);
		mdf.SetHandle(srcf.CreateMt());
		int lastoffset=dstf.WriteHeader(mdf,0,fid,srcf.GetNextFileName());
		
		AutoMt *pidxmt=(AutoMt *)idxf;
		int idxrn=wociGetMemtableRows(*pidxmt);
		lgprintf("从索引文件读入%d条记录.",idxrn);
		int *pblockstart=pidxmt->PtrInt("blockstart",0);
		int *pblocksize=pidxmt->PtrInt("blocksize",0);
		int lastrow=0;
		int oldblockstart=pblockstart[0];
		int dspct=0;
		while(true) {//文件处理完退出
			int srcmt=srcf.ReadBlock(-1,0,1);
			if(srcmt==0) break;
			int tmpoffset=dstf.WriteMySQLMt(srcmt,COMPRESSLEVEL);
			int storesize=tmpoffset-lastoffset;
			for(;pblockstart[lastrow]==oldblockstart;) {
				pblockstart[lastrow]=lastoffset;
				pblocksize[lastrow++]=storesize;
			}
			if(++dspct>1000) {
				dspct=0;
				printf("\r...%d%% ",lastrow*100/idxrn);
				fflush(stdout);
				//			break;
			}
			lastoffset=tmpoffset;
			oldblockstart=pblockstart[lastrow];
		}
		dt_file idxdstf;
		idxdstf.Open(idxdstfn,1,fid);
		//mdf.SetHandle(idxf.CreateMt());
		idxdstf.WriteHeader(*pidxmt,idxrn,fid,idxf.GetNextFileName());
		dstfilelen=lastoffset;
		idxdstf.WriteMt(*pidxmt,COMPRESSLEVEL,0,false);
		dstf.Close();
		idxdstf.Close();
		st.Prepare("update dt_datafilemap set procstatus=2 where fileid=%d and procstatus=1 and fileflag=0",
			fid);
		st.Execute(1);
		st.Wait();
	}
	catch(...) {
		errprintf("数据转换出现异常，文件处理状态恢复...");
		AutoStmt st(psa->GetDTS());
		st.Prepare("update dt_datafilemap set procstatus=0 where fileid=%d and procstatus=1 and fileflag=0",
			fid);
		st.Execute(1);
		st.Wait();
		errprintf("删除数据文件和索引文件");
		unlink(dstfn);
		unlink(idxdstfn);
		throw;
	}
	
	lgprintf("文件转换结束,目标文件:'%s',文件长度(字节):%f.",dstfn,dstfilelen);
	return 1;
}
int DestLoader::RemoveTable(const char *dbn, const char *tabname,bool prompt)
{
	char sqlbuf[1000];
	char choose[200];
	wociSetEcho(FALSE); 
	lgprintf("remove table '%s.%s ' ...",dbn,tabname);
	AutoMt mt(psa->GetDTS(),MAX_DST_DATAFILENUM);
	AutoStmt st(psa->GetDTS());
	mt.FetchAll("select * from dt_table where tabname=lower('%s') and databasename=lower('%s')",tabname,dbn);
	int rn=mt.Wait();
	if(rn<1) {
		char fulltbname[300];
		sprintf(fulltbname,"%s.%s",dbn,tabname);
		if(prompt) {
			sprintf(choose,"表'%s.%s'将被删除(Y/N)",dbn,tabname);
			if(!GetYesNo(choose,false)) {
				lgprintf("取消删除。 ");
				return 0;
			}
		}
		sprintf(sqlbuf,"drop table %s.%s",dbn,tabname);
		lgprintf(sqlbuf);
		psa->DoQuery(sqlbuf);
		{
			lgprintf("删除DP参数文件.");
			char streamPath[300];
			mt.FetchAll("select * from dt_path where pathtype='msys'");
			if(mt.Wait()!=1) ThrowWith("查找基本目录失败，请检查dt_path表和同义词定义.");
			sprintf(streamPath,"%s%s/%s.DTP",mt.PtrStr("pathval",0),dbn,tabname);
			unlink(streamPath);
		}
		lgprintf("表'%s.%s'已删除.",dbn,tabname);
		return 0;
		//if(!psa->TouchTable(fulltbname)) {
		// printf("表'%s'不存在!\n",tabname);
		//return 0;
	}
	tabid=mt.GetInt("tabid",0);
	datasetid=mt.GetInt("datasetid",0);
	double recordnum=mt.GetDouble("recordnum",0);
	int firstdatafileid=mt.GetInt("firstdatafileid",0);
	int srctabid=mt.GetInt("srctabid",0);
	if(prompt) {
		if(recordnum<1)
			sprintf(choose,"DP表'%s.%s'将被删除，数据为空，继续？(Y/N)",dbn,tabname);
		else
			sprintf(choose,"DP表'%s.%s'将被删除，记录数:%.0f？(Y/N)",dbn,tabname,recordnum);
		if(!GetYesNo(choose,false)) {
			lgprintf("取消删除。 ");
			return 0;
		}			
	}
	psa->CloseTable(tabid,NULL,true);
	//	lgprintf("关闭源表，记录数：%d",recordnum);
	//	sprintf(sqlbuf,"update dt.dt_table set recordnum=0,firstdatafileid=0,datasetid=0,totalbytes=0 where tabid=%d",
	//		tabid);
	//	psa->DoQuery(sqlbuf);
	
	//FlushTables操作成功,标志着表删除操作对用户正式生效.
	//	lgprintf("MySQL刷新...");
	//	conn.FlushTables(dbn,tabname);//.DoQuery("flush tables ");
	
	//下面的查询不需要加fileflag!=2的限制条件，可以全部删除。
	mt.FetchAll("select * from dt_datafilemap where tabid=%d and datasetid=%d",
		tabid,datasetid);
	rn=mt.Wait();
	int i=0;
	for(i=0;i<rn;i++) {
		lgprintf("删除'%s'和附加的depcp,dep5文件",mt.PtrStr("filename",i));
		unlink(mt.PtrStr("filename",i));
		char tmp[300];
		sprintf(tmp,"%s.depcp",mt.PtrStr("filename",i));
		unlink(tmp);
		sprintf(tmp,"%s.dep5",mt.PtrStr("filename",i));
		unlink(tmp);
	}
	//下面的语句不需要加fileflag!=2的限制条件，可以全部删除。
	st.Prepare(" delete from dt_datafilemap where tabid=%d and datasetid=%d",tabid,datasetid);
	st.Execute(1);
	st.Wait();
	
	//下面的语句不需要加fileflag!=2的限制条件，可以全部删除。
	mt.FetchAll("select * from dt_indexfilemap where tabid=%d and datasetid=%d ",//and (fileflag=0 or fileflag is null)
		tabid,datasetid);
	rn=mt.Wait();
	for(i=0;i<rn;i++) {
		lgprintf("删除'%s'和附加的depcp,dep5文件",mt.PtrStr("filename",i));
		unlink(mt.PtrStr("filename",i));
		char tmp[300];
		sprintf(tmp,"%s.depcp",mt.PtrStr("filename",i));
		unlink(tmp);
		sprintf(tmp,"%s.dep5",mt.PtrStr("filename",i));
		unlink(tmp);
	}
	//下面的语句不需要加fileflag!=2的限制条件，可以全部删除。
	st.Prepare(" delete from dt_indexfilemap where tabid=%d and datasetid=%d"/*and fileflag=0 "*/,tabid,datasetid);
	st.Execute(1);
	st.Wait();
	
	if(srctabid<0) {
		st.Prepare(" delete from dt_table where tabid=%d",tabid);
		st.Execute(1);
		st.Wait();
		sprintf(sqlbuf,"drop table %s.%s",dbn,tabname);
		lgprintf(sqlbuf);
		psa->DoQuery(sqlbuf);
		mt.FetchAll("select * from dt_index where tabid=%d and issoledindex=1",tabid);
		rn=mt.Wait();
		for(i=0;i<rn;i++) {
			sprintf(sqlbuf,"drop table %s.%s",dbn,mt.PtrStr("indextabname",i));
			lgprintf(sqlbuf);
			psa->DoQuery(sqlbuf);
		}
		st.Prepare(" delete from dt_index where tabid=%d",tabid);
		st.Execute(1);
		st.Wait();
	}
	else psa->EmptyIndex(tabid);
	
	lgprintf("表'%s.%s'已删除.",dbn,tabname);
	return 1;
}

int SysAdmin::CleanData(bool prompt)
{
	AutoMt mt(dts,100);
	AutoStmt st(dts);
	mt.FetchAll("select tabid,datasetid,sum(recordnum) recordnum from dt_datafilemap where fileflag=2 group by tabid,datasetid");
	int rn=mt.Wait();
	if(rn<1) {
		printf("没有数据需要清空!");
		return 0;
	}
	lgprintf("永久删除数据...");
	//for(int i=0;i<rn;i++) {
	int tabid=mt.GetInt("tabid",0);
	int datasetid=mt.GetInt("datasetid",0);
	//	int recordnum=mt.GetInt("recordnum",0);
	char tbname[150],idxname[150];
	GetTableName(tabid,-1,tbname,idxname,TBNAME_FORDELETE);
	AutoMt dtmt(dts,MAX_DST_DATAFILENUM);
	dtmt.FetchAll("select filename from dt_datafilemap where tabid=%d and datasetid=%d and fileflag=2",
		tabid,datasetid);
	int frn=dtmt.Wait();
	AutoMt idxmt(dts,200);
	idxmt.FetchAll("select filename from dt_indexfilemap where tabid=%d and datasetid=%d and fileflag=2",
		tabid,datasetid);
	idxmt.Wait();
	//int firstdatafileid=mt.GetInt("firstdatafileid",0);
	//int srctabid=mt.GetInt("srctabid",0);
	if(prompt)
	{
		while(true) {
			printf("\n表 '%s': 将被删除，数据集编号:%d,继续?(Y/N)?",
				tbname,datasetid);
			char ans[100];
			fgets(ans,100,stdin);
			if(tolower(ans[0])=='n') {
				lgprintf("取消删除。 ");
				return 0;
			}
			if(tolower(ans[0])=='y') break;
		}
	}
	
	for(int j=0;j<frn;j++) {
		lgprintf("删除'%s'和附加的depcp,dep5文件",dtmt.PtrStr("filename",j));
		unlink(dtmt.PtrStr("filename",j));
		char tmp[300];
		sprintf(tmp,"%s.depcp",dtmt.PtrStr("filename",j));
		unlink(tmp);
		sprintf(tmp,"%s.dep5",dtmt.PtrStr("filename",j));
		unlink(tmp);
		lgprintf("删除'%s'和附加的depcp,dep5文件",idxmt.PtrStr("filename",j));
		unlink(idxmt.PtrStr("filename",j));
		sprintf(tmp,"%s.depcp",idxmt.PtrStr("filename",j));
		unlink(tmp);
		sprintf(tmp,"%s.dep5",idxmt.PtrStr("filename",j));
		unlink(tmp);
	}
	st.Prepare(" delete from dt_datafilemap where tabid=%d and datasetid=%d and fileflag=2",tabid,datasetid);
	st.Execute(1);
	st.Wait();
	st.Prepare(" delete from dt_indexfilemap where tabid=%d and datasetid=%d and fileflag=2",tabid,datasetid);
	st.Execute(1);
	st.Wait();
	//千万不能删!!!!!!!!!!!
	//st.Prepare(" delete from dt_table where tabid=%d",tabid);
	//st.Execute(1);
	//st.Wait();
	DropDTTable(tabid,TBNAME_FORDELETE);
	lgprintf("表'%s'及数据、索引文件已删除.",tbname);
	return 1;
}


void SysAdmin::DropDTTable(int tabid,int nametype) {
	char sqlbf[300];
	AutoMt mt(dts,MAX_DST_INDEX_NUM);
	char tbname[150],idxname[150];
	mt.FetchAll("select * from dt_index where tabid=%d and issoledindex=1",tabid);
	int rn=mt.Wait();
	if(rn<1) ThrowWith("找不到%d表的独立索引.",tabid);
	for(int i=0;i<rn;i++) {
		GetTableName(tabid,mt.GetInt("indexid",i),tbname,idxname,nametype);
		sprintf(sqlbf,"drop table %s",idxname);
		if(conn.TouchTable(idxname))
			DoQuery(sqlbf);
	}
	sprintf(sqlbf,"drop table %s",tbname);
	if(conn.TouchTable(tbname))
		DoQuery(sqlbf);
}

//		
//返回不含公共字段的索引字段数
//destmt:目标表的内存表,含字段格式信息
//indexid:索引编号
int SysAdmin::CreateIndexMT(AutoMt &idxtarget,int destmt,int indexid,int *colidx,char *colsname,bool update_idxtb) {
	bool ec=wociIsEcho();
	wociSetEcho(FALSE);
	AutoMt idxsubmt(dts,10);
	idxsubmt.FetchAll("select * from dt_index where indexid=%d and issoledindex=1",indexid);
	int rn=idxsubmt.Wait();
	if(rn<1) {
		ThrowWith("建立索引结构:在dt_index中无%d独立索引的记录。",indexid);
	}
	wociClear(idxtarget);
	strcpy(colsname,idxsubmt.PtrStr("columnsname",0));
	wociCopyColumnDefine(idxtarget,destmt,colsname);
	//查找该独立索引附带的非独立索引，并以此为依据建立索引表
	idxsubmt.FetchAll("select * from dt_index where reuseindexid=%d order by indexidinidxtab",
		indexid);
	int srn=idxsubmt.Wait();
	for(int j=0;j<srn;j++) {
		//重复的字段自动剔除
		wociCopyColumnDefine(idxtarget,destmt,idxsubmt.PtrStr("columnsname",j));
	}
	//重构索引复用段
	char reusedcols[300];
	int cn1;
	cn1=wociConvertColStrToInt(destmt,colsname,colidx);
	reusedcols[0]=0;
	int tcn=wociGetMtColumnsNum(idxtarget);
	if(tcn>cn1) {
		for(int i=cn1;i<tcn;i++) {
			if(i!=cn1) strcat(reusedcols,",");
			wociGetColumnName(idxtarget,i,reusedcols+strlen(reusedcols));
		}
		strcat(colsname,",");
		strcat(colsname,reusedcols);
	}
	if(update_idxtb) {
		lgprintf("修改索引%d的复用字段为'%s'.",indexid,reusedcols);
		AutoStmt st(dts);
		if(strlen(reusedcols)>0)
			st.Prepare("update dt_index set reusecols='%s' where indexid=%d",
			reusedcols,indexid);
		else
			st.Prepare("update dt_index set reusecols=null where indexid=%d",
			indexid);
		st.Execute(1);
		st.Wait();
	}
	
	//索引表公共字段
	wociAddColumn(idxtarget,"dtfid",NULL,COLUMN_TYPE_INT,10,0);
	wociAddColumn(idxtarget,"blockstart",NULL,COLUMN_TYPE_INT,10,0);
	wociAddColumn(idxtarget,"blocksize",NULL,COLUMN_TYPE_INT,10,0);
	wociAddColumn(idxtarget,"blockrownum",NULL,COLUMN_TYPE_INT,10,0);
	wociAddColumn(idxtarget,"startrow",NULL,COLUMN_TYPE_INT,10,0);
	wociAddColumn(idxtarget,"idx_rownum",NULL,COLUMN_TYPE_INT,10,0);
	idxtarget.Build();
	//取独立索引和复用索引在blockmt(目标数据块内存表)结构中的位置，
	// 检查结构描述文件建立的索引是否和系统参数表中指定的字段数相同。
	int bcn=cn1;//wociConvertColStrToInt(destmt,colsname,colidx);(colsname与reusedcols的内容相同）
	bcn+=wociConvertColStrToInt(destmt,reusedcols,colidx+bcn);
	if(wociGetColumnNumber(idxtarget)!=bcn+6) {
		ThrowWith("Column number error,colnum:%d,deserved:%d",
			wociGetColumnNumber(idxtarget),bcn+6);
	}
	//设置dt_index中的idxfieldnum
	if(update_idxtb) {
		lgprintf("修改%d索引及复用索引的字段总数为%d.",indexid,bcn);
		AutoStmt st(dts);
		st.Prepare("update dt_index set idxfieldnum=%d where indexid=%d or reuseindexid=%d",
			bcn,indexid,indexid);
		st.Execute(1);
		st.Wait();
	}
	wociSetEcho(ec);
	return bcn;
}

void SysAdmin::CreateAllIndexTable(int tabid,int destmt,int nametype,bool createidx,int ci_type) {
	AutoMt mt(dts,100);
	mt.FetchAll("select * from dt_index where tabid=%d and issoledindex=1 order by indexidindattab",tabid);
	int rn=mt.Wait();
	for(int i=0;i<rn;i++) 
		CreateIndexTable(mt.GetInt("indexid",i),-1,destmt,nametype,createidx);
}

//如果indexmt为-1，则destmt必须有效。
void SysAdmin::CreateIndexTable(int indexid,int indexmt,int destmt,int nametype,bool createidx,int ci_type) {
	AutoMt targetidxmt(dts,10);
	if(indexmt==-1) {
		int colidx[50];
		char colsname[300];
		int cn=CreateIndexMT(targetidxmt,destmt,indexid,colidx,colsname,false);
		indexmt=targetidxmt;
	}
	char tbname[100],idxname[100];
	GetTableName(-1,indexid,tbname,idxname,nametype);
	CreateTableOnMysql(indexmt,idxname,true);
	if(createidx) {
		//2005/12/01修改,增加创建索引表/目标表控制
		CreateIndex(indexid,nametype,true,ci_type);//tabname,idxtabname,0,conn,tabid,
		//indexid,true);
	}
}


int SysAdmin::CreateDataMtFromFile(AutoMt &destmt,int rownum,int tabid,int fileflag) {
	AutoMt mt(dts,10);
	//	mt.FetchAll("select filename from dt_datafilemap where tabid=%d and fileflag=%d and rownum<3",tabid,fileflag);
	mt.FetchAll("select filename from dt_datafilemap where tabid=%d and fileflag=%d limit 2",tabid,fileflag);
	int rn=mt.Wait();
	if(rn<1) ThrowWith("创建目标表结构时找不到数据文件。");
	dt_file idf;
	idf.Open(mt.PtrStr("filename",0),0);
	destmt.SetHandle(idf.CreateMt(rownum));
	return wociGetColumnNumber(destmt);
}

int SysAdmin::CreateIndexMtFromFile(AutoMt &indexmt,int rownum,int indexid) {
	AutoMt mt(dts,10);
	//	mt.FetchAll("select filename from dt_indexfilemap where indexid=%d and issoledindex=1 and (fileflag=0 or fileflag is null) and rownum<3",indexid);
	mt.FetchAll("select filename from dt_indexfilemap where indexid=%d and issoledindex=1 and (fileflag=0 or fileflag is null) limit 2",indexid);
	int rn=mt.Wait();
	if(rn<1) ThrowWith("创建索引表结构时找不到数据文件。");
	dt_file idf;
	idf.Open(mt.PtrStr("filename",0),0);
	indexmt.SetHandle(idf.CreateMt(rownum));
	return wociGetColumnNumber(indexmt);
}

void SysAdmin::OutTaskDesc(const char *prompt,int taskid,int tabid,int srctabid,int datasetid,int subdatasetid)
{
	AutoMt mt(dts,100);
	char tinfo[300];
	tinfo[0]=0;
	lgprintf(prompt);
	if(taskid>0 || datasetid>0) {
		mt.FetchAll("select * from dt_taskschedule where %s=%d",taskid>0?"taskid":"datasetid",taskid>0?taskid:datasetid);
		if(mt.Wait()<1) ThrowWith("错误的任务号:%d.",taskid);
		if(tabid==0) tabid=mt.GetInt("tabid",0);
		if(srctabid==0) srctabid=mt.GetInt("srctabid",0);
		lgprintf("任务描述:%s.",mt.PtrStr("datasetdetail",0));
		lgprintf("数据集编号 :%d.",mt.GetInt("datasetid",0));
	}
	if(subdatasetid>0) 
		lgprintf("数据子集编号:%d.",subdatasetid);
	if(srctabid>0) {
		mt.FetchAll("select concat(ss.sysname,':',srcschedulename,'.',srctabname) as srcdesc from dt_srctable st,dt_srcsys ss where st.srcsysid=ss.sysid and st.srctabid=%d",srctabid);
		if(mt.Wait()>0) 
			lgprintf("数据源 :%s.",mt.PtrStr("srcdesc",0));
	}
	if(tabid>0) {
		mt.FetchAll("select concat(databasename,'.',tabname) as dstdesc from dt_table where tabid=%d",tabid);
		if(mt.Wait()>0) 
			lgprintf("目标表 :%s.",mt.PtrStr("dstdesc",0));
	}
}
