//#include <cstring>
//#include <queue>
#include "dt_common.h"
#include "dt_svrlib.h"
#include <stdlib.h>
#include "zlib.h"
#include <lzo1x.h>
#include "lzo_asm.h"
#include <ucl.h>
#include <ucl_asm.h>
//#include <lzo1z.h>
//#include <lzo1c.h>
//#include <lzo1.h>
//#include <zzlib.h>
#include <bzlib.h>
#include "dtio.h"

#ifdef __unix
#define thread_rt void *
#define thread_end return NULL
#else
#include <process.h>
#define thread_rt void
#define thread_end return
#endif

//#define dbgprintf printf
#define dbgprintf
//using namespace std;
SvrAdmin *SvrAdmin::psa=NULL;
AutoHandle *SvrAdmin::pdts=NULL;
int SvrAdmin::svrstarted=0;
int SvrAdmin::shutdown=0;
#ifdef __unix
pthread_t SvrAdmin::hd_pthread_t;
#endif
int getMyRowLen(int *coltp,int *collen,int colct) ;

thread_rt Handle_Read(void *ptr) {
	dt_file *p=(dt_file *)ptr;
	while(1)
	{
		//数据可用并且已用过
		p->WaitBufEmpty(); //Lock buf empty,unlock buf empty by dt_file's main thread(ReadMT)
		//p->WaitBufReady(); //Lock buf ready
		if(p->Terminated()) {
			p->SetBufReady();
			break;
		}
		try {
			p->ReadMtThread();
		}
		catch(char *errstr) {
			p->SetReadError(errstr);
		}
		p->SetBufReady();
	}
	//p->ResetTerminated();
	thread_end; 
}

	dt_file::dt_file(bool _paral) {
		fp=NULL;
		openmode=0;
		fnid=0;
		filename[0]=0;
		bflen=0;filesize=0;pwrkmem=NULL;
		cmprslen=0;terminate=false;isreading=false;
		readedrn=bufrn=-1;
		readedoffset=bufoffset=curoffset=-1;
		readedblocklen=bufblocklen=-1;
		readedfnid=buffnid=-1;
		offlinelen=-1;
		blockbf=NULL;
		cmprsbf=NULL;
		offlineblock=NULL;
		if (lzo_init() != LZO_E_OK)
		{
		   ThrowWith("lzo_init() failed !!!\n");
		}
		paral=false;
		contct=0;
		SetParalMode(_paral);
		memset(errstr,0,sizeof(errstr));
		pdtio=NULL;pdtfile=NULL;
		delmaskbf=new char[(MAX_BLOCKRN+7)/8];
		memset(delmaskbf,0,(MAX_BLOCKRN+7)/8);
	}


	int dt_file::dtfseek(long offset) {
		if(pdtfile) pdtfile->SeekAt(offset);
		else return fseek(fp,offset,SEEK_SET);
		return (int)offset;
	}
	size_t dt_file::dtfread(void *ptr,size_t size) {
		if(pdtfile) return pdtfile->ReadBuf((char *)ptr,(unsigned long)size);
		return fread(ptr,1,size,fp);
	}	

 dt_file::~dt_file() {
		SetParalMode(false);
		if(blockbf) delete[]blockbf;
		if(cmprsbf) delete[]cmprsbf;
		if(pwrkmem) delete[]pwrkmem;
		if(offlineblock) delete[]offlineblock;
		Close();
		if(pdtio) delete pdtio;
		if(pdtfile) delete pdtfile;
		if(delmaskbf) delete []delmaskbf;
	}

void dt_file::SetStreamName(const char *sfn)
{
	if(pdtio!=NULL) delete pdtio;
	if(pdtfile!=NULL) delete pdtfile;
	pdtio=new dtioStreamFile("./");
	pdtio->SetStreamName(sfn);
	pdtio->SetWrite(false);
	pdtio->StreamReadInit();
	if(pdtio->GetStreamType()!=FULL_BACKUP) 
		ThrowWith("指定的文件不是原始备份文件!");
	pdtfile=new dtiofile(pdtio,true);
}

void dt_file::SetParalMode(bool val) {
	if(val) {
		if(paral) return;
		paral=val;
#ifdef __unix
	if(pthread_mutex_init(&buf_ready,NULL)!=0)
		ThrowWith("create mutex faid");
	if(pthread_mutex_init(&buf_empty,NULL)!=0)
		ThrowWith("create mutex faid");
	WaitBufEmpty();// Lock buf empty,in case thread reading.
	WaitBufReady();
	
	pthread_create(&hd_pthread_t,NULL,Handle_Read,(void *)this);
	pthread_detach(hd_pthread_t);
#else
	static int evtct=0;
	char evtname[100];
	sprintf(evtname,"dt_file_%d",evtct++);
	buf_ready=CreateEvent(NULL,false,false,evtname);
	sprintf(evtname,"dt_file_%d",evtct++);
	buf_empty=CreateEvent(NULL,false,false,evtname);
	WaitBufEmpty();// Lock buf empty,in case thread reading.
	WaitBufReady();
	_beginthread(Handle_Read,81920,(void *)this);
#endif
	}
	else {
	      if(paral) {
		if(isreading) 
		  WaitBufReady();
		terminate=true;
		SetBufEmpty();
		WaitBufReady();
		paral=false;
#ifdef __unix
		pthread_mutex_unlock(&buf_ready);
		pthread_mutex_destroy(&buf_empty);
#else
		CloseHandle(buf_ready);
		CloseHandle(buf_empty);
#endif
		}
		paral=false;
		isreading=false;
	}
}


	void dt_file::SetFileHeader(int rn,const char *nextfile) {
		if(!fp) ThrowWith("Write on open failed file at SetNextFile,filename:%s",filename);
		//file_hdr fh;
		//fread(&fh,sizeof(file_hdr),1,fp);
		if(nextfile==NULL) {
			fh.nextfile[0]=0;
			fh.islastfile=1;
		}
		else {
			strcpy(fh.nextfile,nextfile);
			fh.islastfile=0;
		}
		if(rn>0)
		 fh.rownum=rn;
		
		fseek(fp,0,SEEK_SET);
		fh.ReverseByteOrder();
                fwrite(&fh,sizeof(file_hdr),1,fp);
                fh.ReverseByteOrder();
		curoffset=sizeof(file_hdr);
	}
	//openmode 0:rb read 1:w+b 2:wb
	void dt_file::Open(const char *filename,int openmode,int fnid) {
		//索引数据文件和数据文件具有相同的fnid,openmode也有可能相同
		//if(fnid==this->fnid && fp && this->openmode==openmode) return;
		if(fp) fclose(fp);
		fp=NULL;
		//bk_lastrn=0;
		if(pdtio!=NULL && openmode!=0)
		    ThrowWith("Open file error!a stream packed file can only open in read mode.\n filename:%s,openmode:%d",
			filename,openmode);
		if(pdtio) pdtfile->OpenDtDataFile(filename);
		else {if(openmode==0) 
			fp=fopen(filename,"rb");
		      else if(openmode==1)
			fp=fopen(filename,"w+b");
		      else if(openmode==2) 
			fp=fopen(filename,"r+b");
		      if(!fp) ThrowWith("Open file error! filename:%s,openmode:%d",
			filename,openmode);
		}
		if(fnid==-1) this->fnid=0;
		else this->fnid=fnid;
		strcpy(this->filename,filename);
		this->openmode=openmode;
		//lastoffset=0;
		//if(openmode==1) WriteHeader(fnid);
		//else 
		curoffset=0;
		contct=0;
		//readedoffset=bufoffset=-1;readedblocklen=bufblocklen=-1;readedrn=
		if(openmode!=1) {
			if(pdtio) {
				filesize=pdtfile->GetFileLen();
			}
			else {
			 fseek(fp,0,SEEK_END);
			 filesize=ftell(fp);//_filelength(_fileno(fp));
			}
			dtfseek(0);
			ReadHeader();
			SetMySQLRowLen();
		}
		//if(openmode==0) {
		//	WaitBufEmpty();//Lock buf empty,in case thread reading.
		//}
		//touchedblock=false;
	}
    
	int dt_file::WriteHeader(int mt,int rn,int fid,const char *nextfilename) {
		if(!fp) ThrowWith("Write on open failed file,filename:%s",filename);
		fseek(fp,0,SEEK_SET);
		fh.fileflag=FILEFLAGEDIT;
		fh.fnid=fnid=fid;
		fh.islastfile=1;
		fh.rownum=rn;
	        void *pcd=NULL;
		if(!mt) {
			fh.cdlen=fh.cdnum=fh.rowlen=0;
		}
		else {
			wociReverseCD(mt);
			wociGetColumnDesc(mt,&pcd,fh.cdlen,fh.cdnum);
			char *pcd1=new char [fh.cdlen];
			memcpy(pcd1,pcd,fh.cdlen);
			pcd=pcd1;
			wociReverseCD(mt);
			fh.rowlen=wociGetRowLen(mt);
		}
		if(nextfilename) {
			fh.islastfile=false;
			strcpy(fh.nextfile,nextfilename);
		}
		else
		{
			fh.islastfile=true;
			fh.nextfile[0]=0;
		}
		//先保存，再做字节序的变换。
		int cdlen=fh.cdlen;
		memset(&fhe,0,sizeof(fhe));
		fhe.dtp_sync=1;
		fhe.ReverseByteOrder();
		fh.ReverseByteOrder();
		if(fwrite(&fh,sizeof(file_hdr),1,fp)!=1 ||
			fwrite(&fhe,sizeof(fhe),1,fp)!=1 ||
			fwrite(pcd,1,cdlen,fp)!=cdlen) 
			ThrowWith("Write file header failed! filename:%s,fnid:%d",
			   filename,fnid);
		fh.ReverseByteOrder();
		fhe.ReverseByteOrder();
		if(pcd!=NULL) delete [] (char *)pcd;
		curoffset=sizeof(file_hdr)+fh.cdlen+sizeof(fhe);
		return curoffset;
	}

	int dt_file::AppendRecord(const char *rec) {
		int off=readedoffset;
		int rn=1;
		int noff=GetFileSize();
		int startrow=0;
		char *outbf=offlineblock;
		memcpy(outbf,rec,mysqlrowlen);
		if(fhe.lst_blk_off>0)
		{
			startrow=rn=ReadMySQLBlock(fhe.lst_blk_off,0,&outbf);
			if(rn<MAX_BLOCKRN) {
				memcpy(outbf+rn*mysqlrowlen,rec,mysqlrowlen);
				rn++;
				noff=fhe.lst_blk_off;
			}
			else rn=1;
		}
		if(noff>MAX_DATAFILELEN) return -1;
		Open(filename,2,fnid);
		fseek(fp,0,SEEK_SET);
		fh.rownum++;
		fh.ReverseByteOrder();
        fwrite(&fh,sizeof(file_hdr),1,fp);
        fh.ReverseByteOrder();
		// modify file header extend area
		fhe.insertrn++;
		fhe.dtp_sync=0;
		fhe.ReverseByteOrder();
		fwrite(&fhe,sizeof(fhe),1,fp);
		fhe.ReverseByteOrder();

		//删除矩阵保持原有值
		delmaskbf[rn/8]^=(1<<(rn%8));
		fseek(fp,noff,SEEK_SET);
		WriteBlock(outbf,rn*mysqlrowlen,1,false,BLOCKFLAGEDIT);
		//恢复WriteBlock中对fh.rownum的增加
		if(fh.rowlen>0) fh.rownum-=rn;
		return startrow;			
	}

	int dt_file::WriteBlock(char *bf,unsigned int len,int compress,bool packed,char bflag) {
		if(!fp) ThrowWith("Write on open failed file,filename:%s",filename);
		if(fh.fileflag==FILEFLAGEDIT && !EditEnabled(bflag)) 
			ThrowWith("对文件'%s'的修改使用了不正确的块识别代码.",filename);
		if(packed) {
			block_hdr *pbh=(block_hdr *)bf;
                        pbh->ReverseByteOrder();
                        if(fwrite(bf,1,len,fp)!=len)
				ThrowWith("Write file failed! filename:%s,blocklen:%d,offset:%d",
					filename,len,curoffset);
			curoffset+=len;
			pbh->ReverseByteOrder();
                        if(fh.rowlen>0) fh.rownum+=(len-sizeof(block_hdr))/fh.rowlen;
			return curoffset;
		}
		
		block_hdr bh;
		bh.blockflag=bflag;
		bh.compressflag=compress;
		bh.origlen=len;
		bh.storelen=len;
		char *dstbf=bf;
		if(compress>0) {
			unsigned int len2=max((int)(len*1.2),1024);
			if(cmprslen<len2) {
				if(cmprsbf) delete [] cmprsbf;
				cmprsbf= new char[len2];
				if(!cmprsbf) ThrowWith("MemAllocFailed on WriteBlock len:%d,len/3:%d",
					len,len2);
				cmprslen=len2;
			}
			int rt=0;
			uLong dstlen=len2;
			/**********bzip2 compress**************/
			if(compress==10) {
				unsigned int dstlen2=len2;
				rt=BZ2_bzBuffToBuffCompress(cmprsbf,&dstlen2,bf,len,1,0,0);
				dstlen=dstlen2;
				dstbf=cmprsbf;
			}			
			/****   UCL compress **********/
			else if(compress==8) {
				unsigned int dstlen2=len2;
				rt = ucl_nrv2d_99_compress((Bytef *)bf,len,(Bytef *)cmprsbf, (unsigned int *)&dstlen2,NULL,5,NULL,NULL);
				dstlen=dstlen2;
				dstbf=cmprsbf;
			}			
			/******* lzo compress ****/
			else if(compress==5) {
				if(!pwrkmem)  {
				 pwrkmem = //new char[LZO1X_999_MEM_COMPRESS];
					new char[LZO1X_MEM_COMPRESS+204800];
                 memset(pwrkmem,0,LZO1X_MEM_COMPRESS+204800);
                }
				rt=lzo1x_1_compress((const unsigned char*)bf,len,(unsigned char *)cmprsbf,(unsigned int *)&dstlen,pwrkmem);
				dstbf=cmprsbf;
			}
		    /*** zlib compress ***/
			else if(compress==1) {
			 rt=compress2((Bytef *)cmprsbf,&dstlen,(Bytef *)bf,len,1);
			 dstbf=cmprsbf;
			}
			else 
				ThrowWith("Invalid compress flag %d",compress);
		    	if(rt!=Z_OK) {
				ThrowWith("Compress failed,datalen:%d,compress flag%d,errcode:%d",
					len,compress,rt);
			}
			else {
				bh.storelen=dstlen;
			}
		}
		int storelen=bh.storelen;
		unsigned int dml=0;
		dml=(len/GetBlockRowLen(bflag) +7)/8;
		bh.storelen+=dml+sizeof(dmh);
		dmh.rownum=len/GetBlockRowLen(bflag);
		dmh.deletedrn=0;
		dmh.ReverseByteOrder();
		bh.ReverseByteOrder();
		memset(delmaskbf,0,dml);
		if(fwrite(&bh,sizeof(block_hdr),1,fp)!=1 || 
			(EditEnabled(bflag) && fwrite(&dmh,sizeof(dmh),1,fp)!=1) ||
			(EditEnabled(bflag) && fwrite(delmaskbf,1,dml,fp)!=dml) ||
			fwrite(dstbf,1,storelen,fp)!=storelen)
			 ThrowWith("Write file failed! filename:%s,blocklen:%d,offset:%d",
			   filename,len,curoffset);
		curoffset+=sizeof(block_hdr)+storelen+(EditEnabled(bflag)?(dml+sizeof(dmh)):0);
		if(fh.rowlen>0) fh.rownum+=len/GetBlockRowLen(bflag);
		if(EditEnabled(bflag)) 
			dmh.ReverseByteOrder();
		return curoffset;
	}
	#define MAX_COLS_IN_DT 90
	
	
	int getMyRowLen(int *coltp,int *collen,int colct) {
		 int off=(colct+7)/8;
		 for(int i=0;i<colct;i++) {
			int clen=collen[i];
//			int slen;
			switch(coltp[i]) {
			case COLUMN_TYPE_CHAR	:
				clen--;
				off+=clen;
				break;
			case COLUMN_TYPE_FLOAT	:
			case COLUMN_TYPE_NUM	:
				clen+=2;
				off+=clen;
				break;
			case COLUMN_TYPE_INT	:
				off+=sizeof(int);
				break;
			case COLUMN_TYPE_BIGINT	:
				off+=sizeof(LONG64);
				break;
			case COLUMN_TYPE_DATE	:
				off+=sizeof(LLONG);
				break;
			default :
  	    ThrowWith("Invalid column type :%d,id:%d",coltp[i],i);
		    break;
			}
		}
		return off;
	}
		
	void setNullBit(char *buf, int colid)
	{
		static unsigned char marks[8]={1,2,4,8,16,32,64,128};
		buf[colid/8]|=(char )marks[colid%8];
	}

	int dt_file::WriteMySQLMt(int mt,int compress)
	{	
		if(!mt) 
  		 ThrowWith("check a empty memory table in dt_file::WriteMySQLMt,mt=NULL.");
  		int colct=wociGetColumnNumber(mt);
  		if(colct>MAX_COLS_IN_DT)
  		 ThrowWith("exceed maximun columns number, filename:%s,colnum:%d",
			   filename,colct);
		if(colct<1)
  		 ThrowWith("check a empty memory table in dt_file::WriteMySQLMt,colct:%d.",colct);
  		char *colptr[MAX_COLS_IN_DT];
  		int collen[MAX_COLS_IN_DT];
  		int colscale[MAX_COLS_IN_DT];
  		int coltp[MAX_COLS_IN_DT];
		wociAddrFresh(mt,colptr,collen,coltp);
		for(int lp=0;lp<colct;lp++) {
		 collen[lp]=wociGetColumnDataLenByPos(mt,lp);
		 colscale[lp]=wociGetColumnScale(mt,lp);
		 coltp[lp]=wociGetColumnType(mt,lp);
		}
		int rl=getMyRowLen(coltp,collen,colct);
		int rn=wociGetMemtableRows(mt);
		mysqlrowlen=rl;
		unsigned int bfl1=rl*rn;
		if(bfl1>bflen || !blockbf) {
			bflen=(unsigned int)(bfl1*1.3);
			if(blockbf) delete[]blockbf;
			blockbf=new char[bflen];
			if(!blockbf) ThrowWith("Memory allocation faild in WriteMt of dt_file,size:%d",bfl1);
		}
		char *buf=blockbf;
		for(int pos=0;pos<rn;pos++) {
		 int i,j;
		 bool filled=false;
	  	 int off=(colct+7)/8;
	 	 memset(buf,' ',rl);
	 	 memset(buf,0,off);
		 for(i=0;i<colct;i++) {
			int clen=collen[i];
			int slen;
			char *pdst=(char*)buf+off;
			
			switch(coltp[i]) {
			case COLUMN_TYPE_CHAR	:
				{
				clen--;
				char *src=(char *)(colptr[i]+(clen+1)*pos);
				if(*src!=0) {
					char *lst=(char *)memccpy(pdst,src,0,clen);
					if(lst) *--lst=' ';
				}
				else {
					setNullBit(buf,i);
				}
				}
				off+=clen;
				break;
			case COLUMN_TYPE_FLOAT	:
			case COLUMN_TYPE_NUM	:
				clen+=2;
				sprintf(pdst,"%.*f",colscale[i],((double *)colptr[i])[pos]);
				slen=(unsigned int) strlen(pdst);
				if (slen > clen)
					return 1;
				else
				{
				        //char *to=psrc(char *)buf+off;
					memmove(pdst+(clen-slen),pdst,slen);
					for (j=clen-slen ; j-- > 0 ;)
						*pdst++ = ' ' ;
				}
				off+=clen;
				break;
			case COLUMN_TYPE_INT	:
			         //以下语句在pa-risc平台会产生BUS-ERROR
				//*(int *)pdst=((int *)colptr[i])[pos];//*sizeof(int));
				//revInt(pdst);
				{
				int v=((int *)colptr[i])[pos];
				revInt(&v);
				memcpy(pdst,&v,sizeof(int));
				}
				slen=sizeof(int);
				off+=slen;
				break;
			case COLUMN_TYPE_BIGINT	:
			  //以下语句在pa-risc平台会产生BUS-ERROR
				//*(int *)pdst=((int *)colptr[i])[pos];//*sizeof(int));
				//revInt(pdst);
				{
				 LONG64 v=((LONG64 *)colptr[i])[pos];
				 revDouble(&v);
				 memcpy(pdst,&v,sizeof(LONG64));
				}
				slen=sizeof(LONG64);
				off+=slen;
				break;
		  default:
  	    ThrowWith("Invalid column type :%d,id:%d",coltp[i],i);
		    break;
			case COLUMN_TYPE_DATE	:
				{
				char *src=colptr[i]+7*pos;
				if(*src==0 || *src<118 || *src>120) {
					setNullBit(buf,i);
					off+=sizeof(LLONG);
				}
				else {
					LLONG mdt=0;
					mdt=LL(10000000000ll)*((src[0]-100)*100+src[1]-100);
				    mdt+=LL(100000000ll)*src[2];
					mdt+=LL(1000000ll)*src[3];
					mdt+=LL(10000)*(src[4]-1);
					mdt+=100*(src[5]-1);
					mdt+=src[6]-1;
					memcpy(pdst,&mdt,sizeof(LLONG));
					rev8B(pdst);
					off+=sizeof(LLONG);
				}
				break;
				}
			}
		}
		buf+=off;
	    }
	    return WriteBlock(blockbf,bfl1,compress,false,MYSQLBLOCKFLAGEDIT);
	}

	int dt_file::WriteMt(int mt,int compress,int rn) {
		rn=rn==0?wociGetMemtableRows(mt):rn;
		unsigned int bfl1=wociGetRowLen(mt)*rn;
		if(bfl1>bflen || !blockbf) {
			bflen=(unsigned int)(bfl1*1.3);
			if(blockbf) delete[]blockbf;
			blockbf=new char[bflen];
			if(!blockbf) ThrowWith("Memory allocation faild in WriteMt of dt_file,size:%d",bfl1);
		}
		wociExportSomeRows(mt,blockbf,0,rn);
		return WriteBlock(blockbf,bfl1,compress,false,BLOCKFLAGEDIT);
	}

int dt_file::CreateMt(int maxrows)
{
	if(curoffset!=sizeof(file_hdr)+(fh.fileflag==FILEFLAGEDIT?sizeof(fhe):0) )
		ReadHeader();
	if(fh.cdlen<1) 
		ThrowWith("CreateMt on file '%s' which does not include column desc info",filename);
	char *pbf=new char[fh.cdlen];
	if(dtfread(pbf,fh.cdlen)!=fh.cdlen) {
		delete [] pbf;
		ThrowWith("CreateMt read column desc info failed on file '%s'",
		   filename);
	}
	int mt=wociCreateMemTable();
	curoffset=sizeof(file_hdr)+fh.cdlen+(fh.fileflag==FILEFLAGEDIT?sizeof(fhe):0);
	wociImport(mt,NULL,0,pbf,fh.cdnum,fh.cdlen,maxrows,0);
	delete []pbf;
	return mt;
}

int dt_file::GetFirstBlockOffset() {
	return sizeof(file_hdr)+fh.cdlen+(fh.fileflag==FILEFLAGEDIT?sizeof(fhe):0);
}

int dt_file::SetMySQLRowLen() {
	int mt=CreateMt(1);
	if(!mt) 
  	  ThrowWith("check a empty memory table in dt_file::ReadHeader");
  	int colct=wociGetColumnNumber(mt);
  	if(colct>MAX_COLS_IN_DT)
  	 ThrowWith("exceed maximun columns number, filename:%s,colnum:%d",
			   filename,colct);
	if(colct<1)
  		 ThrowWith("check a empty memory table in dt_file::ReadHeader");
  	char *colptr[MAX_COLS_IN_DT];
  	int collen[MAX_COLS_IN_DT];
  	int colscale[MAX_COLS_IN_DT];
  	int coltp[MAX_COLS_IN_DT];
	wociAddrFresh(mt,colptr,collen,coltp);
	for(int lp=0;lp<colct;lp++) {
	 collen[lp]=wociGetColumnDataLenByPos(mt,lp);
	 colscale[lp]=wociGetColumnScale(mt,lp);
	 coltp[lp]=wociGetColumnType(mt,lp);
	}
	mysqlrowlen=getMyRowLen(coltp,collen,colct);
	wocidestroy(mt);
	return 0;
}
	
int dt_file::ReadHeader()
{
	dtfseek(0);
	if(dtfread(&fh,sizeof(file_hdr))!=sizeof(file_hdr)) 
		ThrowWith("Read file header error on '%s'",filename);
	fh.ReverseByteOrder();
	if(fh.fileflag==FILEFLAGEDIT && dtfread(&fhe,sizeof(fhe))!=sizeof(fhe)) 
		ThrowWith("Read file header error on '%s'",filename);
	curoffset=sizeof(file_hdr)+(fh.fileflag==FILEFLAGEDIT?sizeof(fhe):0);
	//oldoffset=lastoffset;
	//touchedblock=false;
	fnid=fh.fnid;
	return curoffset;
}

bool dt_file::OpenNext() {
 if(fh.islastfile!=0) return false;
 int oldfilesize=filesize;
 int oldcdlen=fh.cdlen;
 int oldfnid=fnid;
 Open(fh.nextfile,0);  
 if(oldcdlen!=fh.cdlen) 
	ThrowWith("同一索引数据集的两个数据文件字段格式不一致,fileid1:%d,cdlen1:%d,fileid2:%d,cdlen2:%d,filename2 '%s'",
		oldfnid,oldcdlen,fnid,fh.cdlen,filename);
 curoffset=GetFirstBlockOffset();
 dtfseek(curoffset);
 return true;
}

int dt_file::ReadMySQLBlock(int offset, int storesize,char **poutbf,int _singlefile)
{
	bool contread=false;
	int rn=ReadBlock(offset,storesize,contread,_singlefile);
	if(rn<0) return rn;
	block_hdr *pbh=(block_hdr *)cmprsbf;
	if(offlinelen<pbh->origlen) {
		if(offlineblock) delete []offlineblock;
		offlineblock=new char[int(pbh->origlen*1.2)+mysqlrowlen];
		offlinelen=int(pbh->origlen*1.2+mysqlrowlen);
	}
	memcpy(offlineblock,pblock,pbh->origlen);
	if(pbh->blockflag == MYSQLBLOCKFLAGEDIT) {
		char *pbf=cmprsbf+sizeof(block_hdr);
		memcpy(&dmh,pbf,sizeof(dmh));
		dmh.ReverseByteOrder();
		pbf+=sizeof(dmh);
		int dml=(pbh->origlen/mysqlrowlen+7)/8;
		memcpy(delmaskbf,pbf,dml);
	}

	if(contread && paral) {
	   if(curoffset<filesize ||(curoffset>=filesize && OpenNext())) {
	   	curblocklen=0;
	   	SetBufEmpty();// Start thread reading...
	   }
	}
	*poutbf=offlineblock;
	return rn;
}


int dt_file::GeneralRead(int offset,int storesize,AutoMt &mt,char **ptr,int clearfirst,int _singlefile)
{
	bool contread=false;
	int rn=ReadBlock(offset,storesize,contread,_singlefile);
	if(rn<0) return rn;
	
	block_hdr *pbh=(block_hdr *)cmprsbf;
	if(pbh->blockflag==MYSQLBLOCKFLAG || pbh->blockflag==MYSQLBLOCKFLAGEDIT) {
		if(offlinelen<pbh->origlen) {
			if(offlineblock) delete []offlineblock;
			offlineblock=new char[int(pbh->origlen*1.2)];
			offlinelen=int(pbh->origlen*1.2);
		}
		if(paral) {
			memcpy(offlineblock,pblock,pbh->origlen);
		    *ptr=offlineblock;
		}
		else *ptr=pblock;
	}
	else {
		if(clearfirst) {
			if(mt.GetMaxRows()<readedrn) {
				mt.SetMaxRows((int)(readedrn*1.3));
				mt.Build();
			}
			wociReset(mt);
		}
		wociAppendRows(mt,pblock,readedrn);
	}
	if(contread && paral) {
	   if(curoffset<filesize ||(curoffset>=filesize && OpenNext())) {
	   	curblocklen=0;
	   	SetBufEmpty();// Start thread reading...
	   }
	}
	return rn;
}


int dt_file::ReadBlock(int offset, int storesize,bool &contread,int _singlefile)
{
	bool bufok=false;
	contread=false,
	dbgprintf("DBG(ReadMt): isreading:%d,bufoffset:%d,offset:%d.\n",isreading,bufoffset,offset);
	if(isreading) {
		WaitBufReady();
	}
	if(offset==0 || offset<-1) 
		offset=GetFirstBlockOffset();
	else if(offset==-1) {
		if(readedoffset<GetFirstBlockOffset()) offset=GetFirstBlockOffset();//第一个文件的开始
		else offset=readedoffset+readedblocklen;
		if(offset>curoffset) offset=GetFirstBlockOffset();//已经跳到下一文件或者文件被重新复位(重新打开)
	}
	if(offset>filesize)
	 ThrowWith("读数据失败,指定位置超过文件最大长度,fileid:%d,offset:%d,filesize:%d,filename '%s'",
		fnid,offset,filesize,filename);
	//if(offset<GetFirstBlockOffset()) offset=GetFirstBlockOffset();
	dbgprintf("DBG(ReadMt):adj offset to%d,buffnid %d,fnid %d.\n",offset,buffnid,fnid);
	if(storesize<0) storesize=0;
	if(bufoffset!=offset || buffnid!=fnid) {
	   //连续文件检查
	   curblocklen=storesize;
	   curoffset=offset;
	   if(curoffset>=filesize && (_singlefile==1 || !OpenNext())) {
	   	dbgprintf("DBG(ReadMt) come to eof,curoffset:%d,filesize:%d,bufoffset:%d,offset:%d.\n",
	   	   curoffset,filesize,bufoffset,offset);
	   	return -1;
	   }
	   offset=curoffset;
	   SetBufEmpty();// Start thread reading...
	   WaitBufReady();// Wait Reading complete.
	}
	else {
		if(curoffset<bufoffset+bufblocklen)
		 curoffset=bufoffset+bufblocklen;
	}
	if(bufoffset==-2) 
	       ThrowWith(errstr);
	if(bufoffset!=offset) {
	 ThrowWith("读数据失败,fileid:%d,offset:%d,bufoffset:%d,filename '%s'",
		fnid,offset,bufoffset,filename);
	}
	
	if(readedoffset+readedblocklen==bufoffset) {
		if(contct>3) contread=true;
		else contct++;
	}
	else  {
		contct=0;
		dbgprintf("DBG(ReadMt) readedoff:%d,readedblocklen:%d,off+len %d,bufoffset:%d,break cont read.\n",
	          readedoffset,readedblocklen,readedoffset+readedblocklen,bufoffset);
	}
	readedrn=bufrn;
	readedoffset=bufoffset;
	
	readedblocklen=bufblocklen;
	readedfnid=buffnid;
	dbgprintf("DBG(ReadMt) Got %d rows from off %d,next should be %d.\n",readedrn,readedoffset,readedoffset+readedblocklen);
	return readedrn;
}
 
int dt_file::ReadMt(int offset, int storesize,AutoMt &mt,int clearfirst,int _singlefile,char *poutbf,BOOL forceparal)
{
	bool contread=false;
	int rn=ReadBlock(offset,storesize,contread,_singlefile);
	if(rn<0) return rn;
	if(poutbf) {
		block_hdr *pbh=(block_hdr *)cmprsbf;
		memcpy(poutbf,pbh,sizeof(block_hdr));
		memcpy(poutbf+sizeof(block_hdr),pblock,pbh->origlen);
	}
	else {
		block_hdr *pbh=(block_hdr *)cmprsbf;
		if(pbh->blockflag!=BLOCKFLAG && pbh->blockflag!=BLOCKFLAGEDIT) 
			ThrowWith("文件'%s'格式为MySQL,不允许dt_file::ReadMt调用.",filename);
		if(clearfirst) {
			if(mt.GetMaxRows()<readedrn) {
				mt.SetMaxRows((int)(readedrn*1.3));
				mt.Build();
			}
			wociReset(mt);
		}
		wociAppendRows(mt,pblock,readedrn);
	}
	if(contread && paral) {
	   //if(curoffset>=filesize && (_singlefile==1 || !OpenNext())) return -1;
	   if(curoffset<filesize ||(curoffset>=filesize && OpenNext())) {
	   	curblocklen=0;
	   	SetBufEmpty();// Start thread reading...
	   }
	}
	return readedrn;
}

// System parameter container
	int SysParam::BuildSrcDBCFromSrcTableID(int srctabid) {
		int srctabp=wociSearchIK(dt_srctable,srctabid);
		if(srctabp<0) ThrowWith("BuildSrcDBCFromSrcTableID has a invalid srctabid:%d",
			srctabid);
		int srcid=dt_srctable.GetInt("srcsysid",srctabp);
		int srcidp=wociSearchIK(dt_srcsys,srcid);
		if(srcidp<0) ThrowWith("BuildSrcDBCFromSrcTableID has a invalid srcsysid in dt_srcsys table:srcid=%d"
			,srcid);
		//int tabid=dt_srctable.GetInt("tabid",srctabp);
		return BuildSrcDBC(srcidp);
	};

	int SysParam::GetSoledInexParam(int srctabid,dumpparam *dp,int tabid) {
		int srctabp=wociSearchIK(dt_srctable,srctabid);
		if(tabid==-1)
              tabid=dt_srctable.GetInt("tabid",srctabp);
		int tabp=wociSearchIK(dt_table,tabid);
		AutoMt idxmt(dts,MAX_DST_INDEX_NUM);
		idxmt.FetchAll("select * from dt_index where tabid=%d and issoledindex=1 order by indexid limit %d",
			tabid,MAX_DST_INDEX_NUM);
		idxmt.Wait();
		int rn=idxmt.Wait();
		if(rn<1) ThrowWith("Cound not found primary index of tabid:%d",tabid);
		dp->rowlen=dt_table.GetInt("recordlen",tabp);
		if(dp->rowlen<1)
		  ThrowWith( "目标表的记录长度异常,请重新构造目标表结构.异常记录长度为%d,tabid:%d.",dp->rowlen,tabid) ;
		//AutoMt cdf(dts);
		for(int i=0;i<rn;i++) {
			/*
			cdf.Clear();
			cdf.FetchAll("select * from dt_cdfilemap where fileid=%d",
			 idxmt.GetInt("cdfileid",i));
			int rn1=cdf.Wait();
		        if(rn1<1) ThrowWith("Index column desc file not found in dt_cdfilemap,cdfileid:%d",idxmt.GetInt("cdfileid",i));
			strcpy(dp->idxp[i].cdsfilename,cdf.PtrStr("filename",0));
			dp->idxp[i].cdsfs=cdf.GetInt("filesize",0);
			dp->idxp[i].colnum=cdf.GetInt("columnnum",0);
			*/
			dp->idxp[i].colnum=idxmt.GetInt("idxfieldnum",i);
			strcpy(dp->idxp[i].idxcolsname,idxmt.PtrStr("columnsname",i));
			strcpy(dp->idxp[i].idxreusecols,idxmt.PtrStr("reusecols",i));
			dp->idxp[i].idxid=idxmt.GetInt("indexid",i);
			strcpy(dp->idxp[i].idxtbname,idxmt.PtrStr("indextabname",i));
			dp->idxp[i].idinidx=idxmt.GetInt("indexidinidxtab",i);
			dp->idxp[i].idindat=idxmt.GetInt("indexidindattab",i);
			if(idxmt.GetInt("issoledpindex",i)==1) 
				dp->psoledindex=i;
				
		}
		dp->tmppathid[0]=dt_srctable.GetInt("mddatafilepathid1",srctabp);
		//dp->tmppathid[1]=dt_srctable.GetInt("mddatafilepathid2",srctabp);
		strcpy(dp->tmppath[0],GetMySQLPathName(dp->tmppathid[0]));
		//strcpy(dp->tmppath[1],GetMySQLPathName(dp->tmppathid[1]));
		dp->dstpathid[0]=dt_srctable.GetInt("dstdatafilepathid1",srctabp);
		//dp->dstpathid[1]=dt_srctable.GetInt("dstdatafilepathid2",srctabp);
		strcpy(dp->dstpath[0],GetMySQLPathName(dp->dstpathid[0]));
		//strcpy(dp->dstpath[1],GetMySQLPathName(dp->dstpathid[1]));
		dp->soledindexnum=rn;
		dp->srctabid=srctabid;
		dp->maxrecnum=dt_srctable.GetInt("mdfilemaxrecnum",srctabp);
		dp->tabid=tabid;//dt_srctable.GetInt("tabid",srctabp);
		return rn;
	}


	int SysParam::GetFirstTaskID(TASKSTATUS ts,int &srctabid,int &datasetid) {
		AutoMt tasksch(dts);
		tasksch.FetchAll("select * from dt_taskschedule where begintime<sysdate() and taskstatus=%d order by begintime limit 10",ts);
		int rn=tasksch.Wait();
		if(rn<1) return 0;
		srctabid=tasksch.GetInt("srctabid",0);
		datasetid=tasksch.GetInt("datasetid",0);
		return tasksch.GetInt("taskid",0);
	};

	int SysParam::UpdateTaskStatus(TASKSTATUS ts,int taskid) {
		AutoStmt tasksch(dts);
		tasksch.Prepare("update dt_taskschedule set taskstatus=%d ,lastlaunchtime=launchtime,launchtime=? where taskid=%d and taskstatus<>%d",
			ts,taskid,ts);
		char dt[10];
		wociGetCurDateTime(dt);
		tasksch.BindDate(1,dt);
		tasksch.Execute(1);
		tasksch.Wait();
		int rn=wociGetFetchedRows(tasksch);
		if(rn<1) 
			ThrowWith("任务状态修改为%d时失败，可能是与其它进程冲突。\n"
				" 任务标号：%d.",ts,taskid);
		wociCommit(dts);
		return rn;
	};

	int SysParam::GetDumpSQL(int taskid,int partoffset,char *sqlresult) {
		AutoMt tasksch(dts);
		tasksch.FetchAll("select * from dt_taskschedule where taskid=%d limit 10",taskid);
		int rn=tasksch.Wait();
		if(rn<1) ThrowWith("Invalid taskid in GetDumpSQL ,taskid:%d",taskid);
		int partonly=tasksch.GetInt("onlypartid",0);
		int partid=tasksch.GetInt("partid",0);
		AutoMt srcpart(dts,MAX_DST_PART_NUM);
		int partn=0;
		if(partonly) {
		 srcpart.FetchAll("select * from dt_srcpartinfo where partid=%d",
			partid);
		 partn=srcpart.Wait();
		}
		else {
		 srcpart.FetchAll("select * from dt_srcpartinfo where srctabid=%d order by partid",
			tasksch.GetInt("srctabid",0)); 
		 partn=srcpart.Wait();
		}
		if(partn<1 && partonly) 
			ThrowWith("Partition information of taskid:%d could not found.",taskid);
		if(partoffset>=partn && partoffset) //if partonly and read once more , return -1
			return -1; //no more partitoin .
		int srctabp=wociSearchIK(dt_srctable,tasksch.GetInt("srctabid",0));
		if(srctabp<0) ThrowWith("BuildSrcDBCFromTaskID has a invalid srctabid where taskid=%d",
			tasksch.GetInt("taskid",0));
		sprintf(sqlresult,"select * from %s.%s ",
			dt_srctable.PtrStr("srcschedulename",srctabp),
			dt_srctable.PtrStr("srctabname",srctabp));
		if(partn) {
			char *cols=srcpart.PtrStr("columnsname",partoffset);
			char *bvals=srcpart.PtrStr("beginvalues",partoffset);
			char *evals=srcpart.PtrStr("endvalues",partoffset);
			BuildPartitionWhere(cols,bvals,evals,sqlresult+strlen(sqlresult));
			partid=srcpart.GetInt("partid",partoffset);
		}
		char *pmc=tasksch.PtrStr("morecondition",0);
		if(strlen(pmc)) 
			sprintf(sqlresult+strlen(sqlresult)," %s %s",partn?" and ":" where ",pmc);
		return partid;
	}

	const char *SysParam::GetMySQLPathName(int pathid,char *pathtype)
	{
		const char *rt=internalGetPathName(pathid,pathtype);
		if(!rt) ThrowWith("Could not found path value of column describe in dt_path table");
		if(xmkdir(rt)) ThrowWith("Path '%s' could create or change to\n",rt);
		return rt;
	}
	
	const char * SysParam::internalGetPathName(int pathid, char *pathtype)
	{
		if(pathtype==NULL) {
			int p=wociSearchIK(dt_path,pathid);
			if(p<0) return NULL;
			return dt_path.PtrStr("pathval",p);
		}
		int rn=wociGetMemtableRows(dt_path);
		int p=dt_path.GetPos("pathtype",COLUMN_TYPE_CHAR);
		for(int i=0;i<rn;i++) {
			if(STRICMP(dt_path.PtrStr(p,i),pathtype)==0) {
				return dt_path.PtrStr("pathval",i);
			}
		}
		return NULL;
	}

	int SysParam::NextFileID() {
		return GetSeqID("fileid");//"dt_fileid.nextval"
	}
	
	int SysParam::GetSeqID(const char *seqfield)
	{
		bool ec=wociIsEcho();
		wociSetEcho(FALSE);
		{
		 AutoStmt st(dts);
		 st.DirectExecute("lock tables dt_seq write");
		 st.DirectExecute("update dt_seq set %s=%s+1",seqfield,seqfield);
		}
		AutoMt seq(dts,10);
		//seq.FetchAll("select dt_tableid.nextval as fid from dual");
		seq.FetchAll("select %s as fid from dt_seq",seqfield);
		seq.Wait();
		{
		 AutoStmt st(dts);
		 st.DirectExecute("unlock tables");
		}
		wociSetEcho(ec);
		return seq.GetInt("fid",0);
	}
	
	int SysParam::NextTableID() {
		return GetSeqID("tabid");//"dt_tableid.nextval"
	}

	int SysParam::NextIndexID() {
		return GetSeqID("tabid");//"dt_indexid.nextval"
	}
	
	int SysParam::NextDatasetID() {
		return GetSeqID("datasetid");//"dt_datasetid.nextval.nextval"
	}

	void SysParam::Reload()
	{
	 dt_path.Clear();
	 dt_path.FetchAll("select * from dt_path");
	 dt_path.Wait();
	 wociSetIKByName(dt_path,"pathid");
	 wociOrderByIK(dt_path);
/*****************************/

	 dt_srctable.Clear();
	 dt_srctable.FetchAll("select * from dt_srctable");
	 dt_srctable.Wait();
	 wociSetIKByName(dt_srctable,"srctabid");
	 wociOrderByIK(dt_srctable);
	 wociSetSortColumn(dt_srctable,"tabid");
	 wociSort(dt_srctable);
     
/*****************************/
 	 dt_srcsys.Clear();
	 dt_srcsys.FetchAll("select * from dt_srcsys");
	 dt_srcsys.Wait();
/*****************************/
	 wociSetIKByName(dt_srcsys,"sysid");
	 wociOrderByIK(dt_srcsys);

	 dt_table.Clear();
	 dt_table.FetchAll("select * from dt_table order by tabid");
	 dt_table.Wait();
	 wociSetIKByName(dt_table,"tabid");
	 wociOrderByIK(dt_table);
	 wociSetSortColumn(dt_table,"tabname");
	 wociSort(dt_table);

	 dt_index.Clear();
	 dt_index.FetchAll("select * from dt_index order by indexid");
	 dt_index.Wait();
	 wociSetIKByName(dt_index,"indexid");
	 wociOrderByIK(dt_index);
	 wociSetSortColumn(dt_index,"tabid");
	 wociSort(dt_index);
/*****************************/
	}
	
	int SysParam::GetSrcTabid(int tabid,int &p) {
		void *ptr[2];
		ptr[0]=&tabid;
		ptr[1]=NULL;
		p=wociSearch(dt_srctable,ptr);
		if(p<0) ThrowWith("get srctabid from srctable with tabid error,tabid:%d",tabid);
		return dt_srctable.GetInt("srctabid",p);
	}
	bool SysParam::GetBlankTable(int &tabid)
	{
		int rows=wociGetMemtableRows(dt_table);
		int cdpos=dt_table.GetPos("cdfileid",COLUMN_TYPE_INT);
		for(int i=0;i<rows;i++) {
			if(*dt_table.PtrInt(cdpos,i)==0) {
				tabid=dt_table.GetInt("tabid",i);
				return true;
			}
		}
		return false;
	}


	void SysParam::GetSrcSys(int sysid,char *sysname,char *svcname,char *username,char *pwd)
	{
		int res=wociSearchIK(dt_srcsys,sysid);
		if(res<0) ThrowWith("srcsys get error,sysid:%d",sysid);
		dt_srcsys.GetStr("sysname",res,sysname);
		dt_srcsys.GetStr("svcname",res,svcname);
		dt_srcsys.GetStr("username",res,username);
		dt_srcsys.GetStr("pswd",res,pwd);
	}


int SysParam::BuildSrcDBC(int srcidp)
{
	char *pwd=dt_srcsys.PtrStr("pswd",srcidp);
	char pswd[200];
	if(!*pwd) {
		printf("SYSID:%d\nSVCNAME:%s\nUSERNAME:%s\n Input password:",
			dt_srcsys.GetInt("sysid",srcidp),dt_srcsys.PtrStr("svcname",srcidp),
			dt_srcsys.PtrStr("username",srcidp));
		scanf("%s",pswd);
		pwd=pswd;
	}
	else {
	  strcpy(pswd,pwd);
	  //decode(pswd);
	  pwd=pswd;
	}
	int systype=dt_srcsys.GetInt("systype",srcidp);
	if(systype!=1 && systype!=2) ThrowWith("源数据库系统的类型错误");
	if(systype==1)
	return wociCreateSession(dt_srcsys.PtrStr("username",srcidp),
			 pwd,dt_srcsys.PtrStr("svcname",srcidp),DTDBTYPE_ORACLE);
	else return wociCreateSession(dt_srcsys.PtrStr("username",srcidp),
			 pwd,dt_srcsys.PtrStr("svcname",srcidp),DTDBTYPE_ODBC);
}

int SysParam::GetMiddleFileSet(int procstate)
{
	AutoMt mdfile(dts);
	//mdfile.FetchAll("select * from dt_middledatafile where procstate=%d and rownum<2 ",procstate);
	// Not use limit 1 ,which means desc columns only for DT mysqld.
	mdfile.FetchAll("select * from dt_middledatafile where procstate=%d limit 2 ",procstate);
	int rn=mdfile.Wait();
	if(rn<1) return 0;
	int mt;
	AutoStmt st(dts);
	st.Prepare("select * from dt_middledatefile where subdataset=%d order by mdfid ",mdfile.GetInt("subdatasetid",0));
	mt=wociCreateMemTable();
	wociBuildStmt(mt,st,MAX_MIDDLE_FILE_NUM);
	wociFetchAll(mt);
	wociWaitLastReturn(mt);
	return mt;
}


int SysParam::GetMaxBlockRn(int tabid)
{
		int p=wociSearchIK(dt_table,tabid);
		if(p<0) ThrowWith("get maxrecinblock from table with tabid error,tabid:%d",tabid);
		return dt_table.GetInt("maxrecinblock",p);
}

int SysParam::GetMaxBlockRnFromSrcTab(int srctabid)
{
		int p=wociSearchIK(dt_srctable,srctabid);
		if(p<0) ThrowWith("get maxrecinblock from srctable with srctabid error,tabid:%d",srctabid);
		return GetMaxBlockRn(dt_srctable.GetInt("tabid",p));
}

thread_rt DT_CreateInstance(void *p) {
	SvrAdmin::CreateInstance();
	thread_end;
}

void SvrAdmin::CreateInstance()
{
	if(!pdts) return ;
	bool ec=wociIsEcho();
	wociSetEcho(FALSE);
	try {
	SvrAdmin *_psa=new SvrAdmin(*pdts);
	printf("reload dt parameters start.\n");
	_psa->Reload();
	psa=_psa;
	SetSvrStarted();
	ReleaseDTS();
	}
	catch(WDBIError &er) {
		int erc;
		char *buf;
		er.GetLastError(erc,&buf);
		fprintf(stderr,"Error code-%d: %s .\n",erc,buf);
		//throw buf;
	}
	catch(char *err) {
		fprintf(stderr," %s .\n",err);
		//throw err;
	}
        printf("reload end.\n");
        wociSetEcho(ec);
}

///* Database server extendted interface
	SvrAdmin *SvrAdmin::GetInstance() {
/*		if(psa==NULL ) {
                        void *pval=NULL;
			psa=(SvrAdmin *)0x0001;
#ifdef __unix
			pthread_create(&hd_pthread_t,NULL,DT_CreateInstance,(void *)pval);
			pthread_detach(hd_pthread_t);
#else
			_beginthread(DT_CreateInstance,81920,(void *)pval);
#endif
			//psa=new SvrAdmin(*pdts);
			//psa->Reload();
		}
*/		
		return svrstarted?(psa==(SvrAdmin *)0x1?NULL:psa):NULL;
	}
        
        SvrAdmin *SvrAdmin::RecreateInstance(const char *svcname,const char *usrnm,const char *pswd) {
          if(psa==(void *)0x1) return NULL;
          ReleaseInstance();
          void *pval=NULL;
          CreateDTS(svcname,usrnm,pswd);
#ifdef __unix
          pthread_create(&hd_pthread_t,NULL,DT_CreateInstance,(void *)pval);
          pthread_detach(hd_pthread_t);
#else
          _beginthread(DT_CreateInstance,81920,(void *)pval);
#endif
          return NULL;              //psa=new SvrAdmin(*pdts);
                        //psa->Reload();
        }

	void SvrAdmin::ReleaseInstance() {
		if(psa!=NULL && psa!=(void *)0x1) {
                  SvrAdmin *_psa=psa;
                  psa=(SvrAdmin *)0x1;
                  svrstarted=0;
                  delete _psa;
                }
	}
	
	int SvrAdmin::CreateDTS(const char *svcname,const char *usrnm,const char *pswd) {
		if(pdts==NULL) {
			pdts=new AutoHandle;
			try {
			pdts->SetHandle(wociCreateSession(usrnm,pswd,svcname,DTDBTYPE_ORACLE));
			}
			catch(WDBIError &er) {
				int erc;
				char *buf;
				er.GetLastError(erc,&buf);
				fprintf(stderr,"Error code-%d: %s .\n",erc,buf);
				throw buf;
			}
		}
		return *pdts;  
	}
	
	void SvrAdmin::ReleaseDTS() {
		if(pdts) 
			delete pdts;
		pdts=NULL;
	}
	
	int SvrAdmin::GetIndexStruct(int p) {
		int mt=wociCreateMemTable();
		wociAddColumn(mt,"idxidintab",NULL,COLUMN_TYPE_INT,0,0);
		wociAddColumn(mt,"idxidinidx",NULL,COLUMN_TYPE_INT,0,0);
		wociAddColumn(mt,"soledflag",NULL,COLUMN_TYPE_INT,0,0);
		wociAddColumn(mt,"tableoff",NULL,COLUMN_TYPE_INT,0,0);
		wociAddColumn(mt,"indexid",NULL,COLUMN_TYPE_INT,0,0);
		wociAddColumn(mt,"tabname",NULL,COLUMN_TYPE_CHAR,30,0);
		wociAddColumn(mt,"reuseindexid",NULL,COLUMN_TYPE_INT,0,0);
		wociAddColumn(mt,"idxfieldnum",NULL,COLUMN_TYPE_INT,0,0);
		wociAddColumn(mt,"databasename",NULL,COLUMN_TYPE_CHAR,20,0);
		wociBuild(mt,100);
		int tabid=dsttable.GetInt("tabid",p);
		char *pdbn=dsttable.PtrStr("databasename",p);
		int *ptab=dt_index.PtrInt("tabid",0);
		int *pidxtb=dt_index.PtrInt("indexidindattab",0);
		int	*pidxidx=dt_index.PtrInt("indexidinidxtab",0);
		int *pissoled=dt_index.PtrInt("issoledindex",0);
		int *pindexid=dt_index.PtrInt("indexid",0);
		int idxtabnamep=dt_index.GetPos("indextabname",COLUMN_TYPE_CHAR);
		int rn=wociGetMemtableRows(dt_index);
		int solect=0;
		int i;
		for( i=0;i<rn;i++ ) {
			if(ptab[i]!=tabid) continue;
			else {
				void *ptr[20];
				ptr[0]=pidxtb+i;
				ptr[1]=pidxidx+i;
				ptr[2]=pissoled+i;
				int soledflag=-1;
				if(pissoled[i]==1) soledflag=solect++;
				ptr[3]=&soledflag;
				ptr[4]=pindexid+i;
				ptr[5]=dt_index.PtrStr(idxtabnamep,i);
				ptr[6]=dt_index.PtrInt("reuseindexid",i);
				ptr[7]=dt_index.PtrInt("idxfieldnum",i);
				ptr[8]=pdbn;//dt_index.PtrInt("idxfieldnum",i);
				ptr[9]=NULL;
				wociInsertRows(mt,ptr,NULL,1);
			}
		}
		int totidxnum=GetTotIndexNum(p);
		//int *pissole=NULL;
		int *ptableoff=NULL;
		int *pidxid=NULL;
		int *preuseid;
		//wociGetIntAddrByName(mt,"soledflag",0,&pissole);
		wociGetIntAddrByName(mt,"tableoff",0,&ptableoff);
		wociGetIntAddrByName(mt,"reuseindexid",0,&preuseid);
		wociGetIntAddrByName(mt,"indexid",0,&pidxid);
		for(i=0;i<totidxnum;i++) {
			if(preuseid[i]>0) {
				for(int j=0;j<totidxnum;j++) {
					if(pidxid[j]==preuseid[i]) {
						ptableoff[i]=ptableoff[j];
						break;
					}
				}
			}
		}
		return mt;
	}

	int SvrAdmin::Search(const char *pathval) {
		void *ptr[2];
		ptr[0]=(void *)pathval;
		ptr[1]=NULL;
		return wociSearch(dsttable,ptr);
	}
 
	const char *SvrAdmin::GetFileName(int fileid) {
		int i=wociSearchIK(filemap,fileid);
		if(i<0) {
			lgprintf("Invalid file id :%d",fileid);
			return NULL;
		}
		return filemap.PtrStr(filenamep,i);
	}

	void SvrAdmin::Reload() {
		SysParam::Reload();
		filemap.FetchAll("select * from dt_datafilemap where fileflag is null or fileflag=0");
		filemap.Wait();
		wociSetIKByName(filemap,"fileid");
		wociOrderByIK(filemap);
		filenamep=filemap.GetPos("filename",COLUMN_TYPE_CHAR);

		wociClear(dsttable);
		wociAddColumn(dsttable,"tabid",NULL,COLUMN_TYPE_INT,0,0);
		wociAddColumn(dsttable,"soledindexnum",NULL,COLUMN_TYPE_INT,0,0);
		wociAddColumn(dsttable,"totindexnum",NULL,COLUMN_TYPE_INT,0,0);
		wociAddColumn(dsttable,"recordnum",NULL,COLUMN_TYPE_INT,0,0);
		wociAddColumn(dsttable,"pathval",NULL,COLUMN_TYPE_CHAR,300,0);
		wociAddColumn(dsttable,"firstfile",NULL,COLUMN_TYPE_CHAR,300,0);
		wociAddColumn(dsttable,"databasename",NULL,COLUMN_TYPE_CHAR,300,0);
		//wociAddColumn(dsttable,"colnum",NULL,COLUMN_TYPE_INT,0,0);
		int rn=wociGetMemtableRows(dt_table);
		dsttable.SetMaxRows(rn);
		dsttable.Build();
		for(int i=0;i<rn;i++) {
			int recnum=dt_table.GetInt("recordnum",i);
			if(recnum>0) {
				void *ptr[20];
				char pathval[300];
				ptr[0]=dt_table.PtrInt("tabid",i);
				ptr[1]=dt_table.PtrInt("soledindexnum",i);
				ptr[2]=dt_table.PtrInt("totindexnum",i);
				sprintf(pathval,"./%s/%s",dt_table.PtrStr("databasename",i),
					dt_table.PtrStr("tabname",i));
				ptr[3]=&recnum;
				ptr[4]=pathval;
				ptr[5]=(void *)GetFileName(dt_table.GetInt("firstdatafileid",i));
				ptr[6]=dt_table.PtrStr("databasename",i);
				if(ptr[5]==NULL) ptr[5]=(void *)"";//continue;
				ptr[7]=NULL;
				wociInsertRows(dsttable,ptr,NULL,1);
			}
		}
		wociSetSortColumn(dsttable,"pathval");
		wociSort(dsttable);
	}

const char * SvrAdmin::GetDbName(int p)
{
	return dsttable.PtrStr(6,p);
}

int dt_file::ReadMtThread()
{
	//if(curoffset!=readedoffset+readedblocklen) {
		dtfseek(curoffset);
	//}
	if(curblocklen==0) {
		block_hdr bh;
		if(dtfread(&bh,sizeof(block_hdr))!=sizeof(block_hdr))
		  ThrowWith("File read failed on '%s',offset:%d,size:%d",
			filename,curoffset,curblocklen);
		bh.ReverseByteOrder();
		if(!CheckBlockFlag(bh.blockflag))
		 ThrowWith("Invalid block flag on '%s' ,offset :%d",
			filename,curoffset);
		curblocklen=bh.storelen+sizeof(block_hdr);
		if(cmprslen<curblocklen) {
			if(cmprsbf) delete []cmprsbf;
			cmprsbf=new char[int(curblocklen*1.3)];
			cmprslen=int(curblocklen*1.3);
		}
		memcpy(cmprsbf,&bh,sizeof(block_hdr));
		if(dtfread(cmprsbf+sizeof(block_hdr),bh.storelen)!=bh.storelen)
		  ThrowWith("File read failed on '%s',offset:%d,size:%d",
			filename,curoffset,curblocklen);
	}
	else {
		if(cmprslen<curblocklen) {
			if(cmprsbf) delete []cmprsbf;
			cmprsbf=new char[int(curblocklen*1.3)];
			cmprslen=int(curblocklen*1.3);
		}
		if(dtfread(cmprsbf,curblocklen)!=curblocklen) {
			ThrowWith("File read failed on '%s',offset:%d,size:%d",
				filename,curoffset,curblocklen);
		}
		//直接在cmprsbf地址上作位序变换
		block_hdr *pbh1=(block_hdr *)cmprsbf;
		pbh1->ReverseByteOrder();
	}
	block_hdr *pbh=(block_hdr *)cmprsbf;
	int dml=0;
	if(!CheckBlockFlag(pbh->blockflag))
		ThrowWith("Invalid block flag on '%s' ,offset :%d",
			filename,curoffset);
	if(pbh->storelen+sizeof(block_hdr)!=curblocklen) 
		ThrowWith("Invalid block length on '%s' ,offset :%d,len:%d,should be:%d.",
			filename,curoffset,curblocklen,pbh->storelen+sizeof(block_hdr));
	bufoffset=curoffset;
	dbgprintf("DBG: ReadThread curoffset%d,bufoffset:%d.\n",curoffset,bufoffset);
	bufblocklen=curblocklen;
	buffnid=fnid;
	curoffset+=curblocklen;
	if(EditEnabled(pbh->blockflag)) {
		pblock=cmprsbf+sizeof(block_hdr);
		memcpy(&dmh,pblock,sizeof(dmh));
		dmh.ReverseByteOrder();
		pblock+=sizeof(dmh);
		dml=(pbh->origlen/GetBlockRowLen(pbh->blockflag)+7)/8;
		memcpy(delmaskbf,pblock,dml);
		pblock+=dml;
		dml+=sizeof(dmh);
	}
	else pblock=cmprsbf+sizeof(block_hdr);
	if(pbh->compressflag!=0) {
			int rt=0;
			if(bflen<pbh->origlen) {
				bflen=max(int(pbh->origlen*1.2),1024);
				if(blockbf) delete []blockbf;
				blockbf=new char[bflen];
			}
			int rcl=pbh->storelen-dml;
			uLong dstlen=bflen;;
			//zzlib
		    	/***************************
			if(pbh->compressflag==11) {
				memcpy(blockbf,bk_psrc,pbh->storelen);
				dstlen = ZzUncompressBlock((unsigned char *)bk_psrc);
				if(dstlen<0) rt=dstlen;
			}
			else 
			/****************************/
			//bzlib2
			if(pbh->compressflag==10) {
				unsigned int dstlen2=dstlen;
				rt=BZ2_bzBuffToBuffDecompress(blockbf,&dstlen2,pblock,rcl,0,0);
				dstlen=dstlen2;
				pblock=blockbf;
			}			
			/***********UCL decompress ***********/
			else if(pbh->compressflag==8) {
				unsigned int dstlen2=dstlen;
				//rt = ucl_nrv2d_decompress_asm_fast_8((Bytef *)bk_psrc,pbh->storelen,(Bytef *)blockbf,(unsigned int *)&dstlen2,NULL);
				rt = ucl_nrv2d_decompress_8((Bytef *)pblock,rcl,(Bytef *)blockbf,(unsigned int *)&dstlen2,NULL);
				dstlen=dstlen2;
				pblock=blockbf;
			}
			/******* lzo compress ****/
			else if(pbh->compressflag==5) {
				unsigned int dstlen2=dstlen;
				//rt=lzo1x_decompress_asm_fast((unsigned char*)bk_psrc,pbh->storelen,(unsigned char *)blockbf,&dstlen2,NULL);
				rt=lzo1x_decompress((unsigned char*)pblock,rcl,(unsigned char *)blockbf,&dstlen2,NULL);
				dstlen=dstlen2;
				pblock=blockbf;
			}
		    	/*** zlib compress ***/
			else if(pbh->compressflag==1) {
			 rt=uncompress((Bytef *)blockbf,&dstlen,(Bytef *)pblock,rcl);
			 pblock=blockbf;
			}
			else 
				ThrowWith("Invalid uncompress flag %d",pbh->compressflag);
		    	if(rt!=Z_OK) {
				ThrowWith("Decompress failed,fileid:%d,off:%d,datalen:%d,compress flag%d,errcode:%d",
					fnid,bufoffset,pbh->storelen,pbh->compressflag,rt);
			}
			else if(dstlen!=pbh->origlen) {
				ThrowWith("Decompress failed,fileid:%d,off:%d,datalen:%d,compress flag%d,decompress to len%d,should be %d.",
					fnid,bufoffset,pbh->storelen,pbh->compressflag,dstlen,pbh->origlen); 
			}
	}
	bufrn=pbh->origlen/GetBlockRowLen(pbh->blockflag);
	buforiglen=pbh->origlen;
	dbgprintf("DBG(ReadThread): off %d,coff %d,olen%d,len%d.\n",bufoffset,curoffset,buforiglen,bufblocklen);
	return bufrn;
}
/*
int dt_file::WaitEnd(int tm)
{
	#ifdef __unix
	int rt=pthread_mutex_lock(&hd_end);
	#else
	DWORD rt=WAIT_OBJECT_0;
	rt=WaitForSingleObject(hd_end,tm);
	#endif
	if(rt!=WAIT_OBJECT_0 && rt!=WAIT_TIMEOUT) {
		#ifndef __unix
		rt=GetLastError();
		#endif
		ThrowWith("Waitend failed ,code:%d",rt);
	}
	return rt;
}

void dt_file::Start()
{
	if(paral) {
#ifdef __unix
	 pthread_mutex_unlock(&hd_start);
#else
	SetEvent(hd_start);
#endif
	}
}
*/
int dt_file::WaitBufReady(int tm)
{
 dbgprintf("DBG:WaitBufReady.\n");
 if(paral) {
	#ifdef __unix
	int rt=pthread_mutex_lock(&buf_ready);
	#else
	DWORD rt=WAIT_OBJECT_0;
	rt=WaitForSingleObject(buf_ready,tm);
	#endif
	if(rt!=WAIT_OBJECT_0 && rt!=WAIT_TIMEOUT) {
		#ifndef __unix
		rt=GetLastError();
		#endif
		ThrowWith("Wait Buffer ready failed ,code:%d",rt);
	}
	dbgprintf("DBG:WaitBufReady(locked).\n");
 	isreading=false;
	return rt;
 }
 return 0;
}

int dt_file::WaitBufEmpty(int tm)
{
 dbgprintf("DBG:WaitBufEmpty.\n");
 if(paral) {
	#ifdef __unix
	int rt=pthread_mutex_lock(&buf_empty);
	#else
	DWORD rt=WAIT_OBJECT_0;
	rt=WaitForSingleObject(buf_empty,tm);
	#endif
	if(rt!=WAIT_OBJECT_0 && rt!=WAIT_TIMEOUT) {
		#ifndef __unix
		rt=GetLastError();
		#endif
		ThrowWith("Wait Buffer empty failed ,code:%d",rt);
	}
	dbgprintf("DBG:WaitBufEmpty(locked).\n");
	return rt;
 }
 return 0;
}

void dt_file::SetBufReady()
{
 dbgprintf("DBG:SetBufReady.\n");
 if(paral) {
	#ifdef __unix
	 pthread_mutex_unlock(&buf_ready);
	#else
	SetEvent(buf_ready);
	#endif
 }
}
 
void dt_file::SetBufEmpty()
{
 dbgprintf("DBG:SetBufEmpty.\n");
 if(paral) {
	isreading=true;
	#ifdef __unix
	 pthread_mutex_unlock(&buf_empty);
	#else
	SetEvent(buf_empty);
	#endif
 }
 else ReadMtThread();
}

#define CHARENC(a)  ((a)>25?('0'+(a)-26):('A'+(a)))
#define CHARDEC(a)  ((a)<'A'?((a)-'0'+26):((a)-'A'))
	
void encode(char *str) 
{
	char str1[17];
	char cd[35];
	int i;
	int len=strlen(str);
	if(len<2 || len>15) {
		printf("输入2-15个字符.\n");
		return;
	}
	static bool inited=false;
	if(!inited) {
	 srand( (unsigned)time( NULL ) );
	 inited=true;
	}
        for(i = len+1;   i < 17;i++ )
		 str[i]=rand()%127;
	int pos[]={13,8,9,14,7,0,10,1,4,12,5,15,6,2,11,3};
	for( i=0;i<16;i++) {
		str1[i]=str[pos[i]];
	}
	for(i=0;i<16;i++) {
		str1[i]^=str[16];//0x57;
		int off=(str[16]+i)%20;
		cd[2*i]=CHARENC((str1[i]>>4)+off);
		cd[2*i+1]=CHARENC((str1[i]&0x0f)+off);
	}
	cd[32]=CHARENC(str[16]>>4);
	cd[33]=CHARENC((str[16]&0x0f));
	cd[34]=0;
	printf("加密为:%s\n",cd);
	//return ;
	//m_strEnc.SetWindowText(cd);
	
	/***Decode 
	str1[16]=(CHARDEC(cd[32])<<4)+CHARDEC(cd[33]);
	for(i=0;i<16;i++) {
		int off=(str1[16]+i)%20;
		str1[i]=((CHARDEC(cd[2*i])-off)<<4)+CHARDEC(cd[2*i+1])-off;
		str1[i]^=str1[16];
	}
	for(i=0;i<16;i++) {
		str[pos[i]]=str1[i];
	}
	str[16]=0;
	printf("解密:%s\n",str);
	**************/
}

void decode(char *str) {
	char cd[40];
	char str1[20];
	int i;
	strcpy(cd,str);
	//Decode 
	str1[16]=(CHARDEC(cd[32])<<4)+CHARDEC(cd[33]);
	for(i=0;i<16;i++) {
		int off=(str1[16]+i)%20;
		str1[i]=((CHARDEC(cd[2*i])-off)<<4)+CHARDEC(cd[2*i+1])-off;
		str1[i]^=str1[16];
	}
	int pos[]={13,8,9,14,7,0,10,1,4,12,5,15,6,2,11,3};
	for(i=0;i<16;i++) {
		str[pos[i]]=str1[i];
	}
	str[16]=0;
}

int dt_file::SetLastWritePos(unsigned int off)
{
		if(!fp) ThrowWith("Write on open failed file at SetLastWritePos,filename:%s",filename);
		fhe.lst_blk_off=off;
		fhe.ReverseByteOrder();
		fseek(fp,sizeof(fh)+sizeof(fhe),SEEK_SET);
		fwrite(&fhe,sizeof(fhe),1,fp);
        fhe.ReverseByteOrder();
		curoffset=sizeof(file_hdr)+sizeof(fhe);
		return curoffset;
}

int file_mt::AppendMt(int amt, int compress, int rn)
{
		int startrow=0;
	    if(fhe.lst_blk_off>0)
		{
			int fmt=ReadMtOrBlock(fhe.lst_blk_off,0,1,NULL);
			if(fmt==0) return -1;
			startrow=GetRowNum();
			if(startrow+rn<MAX_APPEND_BLOCKRN) {
				wociCopyRowsTo(amt,fmt,-1,0,rn);
				dtfseek(GetOldOffset());
				WriteMt(fmt,compress);
				return startrow;
			}
		}
		unsigned int off=GetFileSize();
		dtfseek(GetFileSize());
		WriteMt(amt,compress,rn);
		SetLastWritePos(off);
		return startrow;
}
